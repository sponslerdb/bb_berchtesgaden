---
title: "site-wise niche-overlap by elevation"
output: html_document
---

Load packages 
```{r message=FALSE, warning=FALSE, include=FALSE, echo = FALSE}
library(bipartite)
library(mgcv)
library(mgcViz)
#library(GGally)
library(vegan)
library(ggvegan)
library(ggrepel)
#library(gridExtra)
library(tidyverse)
library(lubridate)
library(patchwork)
library(tidymodels)
```

Load data
```{r message=FALSE, warning=FALSE, include=FALSE, echo = FALSE}
# Site data
site_data <- read_csv("../processed_data/site_data.csv") %>%
  dplyr::select(-c(slope.calc, slope.est, elev.min, elev.max, temp.mean)) %>% # drop these variables
  mutate(elev.class = factor(elev.class, levels = c("unten", "mitte", "oben"))) # turn elav.class into an ordered factor

# BB traits
bb_traits <- read_csv("../processed_data/bb_traits.csv") %>%
  mutate(pbl.fac = factor(if_else(
    bb.sp %in% c("hort", "pasc", "wurf", "gers", "mend", "hypn"), "long", "short"))
    )

# FL traits
## family-level taxonomy
fl_tax <- read_csv("../processed_data/floral_tax.csv") 

## Kugler morphotypes (accessed through Bioflor)
fl_ktype <- read_csv("../processed_data/floral_k_type.csv") 

## diameter and corolla depth data from Gita Benadi
fl_morph <- read_csv("../processed_data/flower_morphology_GitaBenadi.csv") %>% 
  dplyr::select(SampleID, plant.family = Family, plant.sp = Species, 
                Unit, Flowers_per_unit, diam = Diameter, LN) %>%
  group_by(plant.sp) %>%
  summarize(diam = mean(diam), LN = mean(LN))

## verbal description of Kugler morphotypes
fl_ktype_key <- read_delim("../processed_data/kugler_key.tsv", delim = "\t", col_names = FALSE) %>%
  dplyr::select(k.type = 1, description = 2)

## join all trait tables
fl_traits <- fl_tax %>%
  full_join(fl_ktype) %>%
  full_join(fl_morph) %>%
  dplyr::select(plant.sp, plant.genus, plant.family, k.type, k.type.s, k.type.ss, diam, LN)

# Network
net <- read_csv("../processed_data/network.csv") %>%
  mutate(year = factor(year)) %>% # convert year to factor
  left_join(site_data, by = "site") %>% # add site data
  ungroup() %>%
  arrange(site, date) %>%
  left_join(fl_traits) %>% # add floral traits
  group_by(elev.class) %>%
  mutate(period = cut_interval(dayofyear, 3, labels = c("early", "mid", "late"))) # divide each elev.class into 3 equal time slices

# Floral survey
survey <- read_csv("../processed_data/floral_survey.csv") %>%
  semi_join(net, by = "plant.sp") %>% # Consider only plants visited (anytime anywhere, not specifically for a given site*date)
  dplyr::select(site, date, plant.sp, flower.cover) %>%
  left_join(fl_traits) # add floral traits
```

We will focus on six species that are abundant and widespread:  
  1. *B. sensu-strictu*
  2. *B. pascuorum*
  3. *B. pratorum*
  4. *B. hortorum*
  5. *B. soroensis*
  6. *B. wurflenii*

```{r fig.cap="**Figure 1: Focal species**", message=FALSE, warning=FALSE, echo=FALSE}
bb_range.year <- net %>%
  left_join(site_data) %>%
  group_by(site, elev.mean, bb.sp, year) %>%
  summarize(abund = n()) %>%
  group_by(bb.sp) %>%
  mutate(elev.floor = min(elev.mean),
         elev.ceiling = max(elev.mean),
         elev.range = elev.ceiling - elev.floor,
         elev.med = elev.floor + ((elev.ceiling - elev.floor)/2)) %>%
  mutate(focal = if_else(
    bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf"), TRUE, FALSE)
    )

ggplot(bb_range.year, aes(reorder(bb.sp, elev.med), elev.mean, color = focal)) +
  geom_line(size = 2, alpha = 0.25) +
  geom_point(aes(size = abund), alpha = 0.5) +
  facet_wrap(~year, ncol = 1) +
  theme_light(12) +
  scale_size_continuous(name = "Abundance") +
  scale_color_discrete(name = "Focal species") +
  xlab("BB species") +
  ylab("Elevation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggsave("./output/bb_range_year.pdf", height = 6, width = 6)
```

Functions
```{r, echo = FALSE}
# Convert PCoA to tidy array ("fortify")
pcoa_fort <- function(x){
  fortify(x, axes = 1:2) %>% 
  mutate(Score = case_when( # rename default scores to match my data
    Score == "species" ~ "FL.sp",
    Score == "sites" ~ "BB.sp"))
}

# Plot PCoA; to avoid overplotting, scores < min_score are not plotted
pcoa_plot <- function(x, min_score = 0.25) {
  
  # Add T.class variable for the BB.sp subset of the PCoA
  t.class <- x %>%
    filter(Score == "BB.sp") %>%
    mutate(T.class = factor(if_else(
      Label %in% c("hort", "pasc", "wurf", "gers", "mend", "hypn"), "long", "short"))
      )
  
  ggplot(filter(x, (abs(MDS1) > min_score | abs(MDS2) > min_score) | (Score == "BB.sp"))) + # no threshold for BB spp
    geom_polygon(data = t.class, aes(MDS1, MDS2, linetype = T.class), # draw polygons around T classes
                 color = "gray70", fill = NA, size = 1.25, key_glyph = "abline") +
    geom_point(aes(MDS1, MDS2, color = Score), size = 3, alpha = 0.75) + # add points
    ggrepel::geom_text_repel(aes(MDS1, MDS2, color = Score, label = Label), key_glyph = "rect") + # add labels
    theme_classic()
}


# Generates PCoAs, ADONIS tests, and ordination plots (fully aggregated)
## The ... represents the variables we will use to parse our analysis. For aggregate analysis, just leave the ...
## unpopulated, e.g. niche_analysis(net, bb_traits, plant.sp). 
## To parse by elev.class: niche_analysis(net, bb_traits, plant.sp)
## To parse by  elev.class, period, and pollen: niche_analysis(net, bb_traits, plant.sp, period, pollen)
## You get the idea. You should anyway -- you wrote it. https://tidyeval.tidyverse.org/multiple.html
niche_analysis <- function(x, y, criterion, ...) { 
  
  criterion <- enquo(criterion) # this argument toggles taxonomic (plant.sp) vs. morphological (k.type.s) analysis

  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # only focal species
    group_by(..., bb.sp, !!criterion) %>% # pooling all sites and years
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair
    group_by(..., bb.sp) %>%
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair
    dplyr::select(-freq) %>% # drop freq variable
    group_by(...) %>%
    nest() %>% # nest into list-column
    mutate(comm1 = map(data, # spread into the kind of array vegan likes
                       function(x) pivot_wider(x, names_from = !!criterion, values_from = prop) %>%
                         replace(is.na(.), 0)
                       ), 
           comm2 = map(comm1, # column to rowname
                       function(x) column_to_rownames(x, var = "bb.sp")
                       ),
           pcoa = map(comm2, # call PCoA
                      function(x) capscale(x ~ 1, distance = "horn")
                      ),
           traits = map(comm1, # join BB traits
                        function(x) x %>% 
                          left_join(y) %>% # y is the trait table, an argument in the main function call
                          column_to_rownames(var = "bb.sp") %>% 
                          select(pbl.fac) # pbl.fac is the variable I'm interested in
                        ),
           adonis = map2(comm2, traits, # run adonis permuatation test for distance ~ tongue class
                         function(x, y) adonis(x ~ pbl.fac, data = y, method = "horn")
                         ),
           betadis = map2(comm2, traits, # betadisper to test for difference in dispersion between tongue classes
                         function(x, y) x %>%
                           vegdist(method = "horn") %>% # betadisper runs a PCoA under the hood; match method to my PCoA
                           betadisper(group = y$pbl.fac) 
                         ),
           betadis.permutest = map(betadis, permutest), # perumutation test
           betadis.p = map(betadis.permutest, # extract betadisper p-value
                           function(x) x$tab$'Pr(>F)'[[1]]
                           ),
           betadis.boxplot = map(betadis, boxplot), # boxplot of betadisper
           pcoa.fort = map(pcoa, pcoa_fort), 
           pcoa.plot = map(pcoa.fort, pcoa_plot),
           adonis.r2 = map(adonis, # extract adonis r2
                           function(x) x$aov.tab$R2[[1]]
                           ),
           adonis.p = map(adonis, # extract adonis p-value
                          function(x) x$aov.tab$'Pr(>F)'[[1]]
                          ),
           MDS1 = map(pcoa, # extract eigenvalue for MDS1
                      function(x) x$CA$eig[[1]]
                      ), 
           MDS2 = map(pcoa, # extract eigenvalue for MDS2
                      function(x) x$CA$eig[[2]]
                      )) %>%
    unnest(cols = c(adonis.r2, adonis.p, betadis.p, MDS1, MDS2)) %>% # these are lists of length = 1, so unnesting them simply displays the value
    select(..., pcoa, betadis, betadis.permutest, betadis.p, adonis, 
           adonis.r2, adonis.p, betadis.boxplot, pcoa.plot, MDS1, MDS2) 
}

beta_func <- function(x, y, level, criterion, binary) {
  
  criterion <- enquo(criterion)
  level <- enquo(level)

  x %>% 
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    left_join(bb_traits) %>%
    #filter(!is.na(pollen)) %>%
    #group_by(pollen, site, !!level, !!criterion) %>%
    group_by(site, !!level, !!criterion) %>%
    summarize(freq = n()) %>%
    #group_by(pollen, site, !!level) %>%
    group_by(site, !!level) %>%
    mutate(prop = freq/sum(freq)) %>%
    #group_by(pollen, !!level) %>%
    group_by(!!level) %>%
    select(-freq) %>%
    nest() %>%
    mutate(comm = map(data, function(x) pivot_wider(x, names_from = !!criterion, values_from = prop, values_fill = 0)),
           comm2 = map(comm, function(x) column_to_rownames(x, var = "site")),
           dist = map(comm2, function(x) vegdist(x, method = "horn", binary = binary)),
           tidy.dist = map(dist, tidy),
           elevation = map(comm, function(x) left_join(x, y, by = "site") %>% 
                             select(site, elev.mean) %>% 
                             column_to_rownames(var = "site")),
           adonis = map2(comm2, elevation, function(x, y) adonis(x ~ elev.mean, data = y)),
           elev.r2 = map(adonis, function(x) x$aov.tab$R2[[1]]),
           elev.p = map(adonis, function(x) x$aov.tab$'Pr(>F)'[[1]])) %>%
    unnest(c(tidy.dist, elev.r2, elev.p)) %>%
    #select(!!level, pollen, site1 = item1, site2 = item2, distance, elev.r2, elev.p) %>%
    select(!!level, site1 = item1, site2 = item2, distance, elev.r2, elev.p) %>%
    left_join(select(site_data, site, elev.mean), by = c("site1" = "site")) %>%
    rename(elev1 = elev.mean) %>%
    left_join(select(site_data, site, elev.mean), by = c("site2" = "site")) %>%
    rename(elev2 = elev.mean) %>%
    mutate(elev.diff = abs(elev1 - elev2)) 
}

# Niche overlap by sp.pair * site * year
niche_overlapper <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
    group_by(bb.sp, pollen, !!criterion, site, year) %>% # group by site-year and BB-FL pair
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site-year
    group_by(bb.sp, pollen, site, year) %>% # group by site-year and BB species
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair
    dplyr::select(-freq) %>% # drop freq variable
    pivot_wider(names_from = !!criterion, values_from = prop) %>% # spread into the kind of array vegan likes
    replace(is.na(.), 0) %>% # replace NAs with zeros
    group_by(pollen, site, year) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    dplyr::select(pollen, site, year, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>% # unnest back into a single data frame
    left_join(site_data) %>% # add site data
    dplyr::select(site, year, pollen, bb.sp1 = item1, bb.sp2 = item2, distance, elev.mean) %>% # dplyr::select and rename vars
    left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>% # add traits for bb.sp1
    rename(subgenus1 = subgenus, pbl.w1 = pbl.w, pbl.w.class1 = pbl.w.class, pbl.fac1 = pbl.fac) %>%
    left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>% # add traits for bb.sp2
    rename(subgenus2 = subgenus, pbl.w2 = pbl.w, pbl.w.class2 = pbl.w.class, pbl.fac2 = pbl.fac) %>%
    dplyr::select(site, year, pollen, bb.sp1, bb.sp2, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, pbl.fac1, pbl.fac2, elev.mean) %>%
    left_join(BB_covars.splevel, by = c("bb.sp1" = "bb.sp", "site", "year", "pollen")) %>%
    rename(bb.sp1.abund = bb.sp.abund) %>%
    dplyr::select(site, year, pollen, bb.sp1, bb.sp2, bb.sp1.abund, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, pbl.fac1, pbl.fac2, elev.mean) %>%
    left_join(BB_covars.splevel, by = c("bb.sp2" = "bb.sp", "site", "year", "pollen")) %>%
    rename(bb.sp2.abund = bb.sp.abund) %>%
    dplyr::select(site, year, pollen, bb.sp1, bb.sp2, bb.sp1.abund, bb.sp2.abund, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, pbl.fac1, pbl.fac2, elev.mean) %>%
    mutate(pbl.diff = abs(pbl.w1 - pbl.w2), # tongue length differences
           pbl.fac.diff = if_else(pbl.fac1 == pbl.fac2, "same", "different"),
           abund.diff = abs(bb.sp1.abund - bb.sp2.abund),
           subgenus.diff = if_else(subgenus1 == subgenus2, "same", "different"), # binary: same or different subgenus
           
           # Logical columns indicating whether a given species belongs to a given species pair
           # This is handy for extracting data for individual species across all their counterparts
           bss = if_else(bb.sp1 == "bss" | bb.sp2 == "bss", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE)) %>%
    
    unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
    mutate(sp.pair = factor(sp.pair),
           pollen = factor(pollen)) %>% # ...and make it a factor so that mgcv can handle it
    left_join(BB_covars) %>% # add BB covars
    left_join(FL_covars) %>% # add floral covars
    mutate(niche.overlap = 1-distance) # express niche overlap so that 1 = perfect overlap and 0 = no overlap
}

niche_overlapper2 <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
    group_by(bb.sp, pollen, !!criterion, site) %>% # group by site-year and BB-FL pair
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site-year
    group_by(bb.sp, pollen, site) %>% # group by site-year and BB species
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair
    dplyr::select(-freq) %>% # drop freq variable
    pivot_wider(names_from = !!criterion, values_from = prop) %>% # spread into the kind of array vegan likes
    replace(is.na(.), 0) %>% # replace NAs with zeros
    group_by(pollen, site) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    dplyr::select(pollen, site, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>% # unnest back into a single data frame
    left_join(site_data) %>% # add site data
    dplyr::select(site, pollen, bb.sp1 = item1, bb.sp2 = item2, distance, elev.mean) %>% # dplyr::select and rename vars
    left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>% # add traits for bb.sp1
    rename(subgenus1 = subgenus, pbl.w1 = pbl.w, pbl.w.class1 = pbl.w.class, pbl.fac1 = pbl.fac) %>%
    left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>% # add traits for bb.sp2
    rename(subgenus2 = subgenus, pbl.w2 = pbl.w, pbl.w.class2 = pbl.w.class, pbl.fac2 = pbl.fac) %>%
    dplyr::select(site, pollen, bb.sp1, bb.sp2, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, pbl.fac1, pbl.fac2, elev.mean) %>%
    mutate(pbl.diff = abs(pbl.w1 - pbl.w2), # tongue length differences
           pbl.fac.diff = if_else(pbl.fac1 == pbl.fac2, "same", "different"),
           subgenus.diff = if_else(subgenus1 == subgenus2, "same", "different"), # binary: same or different subgenus
           
           # Logical columns indicating whether a given species belongs to a given species pair
           # This is handy for extracting data for individual species across all their counterparts
           bss = if_else(bb.sp1 == "bss" | bb.sp2 == "bss", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE)) %>%
    
    unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
    mutate(sp.pair = factor(sp.pair),
           pollen = factor(pollen)) %>% # ...and make it a factor so that mgcv can handle it
    mutate(niche.overlap = 1-distance) # express niche overlap so that 1 = perfect overlap and 0 = no overlap
}
```

# 1. What is the logic of niche partitioning between core species, and does it change through elevation and time?

For ordination-based analyses, I have opted to pool across years to emphasize species relationships rather than interannual differences. To aid interpretation, I have classified BB species by tongue length. The two "true" long-tongued species are *B. pascuorum* and *B. hortorum*, with the latter having a considerably longer tongue than the former, but I have opted to consider *B. wurflenii* as "behaviorally long-tongued" because it characteristically forages as a robber, and evidently converges in flower choice with *B. pascuorum* and *B. hortorum*. This decision was made *post-hoc* after noting the clustering patterns.

To avoid overplotting plant species / Kugler classes, I have only plotted species scoring above a given threshold on either the first or second axis. Thus, the plotted species are those that contribute most to the separation, not necessarily those that contribute most to diet. A species that is visited heavily by all BB species will fall close to (0,0) and will therefore not be plotted. 

## 1.1 Ordination by species with post-hoc fitting of tongue length  

**Results**  
1. The most salient pattern is that the long-tongued species cluster tightly with one another, especially in pollen foraging, while the short-tongued species are widely spread out. In other words, with respect to dietary niche space, long-tongued species converge while short-tongued species diverge.  

2. Broadly speaking, MDS1 explains the difference between short- and long-tongued species while MDS2 explains the separation within those groups.  

3. *Pollen foraging*: Long-tongued species were strongly associated with flag flowers (Kugler 6.1; *Trifolium pratense*, *Lotus corniculatus*, *Anthyllis vulneraria*) and the true lip flower (Kugler 5.1) *Rhinanthus glacialis*. Short-tongued species were more diffusely associated with disk/bowl flowers (Kugler 1.1-2; *Helianthemum nummularium*), flower heads (Kugler 7.1-2; *Phyteuma orbiculare*), and bell-shaped flowers of the sticky pollen persuasion (Kugler 3.2; *Campanula scheuchzeri*). 

4. *Nectar foraging*: Long-tongued species were strongly associated with true lip flowers (Kugler 5.1; *Rhinanthus glacialis*, *Salvia glutinosa*). Short-tongued species are more diffusely associated with Asteraceae flower heads (Kugler 7.2; *Carduus defloratus*, *Centaurea jacea*) and bell flowers with powdery pollen (Kugler 3.1; *Erica carnea*). *B. soroensis* was especially associated with the Asteraceae.  


**Discussion**
1. No surprises here with respect to the short-tongued/long-tongued divide; long-tonguers like deep/closed flowers, short-tonguers like shallow/open flowers. It is interesting, though, to see just how strongly B. wurflenii behaves as a long-tongued species. This is consistent, I suppose, with the generalization that deep/closed flowers off higher rewards. If you can rob, I guess you choose to rob the flowers that give you the highest reward rather than forage legitimately from open flowers. One thing that I find a bit puzzling is that these patterns hold for pollen as well as nectar; in fact, they are stronger for pollen than for nectar. Pollen collecting has nothing to do with tongue length, right? It's all in the legs. But I can guess at two explanations for this. First, just because a bee was noted as carrying pollen doesn't mean it was not nectar foraging (but it is probably safer to assume that a bee *not* carrying pollen was not foraging for pollen), so my pollen category probably represents a combination of pollen and nectar foraging. Second, and I think more convincingly, pollen and nectar foraging are not independent activities. A bee that learns to associate a given flower type with reward might be expected to return to that flower type to seek a different reward. And this "spillover" could end up being evolutionarily imprinted on the innate floral preferences BB spp. Right?  

2. Note how far-flung *B. sensu-strictu* tends to be. With respect to nectar foraging, this might have something to do with *B. ss*'s affinity for *Erica carnea*. But it seems to be a bit of a wildcard among our dominant *Bombus* spp.  

```{r message=FALSE, warning=FALSE, echo = FALSE}
# By plant.sp
niche.tax <- niche_analysis(net, bb_traits, criterion = plant.sp.abb)

## Extract and name plots
pollen.tax <- filter(niche.tax, pollen == "pollen")$pcoa.plot[[1]]
nectar.tax <- filter(niche.tax, pollen == "nopollen")$pcoa.plot[[1]]

## Display plots on grid
# pdf("../analyses/output/tax_niche.pdf", height = 6, width = 11)
# (pollen.tax | nectar.tax) + plot_layout(guides = 'collect')
# dev.off()

# By ktype
niche.morph <- niche_analysis(net, bb_traits, criterion = k.type.s)

## Extract and name plots
pollen.morph <- filter(niche.morph, pollen == "pollen")$pcoa.plot[[1]]
nectar.morph <- filter(niche.morph, pollen == "nopollen")$pcoa.plot[[1]]

## Display plots on grid
# pdf("../analyses/output/morph_niche.pdf", height = 6, width = 11)
# (pollen.morph | nectar.morph) + plot_layout(guides = 'collect') 
# dev.off()

## Taxonomic and morphological together
#pdf("../analyses/output/stack_niche.pdf", height = 8.5, width = 11)
(pollen.tax + ggtitle("Pollen/Taxonomic") | nectar.tax + ggtitle("Nectar/Taxonomic")) /
(pollen.morph + ggtitle("Pollen/Morphological") | nectar.morph + ggtitle("Nectar/Morphological")) + plot_layout(guides = 'collect') 
#dev.off()
```

## 1.2 Ordination by species with post-hoc fitting of tongue length, broken down by elevation class

**Results**  
1. The degree of separation between short- and long-tongued species varies markedly, as does the tightness of the clustering. At mid and high elevations, the patterns generally echo those described in the aggregate analysis above. At low elevations, though, the separation breaks down and the clustering relaxes. This is especially marked in nectar visitation.

2. *Pollen foraging*  

2.1  At low elevation, pollen foraging is a story of the true lip flower (Kugler 5.1) *Rhinanthus alectorolophus* for long-tonguers and flower heads (Kugler 7.1-2; *Centaurea jacea*, *Knautia arvensis*) for short-tonguers. Note that *Rhinanthus alectorolophus* is a different species of *Rhinanthus* than the one that was prominent in the aggregate analysis (*Rhinanthus glacialis*). 

2.2 At mid elevation, a bunch of morphological traits come into play. As in the aggregate analysis, long-tonguers are associated with flag flowers (Kugler 6.1; *Trifolium pratense*, *Anthyllis vulneraria*) and the true lip flower (Kugler 5.1) *Rhinanthus glacialis*. Short-tongue species, however, are spread along a wide and almost linear gradient with *B. sensu-strictu* on one end, *B. soroensis* on the other, and *B. pratorum* in the middle. Toward the *bss* end of the gradient, we have the disk/bowl flower (Kugler 1.2) *Hypericum maculatum* (actually K 1.1, but I think 1.1 and 1.2 scored very close to each other, but 1.1 was dropped by the overplotting threshold) and the unclassified flower (Kugler 0) *Plantago lanceolata*; I think unclassified flowers are those that Kugler reckoned to be wind-pollinated. On the *B. soroensis* end of the gradient, we have the flower head (Kugler 7.1) *Phyteuma orbiculare*. In the middle, near *B. pratorum*, we have the bell flower (Kugler 3.2) *Geum rivale*.

2.3. At high elevation, long-tonguers are still associate with flag flowers and true lip flowers, and indeed by *T. pratense* and *Anthyllis vulneraria*, but *Rhianthus* has been replaced by *Lotus corniculatus* (Kugler 6.1) and *Stachys alopecuros* (Kugler 5.1). Short-tonguers are widely spread and associated with the disk/bowl flower (Kugler 1.1-2) *Helianthemum nummularium*, the flower head (Kugler 7.1) *Phyteuma orbiculare*, and the bell flower (Kugler 3.2) *Campanula scheuchzeri*..  

3. *Nectar foraging*

3.1 At low elevation, there is little separation between long-tongued and short-tongued species. The most salient separation is that of *B. soroensis* from other species, driven by its apparent affinity for flower heads (Kugler 7.2; *Centaurea jacea*). *B. hortorum* and *B. pratorum*, despite their huge difference in tongue length, fall close to each other based on their shared affinity for the stalk-disc flower (Kugler 4.1) *Primula elatior*.

3.2 At mid elevation, short- and long-tongued species are separated more strongly. As we saw for pollen foraging, long-tongued species are associated with flag flowers (Kugler 6.1-2; *Polygala chamaebuxus*, *Anthyllis vulneraria*) and true lip flowers (Kugler 5.1; *Rhinanthus glacialis*, *Salvia glutinosa*). Short-tongued species were associated with the bell flower (Kugler 5.1) *Erica carnea*, the flower head (Kugler 7.2) *Centaurea jacea*, and the lip flower (Kugler 5.1) *Origanum vulgare*.

3.3 At high elevation, only two flower species stand out: *Carduus defloratus* (Kugler 7.2) and *Stachys alopecuros* (Kugler 5.1). Not surprisingly, the short-tongued species --- and especially *B. soroensis* --- leaned toward *Carduus* and the long-tongued species --- especially *B. hortorum* and *B. wurflenii* --- leaned toward *Stachys*. Interestingly, *B. pascuorum* and *B. pratorum* landed right next to each other in the middle of the spread. 

**Discussion**  
1. It is interesting, though not surprising, that morphological associations are relatively constant even though taxonimic associations (by necessity) turn over strongly.  

```{r message=FALSE, warning=FALSE, echo = FALSE}
# By plant.sp
niche_x_elev.tax <- niche_analysis(net, bb_traits, criterion = plant.sp.abb, elev.class)

## Extract and name plots
pollen_oben.tax <- filter(niche_x_elev.tax, pollen == "pollen" & elev.class == "oben")$pcoa.plot[[1]] + ggtitle("Pollen/Oben/Tax")
pollen_mitte.tax <- filter(niche_x_elev.tax, pollen == "pollen" & elev.class == "mitte")$pcoa.plot[[1]] + ggtitle("Pollen/Mitte/Tax")
pollen_unten.tax <- filter(niche_x_elev.tax, pollen == "pollen" & elev.class == "unten")$pcoa.plot[[1]] + ggtitle("Pollen/Unten/Tax")

nectar_oben.tax <- filter(niche_x_elev.tax, pollen == "nopollen" & elev.class == "oben")$pcoa.plot[[1]] + ggtitle("Nectar/Oben/Tax")
nectar_mitte.tax <- filter(niche_x_elev.tax, pollen == "nopollen" & elev.class == "mitte")$pcoa.plot[[1]] + ggtitle("Nectar/Mitte/Tax")
nectar_unten.tax <- filter(niche_x_elev.tax, pollen == "nopollen" & elev.class == "unten")$pcoa.plot[[1]] + ggtitle("Nectar/Unten/Tax")

# By ktype
niche_x_elev.morph <- niche_analysis(net, bb_traits, criterion = k.type.s, elev.class)

## Extract and name plots
pollen_oben.morph <- filter(niche_x_elev.morph, pollen == "pollen" & elev.class == "oben")$pcoa.plot[[1]] + ggtitle("Pollen/Oben/Morph")
pollen_mitte.morph <- filter(niche_x_elev.morph, pollen == "pollen" & elev.class == "mitte")$pcoa.plot[[1]] + ggtitle("Pollen/Mitte/Morph")
pollen_unten.morph <- filter(niche_x_elev.morph, pollen == "pollen" & elev.class == "unten")$pcoa.plot[[1]] + ggtitle("Pollen/Unten/Morph")

nectar_oben.morph <- filter(niche_x_elev.morph, pollen == "nopollen" & elev.class == "oben")$pcoa.plot[[1]] + ggtitle("Nectar/Oben/Morph")
nectar_mitte.morph <- filter(niche_x_elev.morph, pollen == "nopollen" & elev.class == "mitte")$pcoa.plot[[1]] + ggtitle("Nectar/Mitte/Morph")
nectar_unten.morph <- filter(niche_x_elev.morph, pollen == "nopollen" & elev.class == "unten")$pcoa.plot[[1]] + ggtitle("Nectar/Unten/Morph")

## Display plots on grid

## Pollen
pdf("../analyses/output/pollen_niche_x_elev.pdf", height = 8.5, width = 11)
(pollen_oben.morph | pollen_oben.tax) /
(pollen_mitte.morph | pollen_mitte.tax) /
(pollen_unten.morph | pollen_unten.tax) + plot_layout(guides = 'collect') 
dev.off()

## Nectar
pdf("../analyses/output/nectar_niche_x_elev.pdf", height = 8.5, width = 11)
(nectar_oben.morph | nectar_oben.tax) /
(nectar_mitte.morph | nectar_mitte.tax) /
(nectar_unten.morph | nectar_unten.tax) + plot_layout(guides = 'collect') 
dev.off()
```

## 1.3 Ordination by BB species * elev.class * period, pooling across years

**Results/Discussion**  
When we subdivide the visitation data by both time and elevation, we see that in many (if not most) elevation-time compartments, only a few floral species account for the niche patterns among BB species, and BB species of a given tongue length are often clustered around a single compatible floral species (though, remember, there could be many shared species that score near the origin and are therefore not plotted). For example, short-tongued bees foraging for nectar early in the season at mid elevation converged tightly around the open bell flower *Erica carnea* while the long-tongued species were able to spread out in the niche space provided by the deep-flowers *Polygala chamaebuxus*, *Primula elatior*, and *Gentiana verna*. Similarly, short-tongued bees foraging for nectar late in the season at low elevation were evidently forced to content themselves with *Centaurea jacea* while their long-tongued counterparts spread themselves broadly in the niche space provided by *Stachys officinalis*, *Lotus corniculatus*, and *Gentiana aspera*. This presents an interesting paradox worth unpacking. When aggregated through elevation and time, long-tongued species appear to be more tightly clustered in niche space, while short-tongued species are broadly spread. This suggests that the long-tongued species are either unable (due to incompatibility with open flowers or competition from short-tongued species) or unwilling (on account of the superior rewards offered by deep flowers) to diverge in niche space, while short-tongued species are either forced to diverge to relieve competition or else vary intrinsically in their preference for and compatibility with different open flower species. When we zoom into to smaller chunks of time and elevation, however, it is more often the short-tongued species that are pidgeon-holed in dietary niche space, presumably because most of the options are simply inaccessible to them on account of their short tongues, while long-tongued species can diverge among available deep flowers. This might suggest that potential competition is stronger among the long-tongued species, since their diet is regionally narrower, but realized competition is higher among short-tongued species, since their diet is locally narrower. This conclusion can only be drawn tentatively, though, since this ordination analysis shows how BB species separate, but it does not show the abundance or diversity of their floral hosts. 
```{r message=FALSE, warning=FALSE, echo = FALSE}
# By plant species
niche_x_elevperiod.tax <- niche_analysis(net, bb_traits, criterion = plant.sp.abb, elev.class, period)

## Extract and name plots
pollen_oben_early.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Pollen/Oben/Early/Tax")
pollen_oben_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Pollen/Oben/Mid/Tax")
pollen_oben_late.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Pollen/Oben/Late/Tax")

pollen_mitte_early.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Pollen/Mitte/Early/Tax")
pollen_mitte_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Pollen/Mitte/Mid/Tax")
pollen_mitte_late.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Pollen/Mitte/Late/Tax")

#pollen_unten_early.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]] +
  #ggtitle("Pollen/Unten/Early/Tax")
pollen_unten_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Pollen/Unten/Mid/Tax")
pollen_unten_late.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Pollen/Unten/Late/Tax")

nectar_oben_early.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Nectar/Oben/Early/Tax")
nectar_oben_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Nectar/Oben/Mid/Tax")
nectar_oben_late.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Nectar/Oben/Late/Tax")

nectar_mitte_early.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Nectar/Mitte/Early/Tax")
nectar_mitte_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Nectar/Mitte/Mid/Tax")
nectar_mitte_late.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Nectar/Mitte/Late/Tax")

nectar_unten_early.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Nectar/Unten/Early/Tax")
nectar_unten_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Nectar/Unten/Mid/Tax")
nectar_unten_late.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Nectar/Unten/Late/Tax")

# By ktype
niche_x_elevperiod.morph <- niche_analysis(net, bb_traits, criterion = k.type.s, elev.class, period)

## Extract and name plots
pollen_oben_early.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Pollen/Oben/Early/Tax")
pollen_oben_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Pollen/Oben/Mid/Tax")
pollen_oben_late.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Pollen/Oben/Late/Tax")

pollen_mitte_early.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Pollen/Mitte/Early/Tax")
pollen_mitte_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Pollen/Mitte/Mid/Tax")
pollen_mitte_late.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Pollen/Mitte/Late/Tax")

#pollen_unten_early.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]] +
  #ggtitle("Pollen/Unten/Early/Tax")
pollen_unten_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Pollen/Unten/Mid/Tax")
pollen_unten_late.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Pollen/Unten/Late/Tax")

nectar_oben_early.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Nectar/Oben/Early/Tax")
nectar_oben_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Nectar/Oben/Mid/Tax")
nectar_oben_late.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Nectar/Oben/Late/Tax")

nectar_mitte_early.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Nectar/Mitte/Early/Tax")
nectar_mitte_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Nectar/Mitte/Mid/Tax")
nectar_mitte_late.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Nectar/Mitte/Late/Tax")

nectar_unten_early.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]] +
  ggtitle("Nectar/Unten/Early/Tax")
nectar_unten_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]] +
  ggtitle("Nectar/Unten/Mid/Tax")
nectar_unten_late.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]] +
  ggtitle("Nectar/Unten/Late/Tax")

## Display plots on grid
pdf("../analyses/output/tax_niche_x_elevperiod_pollen.pdf", height = 8.5, width = 11)
(pollen_oben_early.tax | pollen_oben_mid.tax | pollen_oben_late.tax) /
(pollen_mitte_early.tax | pollen_mitte_mid.tax | pollen_mitte_late.tax) /
(plot_spacer() | pollen_unten_mid.tax  | pollen_unten_late.tax)  + plot_layout(guides = 'collect') 
dev.off()

pdf("../analyses/output/tax_niche_x_elevperiod_nectar.pdf", height = 8.5, width = 11)
(nectar_oben_early.tax | nectar_oben_mid.tax | nectar_oben_late.tax) /
(nectar_mitte_early.tax | nectar_mitte_mid.tax | nectar_mitte_late.tax) /
(nectar_unten_early.tax | nectar_unten_mid.tax  | nectar_unten_late.tax)  + plot_layout(guides = 'collect') 
dev.off()

pdf("../analyses/output/morph_niche_x_elevperiod_pollen.pdf", height = 8.5, width = 11)
(pollen_oben_early.morph | pollen_oben_mid.morph | pollen_oben_late.morph) /
(pollen_mitte_early.morph | pollen_mitte_mid.morph | pollen_mitte_late.morph) /
(plot_spacer() | pollen_unten_mid.morph  | pollen_unten_late.morph)  + plot_layout(guides = 'collect') 
dev.off()

pdf("../analyses/output/morph_niche_x_elevperiod_nectar.pdf", height = 8.5, width = 11)
(nectar_oben_early.morph | nectar_oben_mid.morph | nectar_oben_late.morph) /
(nectar_mitte_early.morph | nectar_mitte_mid.morph | nectar_mitte_late.morph) /
(nectar_unten_early.morph | nectar_unten_mid.morph  | nectar_unten_late.morph)  + plot_layout(guides = 'collect') 
dev.off()
```

## 1.4 A follow up to the question of resource range in long- vs. short-tongued BB species

```{r}
res.rang_x_tongue_x_siteperiod <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  left_join(bb_traits) %>%
  filter(!is.na(pollen)) %>%
  group_by(elev.class) %>%
  mutate(period = cut_interval(dayofyear, 3, labels = c("early", "mid", "late"))) %>%
  group_by(site, pollen, period, pbl.fac, plant.sp) %>% # group by site, date, bee species, plant species
  summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
  unite(webID, c(site, pollen, period), sep = "_") %>%
  ungroup() %>%
  dplyr::select(higher = pbl.fac, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
  data.frame() %>% # convert to data frame
  frame2webs() %>% # convert to to bipartite web
  map(specieslevel, level = "higher", index = c("resource range", "partner diversity", 
                                                "species specificity", "proportional generality")) %>%
  map(rownames_to_column) %>%
  map(as_tibble) %>%
  bind_rows(.id = "webID") %>% # Collapse list into big data frame
  rename(pbl.fac = rowname) %>%
  separate(webID, c("site", "pollen", "period"), sep =  "_") %>%
  left_join(site_data) %>%
  filter(pbl.fac %in% c("long", "short")) %>% # for some reason, a few rows have a "1" for pbl.fac, and I don't know where this comes from; this gets rid of it, but I would still like to know why
  mutate(site = factor(site),
         pollen = factor(pollen)) %>%
  mutate(period = factor(period, levels = c("early", "mid", "late"))) %>%
  mutate(resource.range = 1-resource.range)

ggplot(res.rang_x_tongue_x_siteperiod, aes(elev.mean, resource.range, color = pbl.fac)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_grid(pollen ~ period)
ggsave("./output/resource_range_x_tongue.pdf", width = 6, height = 4)

ggplot(res.rang_x_tongue_x_siteperiod, aes(elev.mean, partner.diversity, color = pbl.fac)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_grid(pollen ~ period)

ggplot(res.rang_x_tongue_x_siteperiod, aes(elev.mean, species.specificity.index, color = pbl.fac)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_grid(pollen ~ period)

ggplot(res.rang_x_tongue_x_siteperiod, aes(elev.mean, proportional.generality, color = pbl.fac)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_grid(pollen ~ period)

abundance_x_tongue_x_siteperiod <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  group_by(elev.class) %>%
  mutate(period = cut_interval(dayofyear, 3, labels = c("early", "mid", "late"))) %>%
  left_join(bb_traits) %>%
  filter(!is.na(pollen)) %>%
  group_by(site, period, pbl.fac) %>% # group by site, date, bee species, plant species
  summarize(abund = n()) %>%
  left_join(site_data)

ggplot(abundance_x_tongue_x_siteperiod, aes(elev.mean, abund, color = pbl.fac)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~period)
```

## 1.5 How do abundant generalist bumble bees deal with a dynamic floral community? Based on the ordination analysis, it looks like they maintain fairly steady morphological preferences, but they are taxonomically flexible. Let's take a closer look at that.

Right now, I am calculating beta-diversity on the basis of presence-absence; if I calculate based on relative abundance, it is extremely high. 
```{r}
# Beta-diversity tables
## Binary
beta.tax.sp.bin <- beta_func(net, site_data, level = bb.sp, 
                             criterion = plant.sp, binary = TRUE) %>%
  mutate(criterion = rep("tax", n()))
beta.tax.guild.bin <- beta_func(net, site_data, level = pbl.fac,
                                criterion = plant.sp, binary = TRUE) %>%
  mutate(criterion = rep("tax", n()))

beta.morph.sp.bin <- beta_func(net, site_data, level = bb.sp,
                               criterion = k.type.s, binary = TRUE) %>%
  mutate(criterion = rep("morph", n()))
beta.morph.guild.bin <- beta_func(net, site_data, level = pbl.fac,
                                  criterion = k.type.s, binary = TRUE) %>%
  mutate(criterion = rep("morph", n()))

beta.sp.bin <- bind_rows(beta.tax.sp.bin, beta.morph.sp.bin)
beta.guild.bin <- bind_rows(beta.tax.guild.bin, beta.morph.guild.bin)

## Not binary
beta.tax.sp <- beta_func(net, site_data, level = bb.sp,
                         criterion = plant.sp, binary = FALSE) %>%
  mutate(criterion = rep("tax", n()))
beta.tax.guild <- beta_func(net, site_data, level = pbl.fac,
                            criterion = plant.sp, binary = FALSE) %>%
  mutate(criterion = rep("tax", n()))

beta.morph.sp <- beta_func(net, site_data, level = bb.sp,
                           criterion = k.type.s, binary = FALSE) %>%
  mutate(criterion = rep("morph", n()))
beta.morph.guild <- beta_func(net, site_data, level = pbl.fac, 
                              criterion = k.type.s, binary = FALSE) %>%
  mutate(criterion = rep("morph", n()))

beta.sp <- bind_rows(beta.tax.sp, beta.morph.sp)
beta.guild <- bind_rows(beta.tax.guild, beta.morph.guild)


# Pull out ADONIS results
## Binary
beta.tax.sp.adonis.bin <- beta.tax.sp %>%
  #select(bb.sp, pollen, elev.r2, elev.p) %>%
  select(bb.sp, elev.r2, elev.p) %>%
  distinct()

beta.morph.sp.adonis.bin <- beta.morph.sp.bin %>%
  #select(bb.sp, pollen, elev.r2, elev.p) %>%
  select(bb.sp, elev.r2, elev.p) %>%
  distinct()

beta.tax.guild.adonis.bin <- beta.tax.guild.bin %>%
  #select(pbl.fac, pollen, elev.r2, elev.p) %>%
  select(pbl.fac, elev.r2, elev.p) %>%
  distinct()

beta.morph.guild.adonis.bin <- beta.morph.guild.bin %>%
  #select(pbl.fac, pollen, elev.r2, elev.p) %>%
  select(pbl.fac, elev.r2, elev.p) %>%
  distinct()

## Not binary
beta.tax.sp.adonis <- beta.tax.sp %>%
  #select(bb.sp, pollen, elev.r2, elev.p) %>%
  select(bb.sp, elev.r2, elev.p) %>%
  distinct()

beta.morph.sp.adonis <- beta.morph.sp %>%
  #select(bb.sp, pollen, elev.r2, elev.p) %>%
  select(bb.sp, elev.r2, elev.p) %>%
  distinct()

beta.tax.guild.adonis <- beta.tax.guild %>%
  #select(pbl.fac, pollen, elev.r2, elev.p) %>%
  select(pbl.fac, elev.r2, elev.p) %>%
  distinct()

beta.morph.guild.adonis <- beta.morph.guild %>%
  #select(pbl.fac, pollen, elev.r2, elev.p) %>%
  select(pbl.fac, elev.r2, elev.p) %>%
  distinct()


# Plot
## Binary
beta.sp.plot.bin <- ggplot(beta.sp.bin, aes(elev.diff, distance, color = criterion)) +
  geom_point(alpha = 0.05) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 4), se = FALSE) +
  facet_wrap(~bb.sp) + 
  ggtitle("Species")

beta.guild.plot.bin <- ggplot(beta.guild.bin, aes(elev.diff, distance, color = criterion)) +
  geom_point(alpha = 0.125) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 4), se = FALSE) +
  facet_wrap(~pbl.fac) + 
  ggtitle("Tongue guild")

(beta.sp.plot.bin | beta.guild.plot.bin) + plot_layout(guides = 'collect')

## Not binary
beta.sp.plot <- ggplot(beta.sp, aes(elev.diff, distance, color = criterion)) +
  geom_point(alpha = 0.05) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 4), se = FALSE) +
  facet_wrap(~bb.sp) + 
  ggtitle("Species")

beta.guild.plot <- ggplot(beta.guild, aes(elev.diff, distance, color = criterion)) +
  geom_point(alpha = 0.125) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 4), se = FALSE) +
  facet_wrap(~pbl.fac) + 
  ggtitle("Tongue guild")

(beta.sp.plot | beta.guild.plot) + plot_layout(guides = 'collect')
```

## 1.6 Does the influence of tongue length on niche partitioning vary with elevation or time?
```{r, echo = FALSE}
# By plant.sp
ggplot(niche_x_elevperiod.tax, aes(elev.class, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)

ggplot(niche_x_elevperiod.tax, aes(period, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)

# By ktype
ggplot(niche_x_elevperiod.morph, aes(elev.class, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)

ggplot(niche_x_elevperiod.morph, aes(period, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)
```

# 2. Testing the stress-gradient hypothesis and the Ranta and Vepsäläinen heterogeneity hypothesis

**Stress-gradient hypothesis:** Is there any evidence that niche partitioning amongst generalist core bumble bee species is governed by an inverse relationship between elevation and competition, broadly consistent with the stress-gradient hypothesis (Bertness and Callaway 1994). This mechanism has been inferred from trait patterns in the whole bee community of the Berchtesgadener Alps (Hoiss et al. 2012) and from interaction specialization patterns in the plant-pollinator community of Mt. Kilimanjaro (Classen et al. 2020). It predicts that niche overlap will increase with elevation, reflecting competitive pressures at low elevations and reduced competition but increased need for opportunism at high elevations.

**Ranta/Vepsäläinen heterogeneity hypothesis :** Ranta and Vepsäläinen (1981) proposed that bumble bees communities are governed by a spatiotemporally heterogeneous mosaic of competitive conditions, such that competitive inequalities between species are sufficiently variable to allow more species to coexist than predicted by trait-based competition models.

## 2.1: Testing the stress-gradient hypothesis
### 2.1.1 Face-value analysis  

*Results:*  
In the taxonomic model (28% variance explained), niche overlap exhibited a unimodal relationship with elevation in 2010 and 2012 (both significant at p < 0.01), with peak overlap at ~1600 m and ~1250 m, respectively. In 2011, peak niche overlap occurred at the lowest elevations, but after an initial descent, it exhibit a unimodal relationship rather like that of 2010; **this relationship was not significant**, though (p = 0.23). Niche overlap of pollen visits was significantly (p = 0.01) lower than that of nectar visits. There was no significant effect of year.

In the morphological model (31% variance explained), niche overlap exhibited a significant relationship with elevation in all three years. In each year, the relationship was approximately quadratic, peaking at low elevation and descending with increasing elevation. In 2010 and 2012, the curve drops off steepy above 1500 m. In 2011, the curve is nearly linear.  Niche overlap of pollen visits was significantly (p = 0.01) lower than that of nectar visits, and there was no significant effect of year.

These results, of course, do not support H1. But there is a caveat. These models try to explain face-value niche overlap, but they do not try to distinguish observed niche overlap from the predictions of a null model. It is possible that the patterns we see would be predicted simply by the abundance relationships in our community. Niche overlap is, in fact, strongly predicted by bumble bee abundance, which is itself strongly correlated with bumble bee richness. One response is, well, so what? These are the observed patterns of niche overlap, and we may not care to disentangle the effects of abundance from those of behavioral changes. 

```{r message=FALSE, warning=FALSE, echo = FALSE}
# Pairwise (bb.sp:bb.sp) niche overlap by site, pooled across years

niche_overlap.tax <- niche_overlapper2(net, criterion = plant.sp.abb)
niche_overlap.morph <- niche_overlapper2(net, criterion = k.type.s)

# All spp pairs
sg1 <- ggplot(niche_overlap.tax, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sg2 <- ggplot(niche_overlap.morph, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

(sg1 + ggtitle("Taxonomic") | sg2 + ggtitle("Morphological")) + plot_layout(guides = 'collect')


## Within LT spp
sg3 <- ggplot(filter(niche_overlap.tax, pbl.fac1 == "long" & pbl.fac2 == "long"), 
       aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sg4 <- ggplot(filter(niche_overlap.morph, pbl.fac1 == "long" & pbl.fac2 == "long"), 
       aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

(sg3 + ggtitle("Taxonomic") | sg4 + ggtitle("Morphological")) + plot_layout(guides = 'collect')


## Within ST spp
sg5 <- ggplot(filter(niche_overlap.tax, pbl.fac1 == "short" & pbl.fac2 == "short"), 
       aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sg6 <- ggplot(filter(niche_overlap.morph, pbl.fac1 == "short" & pbl.fac2 == "short"), 
       aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10))

(sg5 + ggtitle("Taxonomic") | sg6 + ggtitle("Morphological")) + plot_layout(guides = 'collect')

## Between ST and LT
sg7 <- ggplot(filter(niche_overlap.tax, pbl.fac.diff == "different"), 
       aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sg8 <- ggplot(filter(niche_overlap.morph, pbl.fac.diff == "different"), 
       aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 8)) 

(sg7 + ggtitle("Taxonomic") | sg8 + ggtitle("Morphological")) + plot_layout(guides = 'collect')


# GAMs
glob_GAM.tax <- gam(niche.overlap ~ 
                      pollen +
                      s(elev.mean, by = pollen, k = 10, m = 2),
                    method = "REML",
                    family = "gaussian",
                    data = niche_overlap.tax) %>% getViz()

check.gamViz(glob_GAM.tax)
summary(glob_GAM.tax)
print(plot(glob_GAM.tax, allTerms = TRUE), pages = 1)

glob_GAM.morph <- gam(niche.overlap ~ 
                      pollen +
                      s(elev.mean, by = pollen, k = 10, m = 2),
                    method = "REML",
                    family = "gaussian",
                    data = niche_overlap.morph) %>% getViz()

check.gamViz(glob_GAM.morph)
summary(glob_GAM.morph)
print(plot(glob_GAM.morph, allTerms = TRUE), pages = 1)

# Within LT class
LT_GAM.tax <- gam(niche.overlap ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(niche_overlap.tax, pbl.fac1 == "long" & pbl.fac2 == "long")) %>% getViz()

check.gamViz(LT_GAM.tax)
summary(LT_GAM.tax)
print(plot(LT_GAM.tax, allTerms = TRUE), pages = 1)

LT_GAM.morph <- gam(niche.overlap ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(niche_overlap.morph, pbl.fac1 == "long" & pbl.fac2 == "long")) %>% getViz()

check.gamViz(LT_GAM.morph)
summary(LT_GAM.morph)
print(plot(LT_GAM.morph, allTerms = TRUE), pages = 1)

# Within ST class
ST_GAM.tax <- gam(niche.overlap ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(niche_overlap.tax, pbl.fac1 == "short" & pbl.fac2 == "short")) %>% getViz()

check.gamViz(ST_GAM.tax)
summary(ST_GAM.tax)
print(plot(ST_GAM.tax, allTerms = TRUE), pages = 1)

ST_GAM.morph <- gam(niche.overlap ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(niche_overlap.morph, pbl.fac1 == "short" & pbl.fac2 == "short")) %>% getViz()

check.gamViz(ST_GAM.morph)
summary(ST_GAM.morph)
print(plot(ST_GAM.morph, allTerms = TRUE), pages = 1)


# Between ST and LT
STxLT_GAM.tax <- gam(niche.overlap ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(niche_overlap.tax, pbl.fac.diff == "different")) %>% getViz()

check.gamViz(STxLT_GAM.tax)
summary(STxLT_GAM.tax)
print(plot(STxLT_GAM.tax, allTerms = TRUE), pages = 1)

STxLT_GAM.morph <- gam(niche.overlap ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(niche_overlap.morph, pbl.fac.diff == "different")) %>% getViz()

check.gamViz(STxLT_GAM.morph)
summary(STxLT_GAM.morph)
print(plot(STxLT_GAM.morph, allTerms = TRUE), pages = 1)
```

We find no support for H1 at the community-mean level. But perhaps this conceals a diversity of responses to elevation in **individual species pairs**. Let's talk about that.

*Results*
These models are hard to fit nicely due to the sparcity of data and high noise at the level of individual species pairs, but what we see here does not appear to add much to what we learned from the community mean model. Individual species pairs tend to exhibit either unimodal or linear decreasing responses, a few of which are statistically significant, most of which are not. 

```{r, echo = FALSE}
## Taxonomic niche partitioning

# Whole community (pairwise)
ggplot(niche_overlap.tax, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_wrap(~sp.pair) +
  ylim(c(0,1))

ggplot(niche_overlap.tax2, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_wrap(~sp.pair) +
  ylim(c(0,1))

# GAM
niche_pairwise_tax_GAM <- gam(niche.overlap ~ 
                               s(year, bs = "re") +
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.tax) %>% getViz()

check.gamViz(niche_pairwise_tax_GAM)
summary(niche_pairwise_tax_GAM)
print(plot(niche_pairwise_tax_GAM, allTerms = TRUE), pages = 1)

niche_pairwise_tax_GAM2 <- gam(niche.overlap ~ 
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.tax2) %>% getViz()

check.gamViz(niche_pairwise_tax_GAM2)
summary(niche_pairwise_tax_GAM2)
print(plot(niche_pairwise_tax_GAM2, allTerms = TRUE), pages = 1)

## Morphological niche partitioning

# Whole community (pairwise)
ggplot(niche_overlap.morph, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_grid(year~sp.pair) +
  ylim(c(0,1))

ggplot(niche_overlap.morph2, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_wrap(~sp.pair) +
  ylim(c(0,1))

# GAM
niche_pairwise_morph_GAM <- gam(niche.overlap ~ 
                               s(year, bs = "re") +
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.morph) %>% getViz()

check.gamViz(niche_pairwise_morph_GAM)
summary(niche_pairwise_morph_GAM)
print(plot(niche_pairwise_morph_GAM, allTerms = TRUE), pages = 1)

niche_pairwise_morph_GAM2 <- gam(niche.overlap ~ 
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.morph2) %>% getViz()

check.gamViz(niche_pairwise_morph_GAM2)
summary(niche_pairwise_morph_GAM2)
print(plot(niche_pairwise_morph_GAM2, allTerms = TRUE), pages = 1)
```

### 2.1.2 Null-model residual analysis  

Arguably the most rigorous way to tease out the effect of elevation while controlling for community composition (abundance and richness patterns) is to compare the observed niche overlap at each site to that predicted by a random null model, then see how the residuals vary with elevation.

I'll be the first to admit that I'm new to null models, so I want to be extremely clear about the logic of how I'm setting this up. Step-by-step:  
1. Generate community matrices by site and pollen/nectar
2. Permute each matrix *n* times by randomly redistributing the visits of each bumble bee species while holding the total visits for each bumble bee species constant. This is, therefore, a random selection model constrained to the set of flora visited for a given site-pollen/nectar matrix. Importantly, I am opting not to hold the floral marginal totals constant, i.e. the total number of visits that each plant receives will vary with each permutation. My gut feeling is that this is the right place to start, but this is a decision that requires scrutiny.
3. Calculate niche overlap for each permuted matrix and store as tidy arrays; this mirrors the workflow for calculating empirical niche overlap, the only difference being that I had to deal with some tricky nested lists; I'm pretty sure I did this correctly.
4. Take the mean niche overlap for each permuted community.
5. Join null model mean niche overlap table to empirical niche overlap table, joining by site and pollen/nectar. Thus, for each site-pollen/nectar combo in the empirical niche overlap table, we have *n* iterations of random niche overlap.
6. Calculate the difference between empirical niche overlap and null niche overlap for each iteration; we'll call this "residual niche overlap".
7. Calculate mean residual niche overlap for each site-pollen/nectar combo. This can then be regressed against elevation to see how the deviation from null expectations varies along the elevation gradient, with the interpretation that this represents the "pure" influence of elevation on niche overlap whle controlling for community differences. We could also use the raw differences without collapsing them to a mean. But that's not what I did this first time through. 

There are surely a lot of other ways a null model could be constructed and analyzed, but this seems to me a good place to start.

*Results*
 

```{r message=FALSE, warning=TRUE, echo = FALSE}
### Define function that will be used inside map() calls
permat_set <- function(x){
  x %>%
    column_to_rownames("bb.sp") %>%
    vegan::permatfull(fixedmar = "rows", shuffle = "ind", times = 50)
}

ret <- function(x){
  return(x$perm)
}

tidy_dist <- function(x) {
  x %>%
    tidy() %>%
    mutate(index = seq_along())
}

### Generate random niche overlap data
#### Need to look into th the missing value warnings I'm getting from the vegdist() call; I think it's because some plants end up with zero visits in some permutations.
random_niche.tax <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
  select(site, pollen, bb.sp, plant.sp) %>% 
  group_by(site, pollen, bb.sp, plant.sp) %>%
  summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair
  group_by(site, pollen) %>%
  nest() %>% # nest data into list-column grouped by pollen, site, date
  mutate(data = map(data, 
                    function(x) pivot_wider(x, 
                                            names_from = plant.sp, 
                                            values_from = freq) %>% replace(is.na(.), 0)), # turn table into community matrix
         data = map(data, permat_set), # permute community matrices
         data = map(data, ret)) %>% # extract permutations from permat objects
  unnest(data) %>% # unnest
  mutate(data = map(data, function(x) vegdist(x, method = "horn")), # convert each permutation into distance matrix
         data = map(data, tidy)) %>% # convert distance matrices to tidy arrays
  group_by(site, pollen) %>%
  mutate(iter = row_number()) %>% # add index to denote iterations
  unnest(cols = data) %>% # unnest again
  rename(bb.sp1 = item1, bb.sp2 = item2) %>%
  unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
  mutate(sp.pair = factor(sp.pair), # ...and make it a factor so that mgcv can handle it
         niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
  select(site, pollen, sp.pair, iter, niche.overlap.sim = niche.overlap)

random_niche.morph <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
  select(site, pollen, bb.sp, k.type.s) %>% 
  group_by(site, pollen, bb.sp, k.type.s) %>%
  summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair
  group_by(site, pollen) %>%
  nest() %>% # nest data into list-column grouped by pollen, site, date
  mutate(data = map(data, 
                    function(x) pivot_wider(x, 
                                            names_from = k.type.s, 
                                            values_from = freq) %>% replace(is.na(.), 0)), # turn table into community matrix
         data = map(data, permat_set), # permute community matrices
         data = map(data, ret)) %>% # extract permutations from permat objects
  unnest(data) %>% # unnest
  mutate(data = map(data, function(x) vegdist(x, method = "horn")), # convert each permutation into distance matrix
         data = map(data, tidy)) %>% # convert distance matrices to tidy arrays
  group_by(site, pollen) %>%
  mutate(iter = row_number()) %>% # add index to denote iterations
  unnest(cols = data) %>% # unnest again
  rename(bb.sp1 = item1, bb.sp2 = item2) %>%
  unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
  mutate(sp.pair = factor(sp.pair), # ...and make it a factor so that mgcv can handle it
         niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
  select(site, pollen, sp.pair, iter, niche.overlap.sim = niche.overlap)

## Join null model to empirical niche overlap
# Taxonomic niche overlap
comparison.tax <- niche_overlap.tax %>%
  left_join(random_niche.tax, by = c("site", "pollen", "sp.pair")) %>%
  mutate(niche.overlap.resid = niche.overlap - niche.overlap.sim) %>%
  group_by(site, elev.mean, sp.pair, pollen, pbl.fac1, pbl.fac2, pbl.fac.diff) %>%
  summarize(niche.overlap.resid = mean(niche.overlap.resid)) %>%
  mutate(pollen = factor(pollen))

# Morphological niche overlap
comparison.morph <- niche_overlap.morph %>%
  left_join(random_niche.morph, by = c("site", "pollen", "sp.pair")) %>%
  mutate(niche.overlap.resid = niche.overlap - niche.overlap.sim) %>%
  group_by(site, elev.mean, sp.pair, pollen, pbl.fac1, pbl.fac2, pbl.fac.diff) %>%
  summarize(niche.overlap.resid = mean(niche.overlap.resid) )%>%
  mutate(pollen = factor(pollen))

# Plot
# All spp pairs
sgn1 <- ggplot(comparison.tax, aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sgn2 <- ggplot(comparison.morph, aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

(sgn1 + ggtitle("Taxonomic") | sgn2 + ggtitle("Morphological")) + plot_layout(guides = 'collect')


## Within LT spp
sgn3 <- ggplot(filter(comparison.tax, pbl.fac1 == "long" & pbl.fac2 == "long"), 
       aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sgn4 <- ggplot(filter(comparison.morph, pbl.fac1 == "long" & pbl.fac2 == "long"), 
       aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

(sgn3 + ggtitle("Taxonomic") | sgn4 + ggtitle("Morphological")) + plot_layout(guides = 'collect')

## Within ST spp
sgn5 <- ggplot(filter(comparison.tax, pbl.fac1 == "short" & pbl.fac2 == "short"), 
       aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sgn6 <- ggplot(filter(comparison.morph, pbl.fac1 == "short" & pbl.fac2 == "short"), 
       aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10))

(sgn5 + ggtitle("Taxonomic") | sgn6 + ggtitle("Morphological")) + plot_layout(guides = 'collect')

## Between ST and LT
sgn7 <- ggplot(filter(comparison.tax, pbl.fac.diff == "different"), 
       aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

sgn8 <- ggplot(filter(comparison.morph, pbl.fac.diff == "different"), 
       aes(elev.mean, niche.overlap.resid, color = pollen)) +
  geom_point(alpha = 0.5) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 8)) 

(sgn7 + ggtitle("Taxonomic") | sgn8 + ggtitle("Morphological")) + plot_layout(guides = 'collect')

# GAMs
glob_nullmodel_GAM.tax <- gam(niche.overlap.resid ~ 
                      pollen +
                      s(elev.mean, by = pollen, k = 10, m = 2),
                    method = "REML",
                    family = "gaussian",
                    data = comparison.tax) %>% getViz()

check.gamViz(glob_nullmodel_GAM.tax)
summary(glob_nullmodel_GAM.tax)
print(plot(glob_nullmodel_GAM.tax, allTerms = TRUE), pages = 1)

glob_nullmodel_GAM.morph <- gam(niche.overlap.resid ~ 
                      pollen +
                      s(elev.mean, by = pollen, k = 10, m = 2),
                    method = "REML",
                    family = "gaussian",
                    data = comparison.morph) %>% getViz()

check.gamViz(glob_nullmodel_GAM.morph)
summary(glob_nullmodel_GAM.morph)
print(plot(glob_nullmodel_GAM.morph, allTerms = TRUE), pages = 1)

# Within LT class
LT_nullmodel_GAM.tax <- gam(niche.overlap.resid ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(comparison.tax, pbl.fac1 == "long" & pbl.fac2 == "long")) %>% getViz()

check.gamViz(LT_nullmodel_GAM.tax)
summary(LT_nullmodel_GAM.tax)
print(plot(LT_nullmodel_GAM.tax, allTerms = TRUE), pages = 1)

LT_nullmodel_GAM.morph <- gam(niche.overlap.resid ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(comparison.morph, pbl.fac1 == "long" & pbl.fac2 == "long")) %>% getViz()

check.gamViz(LT_nullmodel_GAM.morph)
summary(LT_nullmodel_GAM.morph)
print(plot(LT_nullmodel_GAM.morph, allTerms = TRUE), pages = 1)

# Within ST class
ST_nullmodel_GAM.tax <- gam(niche.overlap.resid ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(comparison.tax, pbl.fac1 == "short" & pbl.fac2 == "short")) %>% getViz()

check.gamViz(ST_nullmodel_GAM.tax)
summary(ST_nullmodel_GAM.tax)
print(plot(ST_nullmodel_GAM.tax, allTerms = TRUE), pages = 1)

ST_nullmodel_GAM.morph <- gam(niche.overlap.resid ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(comparison.morph, pbl.fac1 == "short" & pbl.fac2 == "short")) %>% getViz()

check.gamViz(ST_nullmodel_GAM.morph)
summary(ST_nullmodel_GAM.morph)
print(plot(ST_nullmodel_GAM.morph, allTerms = TRUE), pages = 1)


# Between ST and LT
STxLT_nullmodel_GAM.tax <- gam(niche.overlap.resid ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(comparison.tax, pbl.fac.diff == "different")) %>% getViz()

check.gamViz(STxLT_nullmodel_GAM.tax)
summary(STxLT_nullmodel_GAM.tax)
print(plot(STxLT_nullmodel_GAM.tax, allTerms = TRUE), pages = 1)

STxLT_nullmodel_GAM.morph <- gam(niche.overlap.resid ~ 
                    pollen +
                    s(elev.mean, by = pollen, k = 10, m = 2),
                  method = "REML",
                  family = "gaussian",
                  data = filter(comparison.morph, pbl.fac.diff == "different")) %>% getViz()

check.gamViz(STxLT_nullmodel_GAM.morph)
summary(STxLT_nullmodel_GAM.morph)
print(plot(STxLT_nullmodel_GAM.morph, allTerms = TRUE), pages = 1)
```

### 2.1.3. Parsing niche contraction and niche separation

Contrary to the predictions of H1, niche overlap decreases sharply at high elevation. This is true for both taxonomic and morphological niche overlap, and it holds in both the face-value and null-residual approaches. This decrease in niche overlap might be explained by two modest, proximate hypotheses:  

1.  **H1:** The decrease of niche overlap at high elevations is due to *niche contraction*, i.e. BB spp. visiting a smaller proportion of available (and "eligible", i.e. visited at least once by a bumble bee) flora. 
  *Prediction:* "resource range" (Poisot et al. 2012) will decrease with elevation (as Dormann notes, resource range is a "backward" metric insofar as a large resource range means a small proportional niche breadth; I will calculate the inverse of resource range so that it makes more sense)
2.  **H2:** The decrease of niche overlap at high elevations is due to *niche separation*, i.e. BB spp. avoiding one another's niches but not contracting their own.
  *Predictions:* C score will increase with elevation
  
*Results:* I haven't run formal stats on this analysis yet, but from the visualization, it looks like the overall story is that niche overlap is driven mainly by niche separation, not so much but niche contraction. My first impression is that this suggests a behavior response to competition.

```{r, echo = FALSE}
resource_range.sp <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>%
  group_by(site, year, pollen, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
  summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
  unite(webID, c(site, year, pollen), sep = "_") %>%
  ungroup() %>%
  dplyr::select(higher = bb.sp, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
  data.frame() %>% # convert to data frame
  frame2webs() %>% # convert to to bipartite web
  map(specieslevel, level = "higher", index = "resource range") %>%
  map(rownames_to_column) %>%
  map(as_tibble) %>%
  bind_rows(.id = "webID") %>% # Collapse list into big data frame
  rename(bb.sp = rowname) %>%
  separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
  left_join(site_data) %>%
  mutate(site = factor(site),
         year = factor(year),
         pollen = factor(pollen)) %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # for some reason, one row has a "1" for bb.sp, and I don't know where this comes from; this gets rid of it, but I would still like to know why
  mutate(resource.range = 1-resource.range) %>%
  left_join(BB_covars.splevel) %>%
  filter(bb.sp.abund > 1)

resource_range.sp.mean <- resource_range.sp %>%
  group_by(site, year, elev.mean, pollen) %>%
  summarize(mean.resource.range = mean(resource.range))
  
ggplot(resource_range.sp, aes(elev.mean, resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_grid(bb.sp ~ year) +
  ylim(c(0,1))

ggplot(resource_range.sp.mean, aes(elev.mean, mean.resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year) +
  ylim(c(0,1))

resource_range.ktype <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>%
  group_by(site, year, pollen, bb.sp, k.type.s) %>% # group by site, date, bee species, plant species
  summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
  unite(webID, c(site, year, pollen), sep = "_") %>%
  ungroup() %>%
  dplyr::select(higher = bb.sp, lower = k.type.s, webID, freq) %>% # rename columns to match bipartite's expectations
  data.frame() %>% # convert to data frame
  frame2webs() %>% # convert to to bipartite web
  map(specieslevel, level = "higher", index = "resource range") %>%
  map(rownames_to_column) %>%
  map(as_tibble) %>%
  bind_rows(.id = "webID") %>% # Collapse list into big data frame
  rename(bb.sp = rowname) %>%
  separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
  left_join(site_data) %>%
  mutate(site = factor(site),
         year = factor(year),
         pollen = factor(pollen)) %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # for some reason, one row has a "1" for bb.sp, and I don't know where this comes from; this gets rid of it, but I would still like to know why
  mutate(resource.range = 1-resource.range) %>%
  left_join(BB_covars.splevel) %>%
  filter(bb.sp.abund > 1)

resource_range.ktype.mean <- resource_range.ktype %>%
  group_by(site, year, elev.mean, pollen) %>%
  summarize(mean.resource.range = mean(resource.range))
  
ggplot(resource_range.ktype, aes(elev.mean, resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_grid(bb.sp ~ year) +
  ylim(c(0,1))

ggplot(resource_range.ktype.mean, aes(elev.mean, mean.resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year) +
  ylim(c(0,1))

cscore.sp <- net %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>%
    group_by(site, year, pollen, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
    summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
    group_by(site, year, pollen) %>%
    unite(webID, c(site, year, pollen), sep = "_") %>%
    ungroup() %>%
    dplyr::select(higher = bb.sp, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
    data.frame() %>% # convert to data frame
    frame2webs() %>% # convert to to bipartite web
    map(grouplevel, level = "higher", weighted = TRUE, index = c("C score")) %>% 
    data.frame() %>%
    t() %>%
    data.frame() %>%
    rownames_to_column() %>%
    dplyr::select(webID = rowname, everything()) %>%
    as_tibble() %>%
    separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
    left_join(site_data) %>%
    mutate(site = factor(site),
           year = factor(year),
           pollen = factor(pollen))

ggplot(cscore.sp, aes(elev.mean, C.score.HL, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year)

cscore.ktype <- net %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>%
    group_by(site, year, pollen, bb.sp, k.type.s) %>% # group by site, date, bee species, plant species
    summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
    group_by(site, year, pollen) %>%
    unite(webID, c(site, year, pollen), sep = "_") %>%
    ungroup() %>%
    dplyr::select(higher = bb.sp, lower = k.type.s, webID, freq) %>% # rename columns to match bipartite's expectations
    data.frame() %>% # convert to data frame
    frame2webs() %>% # convert to to bipartite web
    map(grouplevel, level = "higher", weighted = TRUE, index = c("C score")) %>% 
    data.frame() %>%
    t() %>%
    data.frame() %>%
    rownames_to_column() %>%
    dplyr::select(webID = rowname, everything()) %>%
    as_tibble() %>%
    separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
    left_join(site_data) %>%
    mutate(site = factor(site),
           year = factor(year),
           pollen = factor(pollen))

ggplot(cscore.ktype, aes(elev.mean, C.score.HL, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year)
```

