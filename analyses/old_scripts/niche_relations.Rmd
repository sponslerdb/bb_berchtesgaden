---
title: "site-wise niche-overlap by elevation"
output: html_document
---

Load packages 
```{r message=FALSE, warning=FALSE, include=FALSE}
library(bipartite)
library(mgcv)
library(mgcViz)
library(ggbipart)
library(GGally)
library(vegan)
library(ggvegan)
library(ggrepel)
library(gridExtra)
library(tidyverse)
library(lubridate)
library(patchwork)
library(tidymodels)
```

Load data
```{r message=FALSE, warning=FALSE, include=FALSE}
# Site data
site_data <- read_csv("../processed_data/site_data.csv") %>%
  dplyr::select(-c(slope.calc, slope.est, elev.min, 
                   elev.max, temp.mean)) %>% # drop these variables
  mutate(elev.class = factor(elev.class, 
                             levels = c("unten", "mitte", "oben")),
         elev.class2 = factor(elev.class2, 
                             levels = c("low", "mid", "high"))) # turn elav.class into an ordered factor

# BB traits
bb_traits <- read_csv("../processed_data/bb_traits.csv") %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>%
  mutate(pbl.fac = factor(if_else(bb.sp %in% c("hort", "pasc", "wurf"), "long", "short")))

# FL traits
fl_tax <- read_csv("../processed_data/floral_tax.csv")
  
fl_ktype <- read_csv("../processed_data/floral_k_type.csv") 

fl_morph <- read_csv("../processed_data/flower_morphology_GitaBenadi.csv") %>%
  dplyr::select(SampleID, plant.family = Family, plant.sp = Species, 
         Unit, Flowers_per_unit, diam = Diameter, LN) %>%
  group_by(plant.sp) %>%
  summarize(diam = mean(diam),
            LN = mean(LN))

fl_ktype_key <- read_delim("../processed_data/kugler_key.tsv", delim = "\t", col_names = FALSE) %>%
  dplyr::select(k.type = 1, description = 2)

fl_traits <- fl_tax %>%
  full_join(fl_ktype) %>%
  full_join(fl_morph) %>%
  dplyr::select(plant.sp, plant.genus, plant.family, 
         k.type, k.type.s, k.type.ss, diam, LN)

# Network
net <- read_csv("../processed_data/network.csv") %>%
  unite(site.year, site, year, sep = "_", remove = FALSE) %>% # create site.year field that can later be split back up
  mutate(year = factor(year)) %>% # convert year to factor
  left_join(site_data, by = "site") %>%
  #left_join(gdd, by = c("site", "date")) %>%
  ungroup() %>%
  arrange(site, date) %>%
  left_join(fl_traits) %>%
  
  # Fill in missing k.type scores
  mutate(k.type.s = if_else(plant.genus == "Phyteuma", 7.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Phyteuma", 7, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Aconitum", 5.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Aconitum", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Cardamine", 1.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Cardamine", 1, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Euphrasia", 5.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Euphrasia", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Lamium", 5.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Lamium", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Mentha", 2.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Mentha", 2, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Rumex", 0.0, k.type.s),
         k.type.ss = if_else(plant.genus == "Rumex", 0, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Salix", 9.0, k.type.s),
         k.type.ss = if_else(plant.genus == "Salix", 9, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Silene", 4.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Silene", 4, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Stachys", 5.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Stachys", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Taraxacum", 7.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Taraxacum", 7, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.sp == "Gentiana aspera", 2.1, k.type.s),
         k.type.ss = if_else(plant.sp == "Gentiana aspera", 2, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.sp == "Gentiana ciliata", 4.1, k.type.s),
         k.type.ss = if_else(plant.sp == "Gentiana ciliata", 4, k.type.ss))

# Floral survey
survey <- read_csv("../processed_data/floral_survey.csv") %>%
  semi_join(net, by = "plant.sp") %>% # Consider only plants visited (anytime anywhere, not specifically for a given site*date)
  dplyr::select(site, date, plant.sp, flower.cover) %>%
  left_join(fl_traits) %>%
  
  # Fill in missing k.type scores
  mutate(k.type.s = if_else(plant.genus == "Phyteuma", 7.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Phyteuma", 7, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Aconitum", 5.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Aconitum", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Cardamine", 1.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Cardamine", 1, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Euphrasia", 5.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Euphrasia", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Lamium", 5.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Lamium", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Mentha", 2.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Mentha", 2, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Rumex", 0.0, k.type.s),
         k.type.ss = if_else(plant.genus == "Rumex", 0, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Salix", 9.0, k.type.s),
         k.type.ss = if_else(plant.genus == "Salix", 9, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Silene", 4.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Silene", 4, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Stachys", 5.1, k.type.s),
         k.type.ss = if_else(plant.genus == "Stachys", 5, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.genus == "Taraxacum", 7.2, k.type.s),
         k.type.ss = if_else(plant.genus == "Taraxacum", 7, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.sp == "Gentiana aspera", 2.1, k.type.s),
         k.type.ss = if_else(plant.sp == "Gentiana aspera", 2, k.type.ss)) %>%
  mutate(k.type.s = if_else(plant.sp == "Gentiana ciliata", 4.1, k.type.s),
         k.type.ss = if_else(plant.sp == "Gentiana ciliata", 4, k.type.ss))

### Auxiliary data, i.e. all the covariates we need to control for
BB_covars <- net %>%
  group_by(site, year) %>%
  summarize(bb.rich = length(unique(bb.sp)),
            sqrt.bb.abund = sqrt(n()))

FL_covars <- survey %>%
  mutate(year = factor(year(date))) %>%
  filter(flower.cover > 0) %>%
  group_by(site, year) %>%
  summarize(fl.rich = length(unique(plant.sp)),
            log.fl.abund = log(sum(flower.cover))) 

### Species-level by site (we will also separate pollen and nectar foragers)
BB_covars.splevel <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>%
  group_by(bb.sp, site, year, pollen) %>%
  summarize(bb.sp.abund = n())

### Species names and such for plotting
species_names <- cbind(c("bss", "pasc", "prat", 
                         "soro", "wurf", "hort", 
                         "pyre", "mend", "mont", 
                         "gers", "hypn","jone", 
                         "lapi", "muci", "psit", 
                         "humi"),
                       c("B. sensu-strictu", "B. pascuorum", "B. pratorum", 
                         "B. soroensis", "B. wurflenii", "B. hortorum",
                         "B. pyrenaeus", "B. mendax", "B. monticola",
                         "B. gerstaeckeri", "B. hypnorum", "B. jonellus", 
                         "B. lapidarius", "B. mucidus", "B. psithyrus", 
                         "B. humilis"),
                       c("B. ss.", "B. pasc.", "B. prat.", 
                         "B. soro.", "B. wurf.", "B. hort.",
                         "B. pyre.", "B. mend.", "B. mont.",
                         "B. gers.", "B. hypn.", "B. jone.", 
                         "B. lapi.", "B. muci.", "B. psit.", 
                         "B. humi"),
                       c("major", "major", "major", 
                         "major", "major", "common", 
                         "high elev.", "high elev.", "high elev.",
                         "minor", "minor", "common", 
                         "minor", "minor", "common", 
                         "minor")
                       ) %>%
  as.data.frame() %>%
  as_tibble() %>%
  dplyr::select(bb.sp = 1, species.name = 2, species.abb = 3, abund.class = 4) %>%
  mutate(focal = if_else(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf"), TRUE, FALSE))
```

We will focus on six species that are abundant and widespread:  
  1. *B. sensu-strictu*
  2. *B. pascuorum*
  3. *B. pratorum*
  4. *B. hortorum*
  5. *B. soroensis*
  6. *B. wurflenii*

```{r fig.cap="**Figure 1: Focal species**", message=FALSE, warning=FALSE, echo=FALSE}
bb_range.year <- net %>%
  left_join(site_data) %>%
  group_by(site, date, elev.mean, bb.sp, year) %>%
  summarize(abund = n()) %>%
  group_by(site, elev.mean, bb.sp, year) %>%
  summarize(abund = mean(abund)) %>%
  group_by(bb.sp) %>%
  mutate(elev.floor = min(elev.mean),
         elev.ceiling = max(elev.mean),
         elev.range = elev.ceiling - elev.floor,
         elev.med = elev.floor + ((elev.ceiling - elev.floor)/2)) %>%
  left_join(species_names) 

ggplot(bb_range.year, aes(reorder(bb.sp, elev.med), elev.mean, color = focal)) +
  geom_line(size = 2, alpha = 0.25) +
  geom_point(aes(size = abund), alpha = 0.5) +
  facet_wrap(~year, ncol = 1) +
  theme_light(12) +
  scale_size_continuous(name = "Abundance") +
  scale_color_discrete(name = "Focal species") +
  xlab("BB species") +
  ylab("Elevation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Functions
```{r}
# Niche overlap by sp.pair * site * year
niche_overlapper <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
    group_by(bb.sp, pollen, !!criterion, site, year) %>% # group by site-year and BB-FL pair
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site-year
    group_by(bb.sp, pollen, site, year) %>% # group by site-year and BB species
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair
    dplyr::select(-freq) %>% # drop freq variable
    pivot_wider(names_from = !!criterion, values_from = prop) %>% # spread into the kind of array vegan likes
    replace(is.na(.), 0) %>% # replace NAs with zeros
    group_by(pollen, site, year) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    dplyr::select(pollen, site, year, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>% # unnest back into a single data frame
    left_join(site_data) %>% # add site data
    dplyr::select(site, year, pollen, bb.sp1 = item1, bb.sp2 = item2, distance, elev.mean) %>% # dplyr::select and rename vars
    left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>% # add traits for bb.sp1
    rename(subgenus1 = subgenus, pbl.w1 = pbl.w, pbl.w.class1 = pbl.w.class) %>%
    left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>% # add traits for bb.sp2
    rename(subgenus2 = subgenus, pbl.w2 = pbl.w, pbl.w.class2 = pbl.w.class) %>%
    dplyr::select(site, year, pollen, bb.sp1, bb.sp2, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, elev.mean) %>%
    left_join(BB_covars.splevel, by = c("bb.sp1" = "bb.sp", "site", "year", "pollen")) %>%
    rename(bb.sp1.abund = bb.sp.abund) %>%
    dplyr::select(site, year, pollen, bb.sp1, bb.sp2, bb.sp1.abund, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, elev.mean) %>%
    left_join(BB_covars.splevel, by = c("bb.sp2" = "bb.sp", "site", "year", "pollen")) %>%
    rename(bb.sp2.abund = bb.sp.abund) %>%
    dplyr::select(site, year, pollen, bb.sp1, bb.sp2, bb.sp1.abund, bb.sp2.abund, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, elev.mean) %>%
    mutate(pbl.diff = abs(pbl.w1 - pbl.w2), # tongue length differences
           abund.diff = abs(bb.sp1.abund - bb.sp2.abund),
           subgenus.diff = if_else(subgenus1 == subgenus2, "same", "different"), # binary: same or different subgenus
           
           # Logical columns indicating whether a given species belongs to a given species pair
           # This is handy for extracting data for individual species across all their counterparts
           bss = if_else(bb.sp1 == "bss" | bb.sp2 == "bss", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE)) %>%
    
    unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
    mutate(sp.pair = factor(sp.pair),
           pollen = factor(pollen)) %>% # ...and make it a factor so that mgcv can handle it
    left_join(BB_covars) %>% # add BB covars
    left_join(FL_covars) %>% # add floral covars
    mutate(niche.overlap = 1-distance) # express niche overlap so that 1 = perfect overlap and 0 = no overlap
}

niche_overlapper2 <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
    group_by(bb.sp, pollen, !!criterion, site) %>% # group by site-year and BB-FL pair
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site-year
    group_by(bb.sp, pollen, site) %>% # group by site-year and BB species
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair
    dplyr::select(-freq) %>% # drop freq variable
    pivot_wider(names_from = !!criterion, values_from = prop) %>% # spread into the kind of array vegan likes
    replace(is.na(.), 0) %>% # replace NAs with zeros
    group_by(pollen, site) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    dplyr::select(pollen, site, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>% # unnest back into a single data frame
    left_join(site_data) %>% # add site data
    dplyr::select(site, pollen, bb.sp1 = item1, bb.sp2 = item2, distance, elev.mean) %>% # dplyr::select and rename vars
    left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>% # add traits for bb.sp1
    rename(subgenus1 = subgenus, pbl.w1 = pbl.w, pbl.w.class1 = pbl.w.class) %>%
    left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>% # add traits for bb.sp2
    rename(subgenus2 = subgenus, pbl.w2 = pbl.w, pbl.w.class2 = pbl.w.class) %>%
    dplyr::select(site, pollen, bb.sp1, bb.sp2, subgenus1, subgenus2, distance, 
           pbl.w1, pbl.w2, pbl.w.class1, pbl.w.class2, elev.mean) %>%
    mutate(pbl.diff = abs(pbl.w1 - pbl.w2), # tongue length differences
           subgenus.diff = if_else(subgenus1 == subgenus2, "same", "different"), # binary: same or different subgenus
           
           # Logical columns indicating whether a given species belongs to a given species pair
           # This is handy for extracting data for individual species across all their counterparts
           bss = if_else(bb.sp1 == "bss" | bb.sp2 == "bss", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE)) %>%
    
    unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
    mutate(sp.pair = factor(sp.pair),
           pollen = factor(pollen)) %>% # ...and make it a factor so that mgcv can handle it
    mutate(niche.overlap = 1-distance) # express niche overlap so that 1 = perfect overlap and 0 = no overlap
}

# Add BB trait data for envfit() call inside map2()
trait_join <- function(x, y = bb_traits) {
  x %>%
    select(bb.sp) %>%
    left_join(y) %>%
    column_to_rownames(var = "bb.sp") %>%
    select(pbl.w)
}

# Fortify envfit() object fitted to BB tongue length data
envfit_fort <- function(x){
  fortify(x) %>%
  select(Score = Type, Label, MDS1, MDS2) %>%
  mutate(Label = case_when(Label == "pbl.w" ~ "T.len"),
         Score = case_when(Score == "Vector" ~ "T.len"))
}


# Fortify PCOA and add the results of an envfit() to BB tongue length
pcoa_fort <- function(x, y){
  fortify(x, axes = 1:2) %>%
  bind_rows(y) %>%
  mutate(Score = case_when(
    Score == "species" ~ "FL.sp",
    Score == "sites" ~ "BB.sp",
    Score == "T.len" ~ "T.len"))
}

# Plot PCOA with repelled text and arrow for tongue length; to avoid overplotting, loadings < min_load are not plotted
pcoa_plot <- function(x, y, min_load = 0.25) {
  ggplot(filter(x, (abs(MDS1) > min_load | abs(MDS2) > min_load) | (Score %in% c("BB.sp", "T.len")))) + # to avoid overplotting, we can filter to include only floral species > loading threshold
    geom_point(aes(MDS1, MDS2, color = Score)) +
    geom_text_repel(aes(MDS1, MDS2, color = Score, label = Label), key_glyph = "rect") +
    geom_segment(data = y, 
               aes(x = 0, y = 0, xend = MDS1, yend = MDS2, colour = Label),
               arrow = arrow(), size = 2, alpha = 0.5, key_glyph = "rect")
}

# Niche analysis function; generates PCOA, envfit, ordination plot, and tongue length R2 coming out of envfit
niche_analysis1.year <- function(x, criterion) {
  
  criterion <- enquo(criterion)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>%
    filter(!is.na(pollen)) %>%
    group_by(year, bb.sp, !!criterion, pollen) %>%
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site
    group_by(year, bb.sp, pollen) %>%
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair per site-date
    dplyr::select(-freq) %>%
    group_by(pollen) %>%
    nest() %>%
    mutate(data2 = map(data, function(x) pivot_wider(x, names_from = !!criterion, values_from = prop)), # spread into the kind of array vegan likes
           data3 = map(data2, function(x) replace(x, is.na(x), 0)),
           data4 = map(data3, function(x) unite(x, id, c("year", "bb.sp"))),
           data5 = map(data4, function(x) column_to_rownames(x, var = "id")),
           pcoa = map(data5,  function(x) capscale(x ~ 1, distance = "horn", scale = TRUE)),
           traits = map(data3, function(x) x %>% 
                          left_join(bb_traits) %>% 
                          unite(id, c(year, bb.sp)) %>% 
                          column_to_rownames(var = "id") %>% 
                          select(pbl.w)),
           envfit = map2(pcoa, traits, function(x, y) envfit(x, y)),
           envfit.fort = map(envfit, envfit_fort),
           pcoa.fort = map2(pcoa, envfit.fort, pcoa_fort),
           pcoa.plot = map2(pcoa.fort, envfit.fort, pcoa_plot), 
           tongue.r2 = map(envfit, function(x) x$vectors$r),
           tongue.p = map(envfit, function(x) x$vectors$pvals),
           tongue.MDS1 = map(envfit, function(x) x$vectors$arrows[[1]]),
           tongue.MDS2 = map(envfit, function(x) x$vectors$arrows[[2]])) %>%
    unnest(cols = c(tongue.r2, tongue.p, tongue.MDS1, tongue.MDS2)) %>%
    select(pollen, pcoa, envfit, envfit.fort, pcoa.fort, pcoa.plot, tongue.r2, tongue.p, tongue.MDS1, tongue.MDS2) 
}

niche_analysis1 <- function(x, criterion) {
  
  criterion <- enquo(criterion)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>%
    filter(!is.na(pollen)) %>%
    group_by(bb.sp, !!criterion, pollen) %>%
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site
    group_by(bb.sp, pollen) %>%
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair per site-date
    dplyr::select(-freq) %>%
    group_by(pollen) %>%
    nest() %>%
    mutate(data2 = map(data, function(x) pivot_wider(x, names_from = !!criterion, values_from = prop)), # spread into the kind of array vegan likes
           data3 = map(data2, function(x) replace(x, is.na(x), 0)),
           data4 = map(data3, function(x) column_to_rownames(x, var = "bb.sp")),
           pcoa = map(data4,  function(x) capscale(x ~ 1, distance = "horn")),
           traits = map(data3, function(x) x %>% 
                          left_join(bb_traits) %>% 
                          column_to_rownames(var = "bb.sp") %>% 
                          select(pbl.w)),
           envfit = map2(pcoa, traits, function(x, y) envfit(x, y)),
           envfit.fort = map(envfit, envfit_fort),
           pcoa.fort = map2(pcoa, envfit.fort, pcoa_fort),
           pcoa.plot = map2(pcoa.fort, envfit.fort, pcoa_plot), 
           tongue.r2 = map(envfit, function(x) x$vectors$r),
           tongue.p = map(envfit, function(x) x$vectors$pvals),
           MDS1.varexp = map(pcoa, function(x) x$CA$eig[[1]]),
           MDS2.varexp = map(pcoa, function(x) x$CA$eig[[2]])) %>%
    unnest(cols = c(tongue.r2, tongue.p, MDS1.varexp, MDS2.varexp)) %>%
    select(pollen, pcoa, envfit, envfit.fort, pcoa.fort, pcoa.plot, tongue.r2, tongue.p, MDS1.varexp, MDS2.varexp) 
}

# This version break it down by elev.class
niche_analysis2.year <- function(x, criterion) {
  
  criterion <- enquo(criterion)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>%
    filter(!is.na(pollen)) %>%
    group_by(year, elev.class, bb.sp, !!criterion, pollen) %>%
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site
    group_by(year, elev.class, bb.sp, pollen) %>%
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair per site-date
    dplyr::select(-freq) %>%
    group_by(pollen, elev.class) %>%
    nest() %>%
    mutate(data2 = map(data, function(x) pivot_wider(x, names_from = !!criterion, values_from = prop)), # spread into the kind of array vegan likes
           data3 = map(data2, function(x) replace(x, is.na(x), 0)),
           data4 = map(data3, function(x) unite(x, id, c("year", "bb.sp"))),
           data5 = map(data4, function(x) column_to_rownames(x, var = "id")),
           pcoa = map(data5,  function(x) capscale(x ~ 1, distance = "horn", scale = TRUE)),
           traits = map(data3, function(x) x %>% 
                          left_join(bb_traits) %>% 
                          unite(id, c(year, bb.sp)) %>% 
                          column_to_rownames(var = "id") %>% 
                          select(pbl.w)),
           envfit = map2(pcoa, traits, function(x, y) envfit(x, y)),
           envfit.fort = map(envfit, envfit_fort),
           pcoa.fort = map2(pcoa, envfit.fort, pcoa_fort),
           pcoa.plot = map2(pcoa.fort, envfit.fort, pcoa_plot),
           tongue.r2 = map(envfit, function(x) x$vectors$r),
           tongue.p = map(envfit, function(x) x$vectors$pvals),
           tongue.MDS1 = map(envfit, function(x) x$vectors$arrows[[1]]),
           tongue.MDS2 = map(envfit, function(x) x$vectors$arrows[[2]])) %>%
    unnest(cols = c(tongue.r2, tongue.p, tongue.MDS1, tongue.MDS2)) %>%
    select(pollen, elev.class, pcoa, envfit, envfit.fort, pcoa.fort, 
           pcoa.plot, tongue.r2, tongue.p, tongue.MDS1, tongue.MDS2) 
}

niche_analysis2 <- function(x, criterion) {
  
  criterion <- enquo(criterion)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>%
    filter(!is.na(pollen)) %>%
    group_by(elev.class, bb.sp, !!criterion, pollen) %>%
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site
    group_by(elev.class, bb.sp, pollen) %>%
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair per site-date
    dplyr::select(-freq) %>%
    group_by(pollen, elev.class) %>%
    nest() %>%
    mutate(data2 = map(data, function(x) pivot_wider(x, names_from = !!criterion, values_from = prop)), # spread into the kind of array vegan likes
           data3 = map(data2, function(x) replace(x, is.na(x), 0)),
           data4 = map(data3, function(x) column_to_rownames(x, var = "bb.sp")),
           pcoa = map(data4,  function(x) capscale(x ~ 1, distance = "horn", scale = TRUE)),
           traits = map(data3, function(x) x %>% 
                          left_join(bb_traits) %>% 
                          column_to_rownames(var = "bb.sp") %>% 
                          select(pbl.w)),
           envfit = map2(pcoa, traits, function(x, y) envfit(x, y)),
           envfit.fort = map(envfit, envfit_fort),
           pcoa.fort = map2(pcoa, envfit.fort, pcoa_fort),
           pcoa.plot = map2(pcoa.fort, envfit.fort, pcoa_plot),
           tongue.r2 = map(envfit, function(x) x$vectors$r),
           tongue.p = map(envfit, function(x) x$vectors$pvals),
           MDS1.varexp = map(pcoa, function(x) x$CA$eig[[1]]),
           MDS2.varexp = map(pcoa, function(x) x$CA$eig[[2]])) %>%
    unnest(cols = c(tongue.r2, tongue.p, MDS1.varexp, MDS2.varexp)) %>%
    select(pollen, elev.class, pcoa, envfit, envfit.fort, pcoa.fort, 
           pcoa.plot, tongue.r2, tongue.p, MDS1.varexp, MDS2.varexp)
  }

# ...and this version breaks it down by elev.class and period
niche_analysis3 <- function(x, criterion) {
  
  criterion <- enquo(criterion)
  
  x %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>%
    filter(!is.na(pollen)) %>%
    group_by(elev.class) %>%
    mutate(period = cut_interval(dayofyear, 3, labels = c("early", "mid", "late"))) %>%
    group_by(elev.class, period, pollen, bb.sp, !!criterion) %>%
    summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair per site
    group_by(elev.class, period, bb.sp, pollen) %>%
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair per site-date
    dplyr::select(-freq) %>%
    group_by(pollen, elev.class, period) %>%
    nest() %>%
    mutate(data2 = map(data, function(x) pivot_wider(x, names_from = !!criterion, values_from = prop)), # spread into the kind of array vegan likes
           data3 = map(data2, function(x) replace(x, is.na(x), 0)),
           data4 = map(data3, function(x) column_to_rownames(x, var = "bb.sp")),
           pcoa = map(data4,  function(x) capscale(x ~ 1, distance = "horn", scale = TRUE)),
           traits = map(data3, function(x) x %>% 
                          left_join(bb_traits) %>% 
                          column_to_rownames(var = "bb.sp") %>% 
                          select(pbl.w)),
           envfit = map2(pcoa, traits, function(x, y) envfit(x, y)),
           envfit.fort = map(envfit, envfit_fort),
           pcoa.fort = map2(pcoa, envfit.fort, pcoa_fort),
           pcoa.plot = map2(pcoa.fort, envfit.fort, pcoa_plot), 
           tongue.r2 = map(envfit, function(x) x$vectors$r),
           tongue.p = map(envfit, function(x) x$vectors$pvals),
           MDS1.varexp = map(pcoa, function(x) x$CA$eig[[1]]),
           MDS2.varexp = map(pcoa, function(x) x$CA$eig[[2]])) %>%
    unnest(cols = c(tongue.r2, tongue.p, MDS1.varexp, MDS2.varexp)) %>%
    select(pollen, elev.class, period, pcoa, envfit, envfit.fort,
           pcoa.fort, pcoa.plot, tongue.r2, tongue.p, MDS1.varexp, MDS2.varexp)
  }
```

Pairwise (bb.sp:bb.sp) niche overlap, pooled by site-year
```{r}
# By plant.sp

## Resolved to sp.pair
niche_overlap.tax1 <- niche_overlapper(net, criterion = plant.sp.abb)
niche_overlap.tax2 <- niche_overlapper2(net, criterion = plant.sp.abb)

## Collapsed to comunity mean
niche_overlap.tax.mean1 <- niche_overlap.tax1 %>%
  group_by(site, year, pollen, elev.mean) %>%
  summarize(niche.overlap.mean = mean(niche.overlap)) %>%
  left_join(BB_covars) %>% # add BB covars
  left_join(FL_covars)

niche_overlap.tax.mean2 <- niche_overlap.tax2 %>%
  group_by(site, pollen, elev.mean) %>%
  summarize(niche.overlap.mean = mean(niche.overlap)) 


# By floral k.type (simplified)

## Resolved to sp.pair
niche_overlap.morph1 <- niche_overlapper(net, criterion = plant.sp.abb)
niche_overlap.morph2 <- niche_overlapper2(net, criterion = plant.sp.abb)

## Collapsed to comunity mean
niche_overlap.morph.mean1 <- niche_overlap.morph1 %>%
  group_by(site, year, pollen, elev.mean) %>%
  summarize(niche.overlap.mean = mean(niche.overlap)) %>%
  left_join(BB_covars) %>% # add BB covars
  left_join(FL_covars)

niche_overlap.morph.mean2 <- niche_overlap.morph %>%
  group_by(site, pollen, elev.mean) %>%
  summarize(niche.overlap.mean = mean(niche.overlap))
```

# 1. What is the logic of niche partitioning between core species, and does it change through elevation and time?
## 1.1 Ordination by species-year with post-hoc fitting of tongue length
```{r}
# By plant.sp
niche.tax <- niche_analysis1(net, plant.sp.abb)
niche.tax <- niche_analysis1.year(net, plant.sp.abb)

## Extract and name plots
pollen.tax <- filter(niche.tax, pollen == "pollen")$pcoa.plot[[1]]
nectar.tax <- filter(niche.tax, pollen == "nopollen")$pcoa.plot[[1]]

## Display plots on grid
pdf("../analyses/output/tax_niche.pdf", height = 8.5, width = 11)
(pollen.tax | nectar.tax) + plot_layout(guides = 'collect') 
dev.off()

# By ktype
niche.morph <- niche_analysis1(net, k.type.s)

## Extract and name plots
pollen.morph <- filter(niche.morph, pollen == "pollen")$pcoa.plot[[1]]
nectar.morph <- filter(niche.morph, pollen == "nopollen")$pcoa.plot[[1]]

## Display plots on grid
pdf("../analyses/output/morph_niche.pdf", height = 8.5, width = 11)
(pollen.morph | nectar.morph) + plot_layout(guides = 'collect') 
dev.off()
```

## 1.2 Ordination by species-year with post-hoc fitting of tongue length, broken down by elevation class
```{r}
# By plant.sp
niche_x_elev.tax <- niche_analysis2(net, plant.sp.abb)

## Extract and name plots
pollen_oben.tax <- filter(niche_x_elev.tax, pollen == "pollen" & elev.class == "oben")$pcoa.plot[[1]]
pollen_mitte.tax <- filter(niche_x_elev.tax, pollen == "pollen" & elev.class == "mitte")$pcoa.plot[[1]]
pollen_unten.tax <- filter(niche_x_elev.tax, pollen == "pollen" & elev.class == "unten")$pcoa.plot[[1]]

nectar_oben.tax <- filter(niche_x_elev.tax, pollen == "nopollen" & elev.class == "oben")$pcoa.plot[[1]]
nectar_mitte.tax <- filter(niche_x_elev.tax, pollen == "nopollen" & elev.class == "mitte")$pcoa.plot[[1]]
nectar_unten.tax <- filter(niche_x_elev.tax, pollen == "nopollen" & elev.class == "unten")$pcoa.plot[[1]]

## Display plots on grid
pdf("../analyses/output/tax_niche_x_elev.pdf", height = 8.5, width = 11)
(pollen_oben.tax | nectar_oben.tax) /
(pollen_mitte.tax | nectar_mitte.tax) /
(pollen_unten.tax | nectar_unten.tax) + plot_layout(guides = 'collect') 
dev.off()

# By ktype
niche_x_elev.morph <- niche_analysis2(net, k.type.s)

## Extract and name plots
pollen_oben.morph <- filter(niche_x_elev.morph, pollen == "pollen" & elev.class == "oben")$pcoa.plot[[1]]
pollen_mitte.morph <- filter(niche_x_elev.morph, pollen == "pollen" & elev.class == "mitte")$pcoa.plot[[1]]
pollen_unten.morph <- filter(niche_x_elev.morph, pollen == "pollen" & elev.class == "unten")$pcoa.plot[[1]]

nectar_oben.morph <- filter(niche_x_elev.morph, pollen == "nopollen" & elev.class == "oben")$pcoa.plot[[1]]
nectar_mitte.morph <- filter(niche_x_elev.morph, pollen == "nopollen" & elev.class == "mitte")$pcoa.plot[[1]]
nectar_unten.morph <- filter(niche_x_elev.morph, pollen == "nopollen" & elev.class == "unten")$pcoa.plot[[1]]

## Display plots on grid
pdf("../analyses/output/morp_niche_x_elev.pdf", height = 8.5, width = 11)
(pollen_oben.morph | nectar_oben.morph) /
(pollen_mitte.morph | nectar_mitte.morph) /
(pollen_unten.morph | nectar_unten.morph) + plot_layout(guides = 'collect') 
dev.off()
```

## 1.3 Ordination by BB species * elev.class * period, pooling across years
```{r}
# By plant species
niche_x_elevperiod.tax <- niche_analysis3(net, plant.sp.abb)

## Extract and name plots
pollen_oben_early.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]]
pollen_oben_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]]
pollen_oben_late.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]]

pollen_mitte_early.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]]
pollen_mitte_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]]
pollen_mitte_late.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]]

#pollen_unten_early.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]]
pollen_unten_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]]
pollen_unten_late.tax <- filter(niche_x_elevperiod.tax, pollen == "pollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]]

nectar_oben_early.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]]
nectar_oben_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]]
nectar_oben_late.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]]

nectar_mitte_early.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]]
nectar_mitte_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]]
nectar_mitte_late.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]]

nectar_unten_early.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]]
nectar_unten_mid.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]]
nectar_unten_late.tax <- filter(niche_x_elevperiod.tax, pollen == "nopollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]]

## Display plots on grid
pdf("../analyses/output/tax_niche_x_elevperiod_pollen.pdf", height = 8.5, width = 11)
(pollen_oben_early.tax | pollen_oben_mid.tax | pollen_oben_late.tax) /
(pollen_mitte_early.tax | pollen_mitte_mid.tax | pollen_mitte_late.tax) /
(plot_spacer() | pollen_unten_mid.tax  | pollen_unten_late.tax)  + plot_layout(guides = 'collect') 
dev.off()

pdf("../analyses/output/tax_niche_x_elevperiod_nectar.pdf", height = 8.5, width = 11)
(nectar_oben_early.tax | nectar_oben_mid.tax | nectar_oben_late.tax) /
(nectar_mitte_early.tax | nectar_mitte_mid.tax | nectar_mitte_late.tax) /
(nectar_unten_early.tax | nectar_unten_mid.tax  | nectar_unten_late.tax)  + plot_layout(guides = 'collect') 
dev.off()


# By ktype
niche_x_elevperiod.morph <- niche_analysis3(net, k.type.s)

## Extract and name plots
pollen_oben_early.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]]
pollen_oben_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]]
pollen_oben_late.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]]

pollen_mitte_early.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]]
pollen_mitte_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]]
pollen_mitte_late.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]]

#pollen_unten_early.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]]
pollen_unten_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]]
pollen_unten_late.morph <- filter(niche_x_elevperiod.morph, pollen == "pollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]]

nectar_oben_early.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "oben" & period == "early")$pcoa.plot[[1]]
nectar_oben_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "oben" & period == "mid")$pcoa.plot[[1]]
nectar_oben_late.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "oben" & period == "late")$pcoa.plot[[1]]

nectar_mitte_early.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "mitte" & period == "early")$pcoa.plot[[1]]
nectar_mitte_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "mitte" & period == "mid")$pcoa.plot[[1]]
nectar_mitte_late.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "mitte" & period == "late")$pcoa.plot[[1]]

nectar_unten_early.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "unten" & period == "early")$pcoa.plot[[1]]
nectar_unten_mid.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "unten" & period == "mid")$pcoa.plot[[1]]
nectar_unten_late.morph <- filter(niche_x_elevperiod.morph, pollen == "nopollen" & elev.class == "unten" & period == "late")$pcoa.plot[[1]]

## Display plots on grid
pdf("../analyses/output/morph_niche_x_elevperiod_pollen.pdf", height = 8.5, width = 11)
(pollen_oben_early.morph | pollen_oben_mid.morph | pollen_oben_late.morph) /
(pollen_mitte_early.morph | pollen_mitte_mid.morph | pollen_mitte_late.morph) /
(plot_spacer() | pollen_unten_mid.morph  | pollen_unten_late.morph)  + plot_layout(guides = 'collect') 
dev.off()

pdf("../analyses/output/morph_niche_x_elevperiod_nectar.pdf", height = 8.5, width = 11)
(nectar_oben_early.morph | nectar_oben_mid.morph | nectar_oben_late.morph) /
(nectar_mitte_early.morph | nectar_mitte_mid.morph | nectar_mitte_late.morph) /
(nectar_unten_early.morph | nectar_unten_mid.morph  | nectar_unten_late.morph)  + plot_layout(guides = 'collect') 
dev.off()


```

## 1.4 Does the influence of tongue length on niche partitioning vary with elevation or time?
```{r}
# By plant.sp
ggplot(niche_x_elevperiod.tax, aes(elev.class, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)

ggplot(niche_x_elevperiod.tax, aes(period, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)

# By ktype
ggplot(niche_x_elevperiod.morph, aes(elev.class, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)

ggplot(niche_x_elevperiod.morph, aes(period, tongue.r2)) +
  geom_boxplot() +
  facet_wrap(~pollen)
```

# 2. Testing the stress-gradient hypothesis and the Ranta and Vepsäläinen heterogeneity hypothesis

**Stress-gradient hypothesis:** Is there any evidence that niche partitioning amongst generalist core bumble bee species is governed by an inverse relationship between elevation and competition, broadly consistent with the stress-gradient hypothesis (Bertness and Callaway 1994). This mechanism has been inferred from trait patterns in the whole bee community of the Berchtesgadener Alps (Hoiss et al. 2012) and from interaction specialization patterns in the plant-pollinator community of Mt. Kilimanjaro (Classen et al. 2020). It predicts that niche overlap will increase with elevation, reflecting competitive pressures at low elevations and reduced competition but increased need for opportunism at high elevations.

**Ranta/Vepsäläinen heterogeneity hypothesis :** Ranta and Vepsäläinen (1981) proposed that bumble bees communities are governed by a spatiotemporally heterogeneous mosaic of competitive conditions, such that competitive inequalities between species are sufficiently variable to allow more species to coexist than predicted by trait-based competition models.

## 2.1: Testing the stress-gradient hypothesis
### 2.1.1 Face-value analysis  

*Results:*  
In the taxonomic model (28% variance explained), niche overlap exhibited a unimodal relationship with elevation in 2010 and 2012 (both significant at p < 0.01), with peak overlap at ~1600 m and ~1250 m, respectively. In 2011, peak niche overlap occurred at the lowest elevations, but after an initial descent, it exhibit a unimodal relationship rather like that of 2010; **this relationship was not significant**, though (p = 0.23). Niche overlap of pollen visits was significantly (p = 0.01) lower than that of nectar visits. There was no significant effect of year.

In the morphological model (31% variance explained), niche overlap exhibited a significant relationship with elevation in all three years. In each year, the relationship was approximately quadratic, peaking at low elevation and descending with increasing elevation. In 2010 and 2012, the curve drops off steepy above 1500 m. In 2011, the curve is nearly linear.  Niche overlap of pollen visits was significantly (p = 0.01) lower than that of nectar visits, and there was no significant effect of year.

These results, of course, do not support H1. But there is a caveat. These models try to explain face-value niche overlap, but they do not try to distinguish observed niche overlap from the predictions of a null model. It is possible that the patterns we see would be predicted simply by the abundance relationships in our community. Niche overlap is, in fact, strongly predicted by bumble bee abundance, which is itself strongly correlated with bumble bee richness. One response is, well, so what? These are the observed patterns of niche overlap, and we may not care to disentangle the effects of abundance from those of behavioral changes. 

```{r}
## Taxonomic niche partitioning

# Whole community (pairwise)
ggplot(niche_overlap.tax1, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_wrap(~year)

ggplot(niche_overlap.tax2, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10))

# Whole community (collapsed to mean)
ggplot(niche_overlap.tax.mean, aes(elev.mean, niche.overlap.mean, color = pollen)) +
  geom_point(alpha = 0.25) +
  facet_wrap(~year) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

ggplot(niche_overlap.tax.mean2, aes(elev.mean, niche.overlap.mean, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

# GAM
niche_comm_tax_GAM <- gam(niche.overlap.mean ~ 
                           year +
                           pollen +
                          # s(sqrt.bb.abund, k = 4) +
                           s(elev.mean, by = year, k = 10, m = 2),
                         method = "REML",
                         family = "gaussian",
                         data = niche_overlap.tax.mean) %>% getViz()

check.gamViz(niche_comm_tax_GAM)
summary(niche_comm_tax_GAM)
print(plot(niche_comm_tax_GAM, allTerms = TRUE), pages = 1)

niche_comm_tax_GAM2 <- gam(niche.overlap.mean ~ 
                           pollen +
                           s(elev.mean, by = pollen, k = 10),
                         method = "REML",
                         family = "gaussian",
                         data = niche_overlap.tax.mean2) %>% getViz()

check.gamViz(niche_comm_tax_GAM2)
summary(niche_comm_tax_GAM2)
print(plot(niche_comm_tax_GAM2, allTerms = TRUE), pages = 1)

## Morphological niche partitioning

# Whole community
ggplot(niche_overlap.morph, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_wrap(~year)

ggplot(niche_overlap.morph2, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10))

# Whole community (collapsed to mean)
ggplot(niche_overlap.morph.mean, aes(elev.mean, niche.overlap.mean, color = pollen)) +
  geom_point(alpha = 0.25) +
  facet_wrap(~year) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) 

ggplot(niche_overlap.morph.mean2, aes(elev.mean, niche.overlap.mean, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10))

# GAM
niche_comm_morph_GAM <- gam(niche.overlap.mean ~ 
                              year +
                              pollen +
                              #s(sqrt.bb.abund, k = 4) +
                              s(elev.mean, by = year, k = 10),
                            method = "REML",
                            family = "gaussian",
                            data = niche_overlap.morph.mean) %>% getViz()

check.gamViz(niche_comm_morph_GAM)
summary(niche_comm_morph_GAM)
print(plot(niche_comm_morph_GAM, allTerms = TRUE), pages = 1)

niche_comm_morph_GAM2 <- gam(niche.overlap.mean ~ 
                              pollen +
                              s(elev.mean, by = pollen, k = 10),
                            method = "REML",
                            family = "gaussian",
                            data = niche_overlap.morph.mean2) %>% getViz()

check.gamViz(niche_comm_morph_GAM2)
summary(niche_comm_morph_GAM2)
print(plot(niche_comm_morph_GAM2, allTerms = TRUE), pages = 1)
```

We find no support for H1 at the community-mean level. But perhaps this conceals a diversity of responses to elevation in **individual species pairs**. Let's talk about that.

*Results*
These models are hard to fit nicely due to the sparcity of data and high noise at the level of individual species pairs, but what we see here does not appear to add much to what we learned from the community mean model. Individual species pairs tend to exhibit either unimodal or linear decreasing responses, some of which are statistically significant, some of which are. 

```{r}
## Taxonomic niche partitioning

# Whole community (pairwise)
ggplot(niche_overlap.tax, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_grid(year~sp.pair) +
  ylim(c(0,1))

ggplot(niche_overlap.tax2, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_wrap(~sp.pair) +
  ylim(c(0,1))

# GAM
niche_pairwise_tax_GAM <- gam(niche.overlap ~ 
                               s(year, bs = "re") +
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.tax) %>% getViz()

check.gamViz(niche_pairwise_tax_GAM)
summary(niche_pairwise_tax_GAM)
print(plot(niche_pairwise_tax_GAM, allTerms = TRUE), pages = 1)

niche_pairwise_tax_GAM2 <- gam(niche.overlap ~ 
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.tax2) %>% getViz()

check.gamViz(niche_pairwise_tax_GAM2)
summary(niche_pairwise_tax_GAM2)
print(plot(niche_pairwise_tax_GAM2, allTerms = TRUE), pages = 1)

## Morphological niche partitioning

# Whole community (pairwise)
ggplot(niche_overlap.morph, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_grid(year~sp.pair) +
  ylim(c(0,1))

ggplot(niche_overlap.morph2, aes(elev.mean, niche.overlap, color = pollen)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 10)) +
  facet_wrap(~sp.pair) +
  ylim(c(0,1))

# GAM
niche_pairwise_morph_GAM <- gam(niche.overlap ~ 
                               s(year, bs = "re") +
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.morph) %>% getViz()

check.gamViz(niche_pairwise_morph_GAM)
summary(niche_pairwise_morph_GAM)
print(plot(niche_pairwise_morph_GAM, allTerms = TRUE), pages = 1)

niche_pairwise_morph_GAM2 <- gam(niche.overlap ~ 
                               s(pollen, bs = "re") +
                               s(elev.mean, by = sp.pair, k = 10),
                             method = "REML",
                             family = "gaussian",
                             data = niche_overlap.morph2) %>% getViz()

check.gamViz(niche_pairwise_morph_GAM2)
summary(niche_pairwise_morph_GAM2)
print(plot(niche_pairwise_morph_GAM2, allTerms = TRUE), pages = 1)
```

### 2.1.2 Null-model residual analysis  

Arguably the most rigorous way to tease out the effect of elevation while controlling for community composition (abundance and richness patterns) is to compare the observed niche overlap at each site to that predicted by a random null model, then see how the residuals vary with elevation.

I'll be the first to admit that I'm new to null models, so I want to be extremely clear about the logic of how I'm setting this up. Step-by-step:  
1. Generate community matrices by site, pollen/nectar, and year
2. Permute each matrix *n* times by randomly redistributing the visits of each bumble bee species while holding the total visits for each bumble bee species constant. This is, therefore, a random selection model constrained to the set of flora visited for a given site-pollen-year matrix. Importantly, I am opting not to hold the floral marginal totals constant, i.e. the total number of visits that each plant receives will vary with each permutation. My gut feeling is that this is the right place to start, but this is a decision that requires scrutiny.
3. Calculate niche overlap for each permuted matrix and store as tidy arrays; this mirrors the workflow for calculating empirical niche overlap, the only difference being that I had to deal with some tricky nested lists; I'm pretty sure I did this correctly.
4. Take the mean niche overlap for each permuted community.
5. Join null model mean niche overlap table to empirical niche overlap table, joining by site, year, and pollen. Thus, for each site-year-pollen combo in the empirical niche overlap table, we have *n* iterations of random niche overlap.
6. Calculate the difference between empirical niche overlap and null niche overlap for each iteration; we'll call this "residual niche overlap".
7. Calculate mean residual niche overlap for each site-year-pollen combo. This can then be regressed against elevation to see how the deviation from null expectations varies along the elevation gradient, with the understanding that this represents the "pure" influence of elevation on niche overlap whle controlling for community differences. We could also use the raw differences without collapsing them to a mean. But that's not what I did this first time through. 

There are surely a lot of other ways a null model could be constructed and analyzed, but this seems to me a good place to start.

*Results*
Encouragingly, the results of the null model look very similar to those of the "face-value" analysis. The only difference that stands out is that there is no longer a significant difference between pollen and nectar visits. Perhaps that was an artifact of abundance? In any case, our conclusions regarding H1 are the same. 

```{r message=FALSE, warning=FALSE}
### Define function that will be used inside map() calls
df_to_cmat <- function(x, criterion) {
  pivot_wider(x, names_from = criterion, values_from = freq) %>%
    replace(is.na(.), 0)
}

permat_set <- function(x){
  x %>%
    column_to_rownames("bb.sp") %>%
    vegan::permatfull(fixedmar = "rows", shuffle = "ind", times = 50)
}

ret <- function(x){
  return(x$perm)
}

tidy_dist <- function(x) {
  x %>%
    tidy() %>%
    mutate(index = seq_along())
}

### Generate random niche overlap data
#### Need to look into th the missing value warnings I'm getting from the vegdist() call; I think it's because some plants end up with zero visits in some permutations.
random_niche.tax <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
  select(site, pollen, year, bb.sp, plant.sp) %>% 
  group_by(site, pollen, year, bb.sp, plant.sp) %>%
  summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair
  group_by(site, pollen, year) %>%
  nest() %>% # nest data into list-column grouped by pollen, site, date
  mutate(data = map(data, 
                    function(x) pivot_wider(x, 
                                            names_from = plant.sp, 
                                            values_from = freq) %>% replace(is.na(.), 0)), # turn table into community matrix
         data = map(data, permat_set), # permute community matrices
         data = map(data, ret)) %>% # extract permutations from permat objects
  unnest(data) %>% # unnest
  mutate(data = map(data, function(x) vegdist(x, method = "horn")), # convert each permutation into distance matrix
         data = map(data, tidy)) %>% # convert distance matrices to tidy arrays
  group_by(site, pollen, year) %>%
  mutate(iter = row_number()) %>% # add index to denote iterations
  unnest(cols = data) %>% # unnest again
  rename(bb.sp1 = item1, bb.sp2 = item2) %>%
  unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
  mutate(sp.pair = factor(sp.pair), # ...and make it a factor so that mgcv can handle it
         niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
  select(site, pollen, year, sp.pair, iter, niche.overlap)

random_niche.tax.mean <- random_niche.tax %>%
  group_by(site, pollen, year, iter) %>%
  summarize(random.niche.overlap.mean = mean(niche.overlap)) 

random_niche.tax2 <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
  select(site, pollen, bb.sp, plant.sp) %>% 
  group_by(site, pollen, bb.sp, plant.sp) %>%
  summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair
  group_by(site, pollen) %>%
  nest() %>% # nest data into list-column grouped by pollen, site, date
  mutate(data = map(data, df_to_cmat.sp), # turn table into community matrix
         data = map(data, permat_set), # permute community matrices
         data = map(data, ret)) %>% # extract permutations from permat objects
  unnest(data) %>% # unnest
  mutate(data = map(data, function(x) vegdist(x, method = "horn")), # convert each permutation into distance matrix
         data = map(data, tidy)) %>% # convert distance matrices to tidy arrays
  group_by(site, pollen) %>%
  mutate(iter = row_number()) %>% # add index to denote iterations
  unnest(cols = data) %>% # unnest again
  rename(bb.sp1 = item1, bb.sp2 = item2) %>%
  unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
  mutate(sp.pair = factor(sp.pair), # ...and make it a factor so that mgcv can handle it
         niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
  select(site, pollen, sp.pair, iter, niche.overlap)

random_niche.sp.mean <- random_niche %>%
  group_by(site, pollen, year, iter) %>%
  summarize(random.niche.overlap.mean = mean(niche.overlap)) 

random_niche.sp.mean2 <- random_niche2 %>%
  group_by(site, pollen, iter) %>%
  summarize(random.niche.overlap.mean = mean(niche.overlap))


random_niche.ktype <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
  select(site, pollen, year, bb.sp, k.type.s) %>% 
  group_by(site, pollen, year, bb.sp, k.type.s) %>%
  summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair
  group_by(site, pollen, year) %>%
  nest() %>% # nest data into list-column grouped by pollen, site, date
  mutate(data = map(data, df_to_cmat.ktype), # turn table into community matrix
         data = map(data, permat_set), # permute community matrices
         data = map(data, ret)) %>% # extract permutations from permat objects
  unnest(data) %>% # unnest
  mutate(data = map(data, function(x) vegdist(x, method = "horn")), # convert each permutation into distance matrix
         data = map(data, tidy)) %>% # convert distance matrices to tidy arrays
  group_by(site, pollen, year) %>%
  mutate(iter = row_number()) %>% # add index to denote iterations
  unnest(cols = data) %>% # unnest again
  rename(bb.sp1 = item1, bb.sp2 = item2) %>%
  unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
  mutate(sp.pair = factor(sp.pair), # ...and make it a factor so that mgcv can handle it
         niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
  select(site, pollen, year, sp.pair, iter, niche.overlap)

random_niche.ktype2 <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>% # drop observations with no pollen/nectar classification
  select(site, pollen, bb.sp, k.type.s) %>% 
  group_by(site, pollen, bb.sp, k.type.s) %>%
  summarize(freq = n()) %>% # get interaction frequency for each BB-FL pair
  group_by(site, pollen) %>%
  nest() %>% # nest data into list-column grouped by pollen, site, date
  mutate(data = map(data, df_to_cmat.ktype), # turn table into community matrix
         data = map(data, permat_set), # permute community matrices
         data = map(data, ret)) %>% # extract permutations from permat objects
  unnest(data) %>% # unnest
  mutate(data = map(data, function(x) vegdist(x, method = "horn")), # convert each permutation into distance matrix
         data = map(data, tidy)) %>% # convert distance matrices to tidy arrays
  group_by(site, pollen) %>%
  mutate(iter = row_number()) %>% # add index to denote iterations
  unnest(cols = data) %>% # unnest again
  rename(bb.sp1 = item1, bb.sp2 = item2) %>%
  unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":") %>% # create a single species pair column...
  mutate(sp.pair = factor(sp.pair), # ...and make it a factor so that mgcv can handle it
         niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
  select(site, pollen, sp.pair, iter, niche.overlap)

random_niche.ktype.mean <- random_niche %>%
  group_by(site, pollen, year, iter) %>%
  summarize(random.niche.overlap.mean = mean(niche.overlap)) 

random_niche.ktype.mean2 <- random_niche2 %>%
  group_by(site, pollen, iter) %>%
  summarize(random.niche.overlap.mean = mean(niche.overlap))

## Join null model to empirical niche overlap
# Taxonomic niche overlap
comparison.sp <- niche_overlap.sp.mean %>%
  left_join(random_niche.sp.mean) %>%
  mutate(niche.overlap.resid = niche.overlap.mean - random.niche.overlap.mean) %>%
  group_by(site, year, pollen, elev.mean, niche.overlap.mean) %>%
  summarize(mean.resid = mean(niche.overlap.resid))

comparison.sp2 <- niche_overlap.sp.mean2 %>%
  left_join(random_niche.sp.mean2) %>%
  mutate(niche.overlap.resid = niche.overlap.mean - random.niche.overlap.mean) %>%
  group_by(site, year, pollen, elev.mean, niche.overlap.mean) %>%
  summarize(mean.resid = mean(niche.overlap.resid))

ggplot(comparison.sp, aes(elev.mean, mean.resid, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ year)

ggplot(comparison.sp2, aes(elev.mean, mean.resid, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ year)

## GAM
null_resid_sp_GAM <- gam(mean.resid ~ 
                           year +
                           pollen +
                           s(elev.mean, by = year, k = 10),
                         method = "REML",
                         family = "gaussian",
                         data = comparison.sp) %>% getViz()

check.gamViz(null_resid_sp_GAM)
summary(null_resid_sp_GAM)
print(plot(null_resid_sp_GAM, allTerms = TRUE), pages = 1)

null_resid_sp_GAM2 <- gam(mean.resid ~ 
                           pollen +
                           s(elev.mean, by = pollen, k = 10),
                         method = "REML",
                         family = "gaussian",
                         data = comparison.sp2) %>% getViz()

check.gamViz(null_resid_sp_GAM2)
summary(null_resid_sp_GAM2)
print(plot(null_resid_sp_GAM2, allTerms = TRUE), pages = 1)

# Morphological niche overlap
comparison.ktype <- niche_overlap.ktype.mean %>%
  left_join(random_niche.ktype.mean) %>%
  mutate(niche.overlap.resid = niche.overlap.mean - random.niche.overlap.mean) %>%
  group_by(site, year, pollen, elev.mean, niche.overlap.mean) %>%
  summarize(mean.resid = mean(niche.overlap.resid))

comparison.ktype2 <- niche_overlap.ktype.mean2 %>%
  left_join(random_niche.ktype.mean2) %>%
  mutate(niche.overlap.resid = niche.overlap.mean - random.niche.overlap.mean) %>%
  group_by(site, year, pollen, elev.mean, niche.overlap.mean) %>%
  summarize(mean.resid = mean(niche.overlap.resid))

ggplot(comparison.ktype, aes(elev.mean, mean.resid, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ year)

ggplot(comparison.ktype2, aes(elev.mean, mean.resid, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~ year)

## GAM
null_resid_ktype_GAM <- gam(mean.resid ~ 
                              year +
                              pollen +
                              s(elev.mean, by = year, k = 10),
                            method = "REML",
                            family = "gaussian",
                            data = comparison.ktype) %>% getViz()

check.gamViz(null_resid_ktype_GAM)
summary(null_resid_ktype_GAM)
print(plot(null_resid_ktype_GAM, allTerms = TRUE), pages = 1)

null_resid_ktype_GAM2 <- gam(mean.resid ~ 
                              pollen +
                              s(elev.mean, by = pollen, k = 10),
                            method = "REML",
                            family = "gaussian",
                            data = comparison.ktype2) %>% getViz()

check.gamViz(null_resid_ktype_GAM2)
summary(null_resid_ktype_GAM2)
print(plot(null_resid_ktype_GAM2, allTerms = TRUE), pages = 1)
```

### 2.1.3. Parsing niche contraction and niche separation

Contrary to the predictions of H1, niche overlap decreases sharply at high elevation. This is true for both taxonomic and morphological niche overlap, and it holds in both the face-value and null-residual approaches. This decrease in niche overlap might be explained by two modest, proximate hypotheses:  

1.  **H1:** The decrease of niche overlap at high elevations is due to *niche contraction*, i.e. BB spp. visiting a smaller proportion of available (and "eligible", i.e. visited at least once by a bumble bee) flora. 
  *Prediction:* "resource range" (Poisot et al. 2012) will decrease with elevation (as Dormann notes, resource range is a "backward" metric insofar as a large resource range means a small proportional niche breadth; I will calculate the inverse of resource range so that it makes more sense)
2.  **H2:** The decrease of niche overlap at high elevations is due to *niche separation*, i.e. BB spp. avoiding one another's niches but not contracting their own.
  *Predictions:* C score will increase with elevation
  
*Results:* I haven't run formal stats on this analysis yet, but from the visualization, it looks like the overall story is that niche overlap is driven mainly by niche separation, not so much but niche contraction. My first impression is that this suggests a behavior response to competition.

```{r}
resource_range.sp <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>%
  group_by(site, year, pollen, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
  summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
  unite(webID, c(site, year, pollen), sep = "_") %>%
  ungroup() %>%
  dplyr::select(higher = bb.sp, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
  data.frame() %>% # convert to data frame
  frame2webs() %>% # convert to to bipartite web
  map(specieslevel, level = "higher", index = "resource range") %>%
  map(rownames_to_column) %>%
  map(as_tibble) %>%
  bind_rows(.id = "webID") %>% # Collapse list into big data frame
  rename(bb.sp = rowname) %>%
  separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
  left_join(site_data) %>%
  mutate(site = factor(site),
         year = factor(year),
         pollen = factor(pollen)) %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # for some reason, one row has a "1" for bb.sp, and I don't know where this comes from; this gets rid of it, but I would still like to know why
  mutate(resource.range = 1-resource.range) %>%
  left_join(BB_covars.splevel) %>%
  filter(bb.sp.abund > 1)

resource_range.sp.mean <- resource_range.sp %>%
  group_by(site, year, elev.mean, pollen) %>%
  summarize(mean.resource.range = mean(resource.range))
  
ggplot(resource_range.sp, aes(elev.mean, resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_grid(bb.sp ~ year) +
  ylim(c(0,1))

ggplot(resource_range.sp.mean, aes(elev.mean, mean.resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year) +
  ylim(c(0,1))

resource_range.ktype <- net %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
  filter(!is.na(pollen)) %>%
  group_by(site, year, pollen, bb.sp, k.type.s) %>% # group by site, date, bee species, plant species
  summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
  unite(webID, c(site, year, pollen), sep = "_") %>%
  ungroup() %>%
  dplyr::select(higher = bb.sp, lower = k.type.s, webID, freq) %>% # rename columns to match bipartite's expectations
  data.frame() %>% # convert to data frame
  frame2webs() %>% # convert to to bipartite web
  map(specieslevel, level = "higher", index = "resource range") %>%
  map(rownames_to_column) %>%
  map(as_tibble) %>%
  bind_rows(.id = "webID") %>% # Collapse list into big data frame
  rename(bb.sp = rowname) %>%
  separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
  left_join(site_data) %>%
  mutate(site = factor(site),
         year = factor(year),
         pollen = factor(pollen)) %>%
  filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # for some reason, one row has a "1" for bb.sp, and I don't know where this comes from; this gets rid of it, but I would still like to know why
  mutate(resource.range = 1-resource.range) %>%
  left_join(BB_covars.splevel) %>%
  filter(bb.sp.abund > 1)

resource_range.ktype.mean <- resource_range.ktype %>%
  group_by(site, year, elev.mean, pollen) %>%
  summarize(mean.resource.range = mean(resource.range))
  
ggplot(resource_range.ktype, aes(elev.mean, resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_grid(bb.sp ~ year) +
  ylim(c(0,1))

ggplot(resource_range.ktype.mean, aes(elev.mean, mean.resource.range, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year) +
  ylim(c(0,1))

cscore.sp <- net %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>%
    group_by(site, year, pollen, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
    summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
    group_by(site, year, pollen) %>%
    unite(webID, c(site, year, pollen), sep = "_") %>%
    ungroup() %>%
    dplyr::select(higher = bb.sp, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
    data.frame() %>% # convert to data frame
    frame2webs() %>% # convert to to bipartite web
    map(grouplevel, level = "higher", weighted = TRUE, index = c("C score")) %>% 
    data.frame() %>%
    t() %>%
    data.frame() %>%
    rownames_to_column() %>%
    dplyr::select(webID = rowname, everything()) %>%
    as_tibble() %>%
    separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
    left_join(site_data) %>%
    mutate(site = factor(site),
           year = factor(year),
           pollen = factor(pollen))

ggplot(cscore.sp, aes(elev.mean, C.score.HL, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year)

cscore.ktype <- net %>%
    filter(bb.sp %in% c("bss", "pasc", "prat", "hort", "soro", "wurf")) %>% # focal species
    filter(!is.na(pollen)) %>%
    group_by(site, year, pollen, bb.sp, k.type.s) %>% # group by site, date, bee species, plant species
    summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
    group_by(site, year, pollen) %>%
    unite(webID, c(site, year, pollen), sep = "_") %>%
    ungroup() %>%
    dplyr::select(higher = bb.sp, lower = k.type.s, webID, freq) %>% # rename columns to match bipartite's expectations
    data.frame() %>% # convert to data frame
    frame2webs() %>% # convert to to bipartite web
    map(grouplevel, level = "higher", weighted = TRUE, index = c("C score")) %>% 
    data.frame() %>%
    t() %>%
    data.frame() %>%
    rownames_to_column() %>%
    dplyr::select(webID = rowname, everything()) %>%
    as_tibble() %>%
    separate(webID, c("site", "year", "pollen"), sep =  "_") %>%
    left_join(site_data) %>%
    mutate(site = factor(site),
           year = factor(year),
           pollen = factor(pollen))

ggplot(cscore.ktype, aes(elev.mean, C.score.HL, color = pollen)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~year)
```

