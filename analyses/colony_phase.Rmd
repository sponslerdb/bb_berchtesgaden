---
title: "colony_phase.Rmd"
output: html_document
---

### Prepare environment
```{r setup, include=FALSE}
library(tidyverse)
library(lubridate)
```

### Define functions
```{r include=FALSE}
# Find breakpoints on GDD scale
breakpoints_gdd <- function(x, year, t1, t2) {
  
  data <- filter(x, year == !!year)
  
  # Logistic regression for first break point (founding to buildup)
  glm1.low <- glm(q.prop ~ gdd.cum,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "low"))
  
  glm1.mid <- glm(q.prop ~ gdd.cum,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "mid"))
    
  glm1.high <- glm(q.prop ~ gdd.cum,
                   family = quasibinomial,
                   data = filter(data, elev.class2 == "high"))
  
  # Logistic regression for second break point (buildup to reproductive)
  glm2.low <- glm(r.prop ~ gdd.cum,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "low"))
  
  glm2.mid <- glm(r.prop ~ gdd.cum,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "mid"))
    
  glm2.high <- glm(r.prop ~ gdd.cum,
                   family = quasibinomial,
                   data = filter(data, elev.class2 == "high"))
  
  ### Extract gdd corresponding to desired proportion; based on https://stackoverflow.com/questions/32040504/regression-logistic-in-r-finding-x-value-predictor-for-a-particular-y-value
  
  getX <- function(x, y) {
    (log(y/(1-y)) - coef(x)[1])/coef(x)[2]
    }

  break1.low <- getX(glm1.low, t1) %>%
    data.frame() %>%
    select(gdd = 1) %>%
    mutate(elev.class2 = "low",
           breakID = "break1")  

  break1.mid <- getX(glm1.mid, t1) %>%
    data.frame() %>%
    select(gdd = 1) %>%
    mutate(elev.class2 = "mid",
           breakID = "break1")
  
  break1.high <- getX(glm1.high, t1) %>%
    data.frame() %>%
    select(gdd = 1) %>%
    mutate(elev.class2 = "high",
           breakID = "break1")
  
  break2.low <- getX(glm2.low, t2) %>%
    data.frame() %>%
    select(gdd = 1) %>%
    mutate(elev.class2 = "low",
           breakID = "break2")  
  
  break2.mid <- getX(glm2.mid, t2) %>%
    data.frame() %>%
    select(gdd = 1) %>%
    mutate(elev.class2 = "mid",
           breakID = "break2")
  
  break2.high <- getX(glm2.high, t2) %>%
    data.frame() %>%
    select(gdd = 1) %>%
    mutate(elev.class2 = "high",
           breakID = "break2")
  
  # Join into data frame, convert elev.class2 to ordered factor, spread
  breaks <- full_join(break1.low, break1.mid) %>%
    full_join(break1.high) %>%
    full_join(break2.low) %>%
    full_join(break2.mid) %>%
    full_join(break2.high) %>%
    mutate(elev.class2 = factor(elev.class2, levels = c("high", "mid", "low"))) %>%
    spread(breakID, gdd)
  
  #
  out <- data %>%
    full_join(breaks) %>%
    gather(caste, count, -c(site, date, year, q.prop, r.prop,
                          gdd.cum, yday, elev.class, elev.class2, 
                          management, transect, elev.mean, 
                          lat, lon, break1, break2)) %>%
  group_by(site, date) %>%
  mutate(prop = count/sum(count))
}

# Find breakpoints on Julian scale
breakpoints_yday <- function(x, year, t1, t2) {
  
  data <- filter(x, year == !!year)
  
  # Logistic regression for first break point (founding to buildup)
  glm1.low <- glm(q.prop ~ yday,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "low"))
  
  glm1.mid <- glm(q.prop ~ yday,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "mid"))
    
  glm1.high <- glm(q.prop ~ yday,
                   family = quasibinomial,
                   data = filter(data, elev.class2 == "high"))
  
  # Logistic regression for second break point (buildup to reproductive)
  glm2.low <- glm(r.prop ~ yday,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "low"))
  
  glm2.mid <- glm(r.prop ~ yday,
                  family = quasibinomial,
                  data = filter(data, elev.class2 == "mid"))
    
  glm2.high <- glm(r.prop ~ yday,
                   family = quasibinomial,
                   data = filter(data, elev.class2 == "high"))
  
  ### Extract gdd corresponding to desired proportion; based on https://stackoverflow.com/questions/32040504/regression-logistic-in-r-finding-x-value-predictor-for-a-particular-y-value
  
  getX <- function(x, y) {
    (log(y/(1-y)) - coef(x)[1])/coef(x)[2]
    }

  break1.low <- getX(glm1.low, t1) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "low",
           breakID = "break1")  

  break1.mid <- getX(glm1.mid, t1) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "mid",
           breakID = "break1")
  
  break1.high <- getX(glm1.high, t1) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "high",
           breakID = "break1")
  
  break2.low <- getX(glm2.low, t2) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "low",
           breakID = "break2")  
  
  break2.mid <- getX(glm2.mid, t2) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "mid",
           breakID = "break2")
  
  break2.high <- getX(glm2.high, t2) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "high",
           breakID = "break2")
  
  # Join into data frame, convert elev.class2 to ordered factor, spread
  breaks <- full_join(break1.low, break1.mid) %>%
    full_join(break1.high) %>%
    full_join(break2.low) %>%
    full_join(break2.mid) %>%
    full_join(break2.high) %>%
    mutate(elev.class2 = factor(elev.class2, levels = c("high", "mid", "low"))) %>%
    spread(breakID, day)
  
  #
  out <- data %>%
    full_join(breaks) %>%
    gather(caste, count, -c(site, date, year, q.prop, r.prop,
                          gdd.cum, yday, elev.class, elev.class2, 
                          management, transect, elev.mean, 
                          lat, lon, break1, break2)) %>%
  group_by(site, date) %>%
  mutate(prop = count/sum(count))
}

# Find Juian breakpoints across all elevations
breakpoints_yday_all <- function(x, year, t1, t2) {
  
  data <- filter(x, year == !!year)
  
  # Logistic regression for first break point (founding to buildup)
  glm1 <- glm(q.prop ~ yday,
                  family = quasibinomial,
                  data = data)

  # Logistic regression for second break point (buildup to reproductive)
  glm2 <- glm(r.prop ~ yday,
                  family = quasibinomial,
                  data = data)
  
  ### Extract day corresponding to desired proportion; based on https://stackoverflow.com/questions/32040504/regression-logistic-in-r-finding-x-value-predictor-for-a-particular-y-value
  
  getX <- function(x, y) {
    (log(y/(1-y)) - coef(x)[1])/coef(x)[2]
    }

  break1 <- getX(glm1, t1) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "low",
           breakID = "break1") 
  
  break2 <- getX(glm2, t2) %>%
    data.frame() %>%
    select(day = 1) %>%
    mutate(elev.class2 = "low",
           breakID = "break2")  
  
  # Join into data frame, convert elev.class2 to ordered factor, spread
  breaks <- full_join(break1, break2) %>%
    spread(breakID, day)
  
  #
  out <- data %>%
    full_join(breaks) %>%
    gather(caste, count, -c(site, date, year, q.prop, r.prop,
                          gdd.cum, yday, elev.class, elev.class2, 
                          management, transect, elev.mean, 
                          lat, lon, break1, break2)) %>%
  group_by(site, date) %>%
  mutate(prop = count/sum(count))
}

# Binomial ggplot smoother
binomial_smooth <- function(...) {
  geom_smooth(method = "glm", method.args = list(family = "quasibinomial"), se = FALSE, ...)
}
```

### Load site data
```{r, include=FALSE}
site_data <- read_csv("../processed_data/site_data.csv") %>%
  dplyr::select(-c(slope.calc, slope.est, elev.min, elev.max, temp.mean)) %>% # drop these variables
  mutate(elev.class = factor(elev.class, levels = c("oben", "mitte", "unten")),
         elev.class2 = factor(elev.class2, levels = c("high", "mid", "low"))) # turn elav.class into an ordered factor
```

### Load climate data
```{r, include=FALSE}
gdd <- read_csv("../processed_data/climate.csv") %>%
  mutate(year = factor(year)) %>%
  select(site, date, gdd.cum)
```

### Colony phase breakpoint analysis
```{r, include=FALSE}
castes <- read_csv("../processed_data/network.csv") %>%
  filter(bb.sp != "psit") %>% # We do not want to consider Psithyrus, since these parasitic species do not have a worker caste
  group_by(site, date, year, caste) %>%
  summarize(caste.count = n()) %>%
  spread(caste, caste.count) %>%
  replace(is.na(.), 0) %>%
  mutate(queen = oldqueen + queen,
         reproductive = male + youngqueen,
         q.prop = queen/(queen+worker+reproductive),
         r.prop = reproductive/(queen+worker+reproductive)) %>%
  select(-oldqueen, -youngqueen, -male) %>%
  left_join(gdd, by = c("site", "date")) %>%
  left_join(site_data, by = c("site")) %>%
  arrange(gdd.cum) %>%
  mutate(yday = yday(date))

breaks_2012_gdd <- breakpoints_gdd(castes, 2012, t1 = 0.5, t2 = 0.15)
breaks_2011_gdd <- breakpoints_gdd(castes, 2011, t1 = 0.5, t2 = 0.15)
breaks_2010_gdd <- breakpoints_gdd(castes, 2010, t1 = 0.5, t2 = 0.15)

breaks_2012_yday <- breakpoints_yday(castes, 2012, t1 = 0.5, t2 = 0.15)
breaks_2011_yday <- breakpoints_yday(castes, 2011, t1 = 0.5, t2 = 0.15)
breaks_2010_yday <- breakpoints_yday(castes, 2010, t1 = 0.5, t2 = 0.15)

breaks_gdd_summary <- full_join(breaks_2012_gdd, 
                                breaks_2011_gdd) %>%
  full_join(breaks_2010_gdd)

write_csv(breaks_gdd_summary, "./output/breaks_gdd.csv")

breaks_yday_summary <- full_join(breaks_2012_yday, 
                                 breaks_2011_yday) %>%
  full_join(breaks_2010_yday)

write_csv(breaks_yday_summary, "./output/breaks_yday.csv")

breaks_yday <- bind_rows(breaks_2012_yday, breaks_2011_yday, breaks_2010_yday) %>%
  ungroup() %>%
  select(site, year, break1.yday = break1, break2.yday = break2) %>%
  unique()

breaks_gdd <- bind_rows(breaks_2012_gdd, breaks_2011_gdd, breaks_2010_gdd) %>%
  ungroup() %>%
  select(site, year, break1.gdd = break1, break2.gdd = break2) %>%
  unique()

breaks <- full_join(breaks_yday, breaks_gdd, by = c("site", "year")) %>%
  mutate(year = factor(year))

write_csv(breaks, "./output/breaks.csv")
```

### Plot phase breakpoints
```{r, include=FALSE}
breaks_summary <- full_join(breaks_gdd_summary, breaks_yday_summary) %>%
  select(site, date, year, elev.class2, yday, gdd.cum, break1, break2, caste, prop) %>%
  gather(time.metric, value, -c(site, date, year, elev.class2, break1, break2, caste, prop))

ggplot(breaks_yday_summary, aes(yday, prop, color = caste)) +
  geom_point(alpha = 0.5) +
  binomial_smooth(formula = y ~ splines::ns(x, 2)) +
  geom_vline(aes(xintercept = break1), linetype = "dashed") +
  geom_vline(aes(xintercept = break2), linetype = "dashed") +
  facet_grid(elev.class2 ~ year) +
  xlab("Calendar day") +
  ylab("Proportional abundance")

ggplot(breaks_gdd_summary, aes(gdd.cum, prop, color = caste)) +
  geom_point(alpha = 0.5) +
  binomial_smooth(formula = y ~ splines::ns(x, 2)) +
  geom_vline(aes(xintercept = break1), linetype = "dashed") +
  geom_vline(aes(xintercept = break2), linetype = "dashed") +
  facet_grid(elev.class2 ~ year) +
  xlab("GDD") +
  ylab("Proportional abundance") 

ggplot(breaks_summary, aes(value, prop, color = caste)) +
  geom_point(alpha = 0.25) +
  binomial_smooth(formula = y ~ splines::ns(x, 2)) +
  facet_grid(elev.class2~ time.metric, scales = "free") +
  xlab("Julian day") +
  ylab("Proportional abundance") 

ggplot(breaks_summary, aes(value, prop, color = caste)) +
  geom_point(alpha = 0.25) +
  binomial_smooth(formula = y ~ splines::ns(x, 2)) +
  facet_grid(elev.class2~ time.metric, scales = "free") +
  xlab("Julian day") +
  ylab("Proportional abundance") 

ggplot(filter(breaks_summary, time.metric == "yday"), 
       aes(value, prop, color = caste)) +
  geom_point(alpha = 0.25) +
  binomial_smooth(formula = y ~ splines::ns(x, 2)) +
  facet_grid(elev.class2 ~ factor(year), scales = "free") +
  xlab("Day of year") +
  ylab("Proportional abundance") 
```
