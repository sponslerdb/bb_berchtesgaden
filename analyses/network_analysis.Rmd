---
title: "network_analysis"
output: html_document
---

### Prepare environment
```{r setup, include=FALSE}
library(bipartite)
library(mgcv)
library(mgcViz)
library(lavaan)
library(tidyverse)
library(lubridate)
```

### Define functions
#### Bootstrapped network analysis: *boot_net* function bootstraps networks by iteratively subsampling more frequently sampled networks to match the transect count of the least frequently sampled one
```{r, include=FALSE}
#####################################
######## species level ##############
#####################################
boot_net_sp <- function(net, n, iter) {
  
  out <- data.frame()
  
  t_filter <- net %>%
    dplyr::select(site, date, year) %>%
    unique() %>%
    group_by(site, year) %>%
    mutate(transects = n()) %>%
    filter(transects >= n)
  
  for(i in 1:iter) {
    temp <- net %>%
      semi_join(t_filter) %>%
      dplyr::select(site, date, year) %>%
      unique() %>%
      group_by(site, year) %>%
      sample_n(n) %>%
      left_join(net) %>%
      group_by(site, year, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
      summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
      unite(webID, c(site, year), sep = "_") %>%
      ungroup() %>%
      dplyr::select(higher = bb.sp, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
      data.frame() %>% # convert to data frame
      frame2webs() %>% # convert to to bipartite web
      map(specieslevel, level = "higher", index = "d") %>%
      map(rownames_to_column) %>%
      map(as_tibble) %>%
      bind_rows(.id = "site_year") %>% # Collapse list into big data frame
      rename(bb.sp = rowname) %>%
      mutate(iteration = rep(i, n()))
    
    out <- bind_rows(out, temp)
  } 
  out <- out %>%
    gather(metric, value, -c(bb.sp, site_year, iteration)) %>% # get mean value across iterations for each metric
    group_by(bb.sp, site_year, metric) %>%
    summarize(value = mean(value)) %>%
    separate(site_year, c("site", "year"), sep = "_") 
}

#####################################
######## network level ##############
#####################################
boot_net <- function(net, n, iter) {
  
  out <- data.frame()
  
  t_filter <- net %>%
    dplyr::select(site, date, year) %>%
    unique() %>%
    group_by(site, year) %>%
    mutate(transects = n()) %>%
    filter(transects >= n)
  
  for(i in 1:iter) {
    temp <- net %>%
      semi_join(t_filter) %>%
      dplyr::select(site, date, year) %>%
      unique() %>%
      group_by(site, year) %>%
      sample_n(n) %>%
      left_join(net) %>%
      group_by(site, year, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
      summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
      group_by(site, year) %>%
      unite(webID, c(site, year), sep = "_") %>%
      #filter(length(unique(bb.sp)) > 1 & length(unique(plant.sp)) > 1) %>%
      ungroup() %>%
      dplyr::select(higher = bb.sp, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
      data.frame() %>% # convert to data frame
      frame2webs() %>% # convert to to bipartite web
      map(networklevel, level = "higher", weighted = TRUE) %>% # We probably care mainly about the BB level of the network
      data.frame() %>%
      t() %>%
      data.frame() %>%
      rownames_to_column() %>%
      dplyr::select(site_year = rowname, everything()) %>%
      as_tibble() %>%
      mutate(iteration = rep(i, n()))
    
    out <- bind_rows(out, temp)
  } 
  out <- out  %>%
      gather(metric, value, -c(site_year, iteration)) %>% # get mean value across iterations for each metric
      group_by(site_year, metric) %>%
      summarize(value = mean(value)) %>%
      separate(site_year, c("site", "year"), sep = "_") 
}


##################################################
######## network level by site-date ##############
##################################################
site_date_net <- function(net, min_higher, min_lower) {
  
  size_filter <- net %>%
    group_by(site, date) %>%
    summarize(higher.species = length(unique(bb.sp)),
              lower.species = length(unique(plant.sp))) %>%
    filter(higher.species >= min_higher & lower.species >= min_lower)
  
  out <- net %>%
    semi_join(size_filter, by = c("site", "date")) %>%
    group_by(site, date, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
    summarize(freq = n()) %>% # calculate interaction frequency per species pair within each site
    unite(webID, c(site, date), sep = "_") %>%
    ungroup() %>%
    dplyr::select(higher = bb.sp, lower = plant.sp, webID, freq) %>% # rename columns to match bipartite's expectations
    data.frame() %>% # convert to data frame
    frame2webs() %>% # convert to to bipartite web
    map(networklevel, level = "higher", weighted = TRUE, 
        index = c("weighted NODF", "niche overlap", 
                  "C score", "generality", "web asymmetry", 
                  "weighted connectance")) %>% # We probably care mainly about the BB level of the network
    data.frame() %>%
    t() %>%
    data.frame() %>%
    rownames_to_column() %>%
    dplyr::select(site_date = rowname, everything()) %>%
    as_tibble() %>%
    separate(site_date, c("site", "date"), sep = "_")
}
```

### Load site data
```{r, include=FALSE}
site_data <- read_csv("../processed_data/site_data.csv") %>%
  dplyr::select(-c(slope.calc, slope.est, elev.min, elev.max, temp.mean)) %>% # drop these variables
  mutate(elev.class = factor(elev.class, levels = c("oben", "mitte", "unten")),
         elev.class2 = factor(elev.class2, levels = c("high", "mid", "low"))) # turn elav.class into an ordered factor
```

### Climate data
```{r, include=FALSE}
gdd <- read_csv("../processed_data/climate.csv") %>%
  mutate(year = factor(year)) %>%
  dplyr::select(site, date, gdd.cum)
```

### Load network and survey data
```{r, include=FALSE}
net <- read_csv("../processed_data/network.csv") %>%
  unite(site.year, site, year, sep = "_", remove = FALSE) %>% # create site.year field that can later be split back up
  mutate(year = factor(year)) %>% # convert year to factor
  left_join(site_data, by = "site") %>%
  left_join(gdd, by = c("site", "date")) %>%
  ungroup() %>%
  arrange(site, date)

# Yearly subsets
net_2012 <- filter(net, year == "2012")
net_2011 <- filter(net, year == "2011")
net_2010 <- filter(net, year == "2010")

# Floral survey
survey <- read_csv("../processed_data/floral_survey.csv") %>%
  semi_join(net, by = "plant.sp") %>% # Consider only plants visited (anytime anywhere, not specifically for a given site*date)
  dplyr::select(site, date, plant.sp, flower.cover)
```

### Rarefied network analysis (not broken down by phase)
#### Inspect transect counts to set subsampling parameter
```{r, include = FALSE}
### Determine the minimum transect count per site*year to set rarefaction sampling
transects <- net %>%
  dplyr::select(site, year, date) %>%
  unique() %>%
  group_by(site, year) %>%
  summarize(transects = n())

min_transects_per_year <- transects %>%
  group_by(year) %>%
  summarize(min_transects = min(transects))
```

### Tabulate metrics
```{r message=TRUE, warning=TRUE, include=FALSE}
### Auxiliary data
site_BB_aux <- net %>%
  group_by(site, year, date) %>%
  summarize(bb.rich = length(unique(bb.sp)),
            bb.abund = n()) %>%
  group_by(site, year) %>%
  summarize(bb.rich = mean(bb.rich),
            log.bb.abund = log(mean(bb.abund)),
            bb.transects = length(unique(date)))

site_BB_aux.sp <- net %>%
  group_by(site, date, bb.sp) %>% # group by bb.sp*transect (and other variables we want to retain)
  summarize(bb.abund = n()) %>% # get bb.sp*transect abundance
  ungroup %>%
  complete(site, date, bb.sp, fill = list(bb.abund = 0)) %>% # complete implicit absences
  semi_join(net, by = c("site", "date")) %>%
  mutate(year = factor(year(date))) %>%
  group_by(site, year, bb.sp) %>%
  summarize(bb.sp.abund = mean(bb.abund))

site_FL_aux <- survey %>%
  mutate(year = factor(year(date))) %>%
  filter(flower.cover > 0) %>%
  group_by(site, year, date) %>%
  summarize(fl.rich = length(unique(plant.sp)),
            fl.abund = sum(flower.cover)) %>%
  group_by(site, year) %>%
  summarize(fl.rich = mean(fl.rich),
            log.fl.abund = log(mean(fl.abund)),
            fl.transects = length(unique(date)))

# Network- and group-level metrics
netmet_boot_2012 <- boot_net(net_2012, n = 9, iter = 40) %>%
  mutate(year = factor(rep("2012", n())))
netmet_boot_2011 <- boot_net(net_2011, n = 4, iter = 40)  %>%
  mutate(year = factor(rep("2011", n())))
netmet_boot_2010 <- boot_net(net_2010, n = 3, iter = 40) %>%
  mutate(year = factor(rep("2010", n())))

### Species-level metrics 
spmet_2012 <- boot_net_sp(net_2012, 9, 40) %>%
  mutate(year = factor(rep("2012", n())))
spmet_2011 <- boot_net_sp(net_2011, 4, 40) %>%
  mutate(year = factor(rep("2011", n())))  
spmet_2010 <- boot_net_sp(net_2010, 3, 40) %>%
  mutate(year = factor(rep("2010", n())))

spmet <- bind_rows(spmet_2012, spmet_2011, spmet_2010) %>%
  left_join(site_BB_aux.sp) %>%
  inner_join(site_FL_aux) %>%
  spread(metric, value) %>%
  left_join(site_data) %>%
  ungroup() %>%
  mutate(bb.sp = factor(bb.sp),
         year = factor(year),
         site = factor(site),
         management = factor(management))

spmet_mean <- spmet %>%
  group_by(site, year) %>%
  summarize(d = weighted.mean(d, bb.sp.abund, na.rm = TRUE)) %>%
  ungroup() 

### Merge network metrics and auxiliary data
netmet <- bind_rows(netmet_boot_2012, 
                    netmet_boot_2011, 
                    netmet_boot_2010) %>%
  ungroup() %>%
  spread(metric, value) %>%
  left_join(spmet_mean, by = c("site", "year")) %>%
  left_join(site_BB_aux, by = c("site", "year")) %>%
  inner_join(site_FL_aux, by = c("site", "year")) %>% # one site-year is missing from floral survey data
  left_join(site_data, by = "site") %>%
  mutate(year = factor(year),
         site = factor(site),
         management = factor(management))
```

# Let's inspect correlations within our predictors
```{r}
library(GGally)

predictors <- netmet %>%
  select(elev.mean, bb.rich, log.bb.abund, fl.rich, log.fl.abund)

ggpairs(predictors)
```

### Maybe the answer is not to abandon network analysis, but to include all the variables that confound my target relationship with elevation in a big model, then use variable selection to see what *does* predict network structure. I have massive concurvity, of course, so if the select() feature doesn't deal with that, I might need to opt for a model selection approach. 

A source of embuggerance that I have not yet dealt with is that when I bootstrap to equalize transects count, I do not do anything to equalize the temporal (either yday or GDD) interval spanned by the randomly drawn transects. This will, of course, average out as I increase iterations, so I guess the real problem is that the time interval spanned by the full set of transects for each site varies, so no matter how much bootstrapping I do, there will still be potential bias. This seems a fairly insurmountable limitation of the sampling structure of my data, so I will probably resort to just acknowledging it as a caveat of my analysis. 
```{r}
#### Network level
##### niche overlap
gam_niche.overlap <- gam(niche.overlap.HL ~ year + 
                           s(site, bs = "re") +
                           #management + # no effect
                           s(elev.mean, k = 5) +
                           #s(bb.rich, k = 5) + # too collinear with bb.abund
                           s(fl.rich, k = 5) +
                           #s(log.fl.abund, k = 5) + # no effect
                           s(log.bb.abund, k = 5),
                          select = TRUE,
                          data = netmet,
                          method = "REML") %>% getViz()

ggplot(netmet, aes(elev.mean, niche.overlap.HL)) +
  geom_point() +
  theme_modern()

check.gamViz(gam_niche.overlap)
concurvity(gam_niche.overlap, full = TRUE)
concurvity(gam_niche.overlap, full = FALSE)
summary(gam_niche.overlap)
print(plot(gam_niche.overlap, allTerms = TRUE), pages = 1)
ggpredict(gam_niche.overlap)
check_model(gam_niche.overlap)

##### C.score
gam_c.score <- gam(C.score.HL ~ year +
                     s(site, bs = "re") +
                     management +
                     s(elev.mean, k = 5) +
                     s(bb.rich, k = 5) +
                     s(fl.rich, k = 5) +
                     s(log.fl.abund, k = 5) +
                     s(log.bb.abund, k = 5),
                   select = TRUE,
                   data = netmet,
                   method = "REML") %>% getViz()

check.gamViz(gam_c.score)
concurvity(gam_c.score, full = TRUE)
concurvity(gam_c.score, full = FALSE)
summary(gam_c.score)
print(plot(gam_c.score, allTerms = TRUE), pages = 1)

##### weighted NODF: the main takeaway here is that higher BB abundance = higher nestedness, and that could easily be a sampling effect more than an ecologicla effect. Nevertheless, there remains a significant linear partial effect of elevation. It is worth noting that where elevation has an effect on network structure, it is linear after accounting for the influence of other variables.
gam_weighted.NODF <- gam(weighted.NODF ~ year + 
                           s(site, bs = "re") +
                           #management +
                           s(elev.mean, k = 5) +
                           #s(bb.rich, k = 5) +
                           s(fl.rich, k = 5) +
                           #s(log.fl.abund, k = 5) +
                           s(log.bb.abund, k = 5),
                          select = TRUE,
                          data = netmet,
                          method = "REML") %>% getViz()

check.gamViz(gam_weighted.NODF)
concurvity(gam_weighted.NODF, full = TRUE)
concurvity(gam_weighted.NODF, full = FALSE)
summary(gam_weighted.NODF)
print(plot(gam_weighted.NODF, allTerms = TRUE), pages = 1)
ggpredict(gam_weighted.NODF)
check_model(gam_weighted.NODF)

##### togetherness
gam_togetherness <- gam(togetherness.HL ~ year + 
                           s(site, bs = "re") +
                           #management +
                           s(elev.mean, k = 5) +
                           s(bb.rich, k = 5) +
                           #s(log.fl.abund, k = 5) +
                           #s(log.bb.abund, k = 5) +
                           s(fl.rich, k = 5),
                          select = TRUE,
                          data = netmet,
                          method = "REML") %>% getViz()

check.gamViz(gam_togetherness)
concurvity(gam_togetherness, full = TRUE)
concurvity(gam_togetherness, full = FALSE)
summary(gam_togetherness)
print(plot(gam_togetherness, allTerms = TRUE), pages = 1)
ggpredict(gam_togetherness)
check_model(gam_togetherness)

##### generality; this could be an interesting alternative to something like d', but I'm not sure whether it deals with the confunding effects of abundance -- singletons, in extreme cases.
gam_generality <- gam(generality.HL ~ year + 
                           s(site, bs = "re") +
                           management +
                           s(elev.mean, k = 5) +
                           s(bb.rich, k = 5) +
                           s(fl.rich, k = 5) +
                           s(log.fl.abund, k = 5) +
                           s(log.bb.abund, k = 5),
                          select = TRUE,
                          data = netmet,
                          method = "REML") %>% getViz()

check.gamViz(gam_generality)
concurvity(gam_generality, full = TRUE)
concurvity(gam_generality, full = FALSE)
summary(gam_generality)
print(plot(gam_generality, allTerms = TRUE), pages = 1)
ggpredict(gam_generality)
check_model(gam_generality)

##### community mean d'
gam_mean_d <- gam(d ~ year + 
                           s(site, bs = "re") +
                           #management +
                           #s(elev.mean, k = 5) +
                           #s(bb.rich, k = 5) +
                           #s(log.fl.abund, k = 5) +
                           #s(fl.rich, k = 5) +
                           s(log.bb.abund, k = 5),
                          select = TRUE,
                          data = netmet,
                          method = "REML") %>% getViz()

check.gamViz(gam_mean_d)
concurvity(gam_mean_d, full = TRUE)
concurvity(gam_mean_d, full = FALSE)
summary(gam_mean_d)
print(plot(gam_mean_d, allTerms = TRUE), pages = 1)
ggpredict(gam_mean_d)
check_model(gam_mean_d)

ggplot(netmet, aes(log.bb.abund, d, color = year)) +
  geom_point() +
  geom_smooth(method = "lm") +
  theme_abyss()

ggplot(netmet, aes(elev.mean, d, color = year)) +
  geom_point() +
  geom_smooth() +
  theme_abyss()
```

### Since we clearly have structured collinearity in our preditors, i.e. elevation shapes abundance and diversity which shape network structure, perhaps SEM could be appropriate? The main question is whether it can handle the potentially complex (nonlinear) relationships between elevation and diversity/abundance, and whether it can handle the hierarchical structure of my data.
```{r}
library(piecewiseSEM)

netmet.scaled <- netmet %>%
  select(site, year, niche.overlap.HL, elev.mean, fl.rich, bb.rich, log.fl.abund, log.bb.abund) %>%
  mutate(niche.overlap.HL = scale(niche.overlap.HL),
         elev.mean = scale(elev.mean),
         fl.rich = scale(fl.rich),
         log.fl.abund = scale(log.fl.abund),
         log.bb.abund = scale(log.bb.abund)) %>%
  as.matrix() %>%
  as_tibble() %>%
  mutate(niche.overlap.HL = as.numeric(niche.overlap.HL),
         elev.mean = as.numeric(elev.mean),
         fl.rich = as.numeric(fl.rich),
         log.fl.abund = as.numeric(log.fl.abund),
         log.bb.abund = as.numeric(log.bb.abund),
         site = factor(site),
         year = factor(year)) %>%
  na.omit()
  
mod_niche.overlap <- psem(lmer(niche.overlap.HL ~ elev.mean + 
                                fl.rich + log.bb.abund + 
                                 (1 | year) + (1 | site), 
                              netmet.scaled),
                          lm(fl.rich ~ elev.mean, 
                             netmet.scaled),
                          lm(log.bb.abund ~ elev.mean, 
                             netmet.scaled))
summary(mod_niche.overlap)
plot(mod_niche.overlap)
```

### But let's zoom in a bit closer on d' and see if we can model it per-species
```{r}
gam_d.sp_GI <- gam(d ~ year + 
                     s(site, bs = "re") +
                     management +
                     s(bb.sp, bs = "re") +
                     s(elev.mean, bs = "tp", k = 8) +
                     s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                     s(fl.rich, k = 8) +
                     s(log.fl.abund, k = 8) +
                     s(log.bb.sp.abund, k = 5),
                   select = TRUE,
                   data = spmet,
                   method = "REML") %>% getViz()

check.gamViz(gam_d.sp_GI)
concurvity(gam_d.sp_GI, full = TRUE)
concurvity(gam_d.sp_GI, full = FALSE)
summary(gam_d.sp_GI)
print(plot(gam_d.sp_GI, allTerms = TRUE), pages = 4)

gam_d.sp_G <- gam(d ~ year + 
                    s(site, bs = "re") +
                    management +
                    s(bb.sp, bs = "re") +
                    s(elev.mean, bs = "tp", k = 8) +
                    s(fl.rich, k = 8) +
                    s(log.fl.abund, k = 8) +
                    s(log.bb.sp.abund, k = 5),
                  select = TRUE,
                  data = spmet,
                  method = "REML") %>% getViz()

check.gamViz(gam_d.sp_G)
concurvity(gam_d.sp_G, full = TRUE)
concurvity(gam_d.sp_G, full = FALSE)
summary(gam_d.sp_G)
print(plot(gam_d.sp_G, allTerms = TRUE), pages = 1)
check_model(gam_d.sp_G)
modelG_elev.mean <- ggpredict(gam_d.sp_G, terms = "elev.mean")
plot(modelG_elev.mean)

# This simpler varying-smooth model explains just as much variance as the more complex GI model, so it should be preferred. 
gam_d.sp_GS <- gam(d ~ year + 
                     management +
                     s(site, bs = "re") +
                     s(elev.mean, bs = "tp", k = 8) +
                     s(elev.mean, bb.sp, bs = "fs", k = 8) +
                     s(log.fl.abund, k = 8) +
                     s(fl.rich, k = 8) +
                     s(log.bb.sp.abund, k = 5),
                   select = TRUE,
                   data = spmet,
                   method = "REML") %>% getViz()

check.gamViz(gam_d.sp_GS)
concurvity(gam_d.sp_GS, full = TRUE)
concurvity(gam_d.sp_GS, full = FALSE)
summary(gam_d.sp_GS)
print(plot(gam_d.sp_GS, allTerms = TRUE), pages = 1)
check_model(gam_d.sp_GS)
plot(ggpredict(gam_d.sp_GS))

# What about I? Does it do any better than S?
gam_d.sp_I <- gam(d ~ year + 
                     s(site, bs = "re") +
                     management +
                     s(bb.sp, bs = "re") +
                     s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                     s(fl.rich, k = 8) +
                     s(log.fl.abund, k = 8) +
                     s(log.bb.sp.abund, k = 5),
                   select = TRUE,
                   data = spmet,
                   method = "REML") %>% getViz()

check.gamViz(gam_d.sp_I)
concurvity(gam_d.sp_I, full = TRUE)
concurvity(gam_d.sp_I, full = FALSE)
summary(gam_d.sp_I)
print(plot(gam_d.sp_I, allTerms = TRUE), pages = 4)

AIC(gam_d.sp_I, gam_d.sp_S, gam_d.sp_G, gam_d.sp_GI, gam_d.sp_GS)

ggplot(spmet, aes(log.bb.sp.abund)) +
  geom_histogram() +
  theme_modern()

ggplot(spmet, aes(log.bb.sp.abund)) +
  geom_histogram() +
  theme_blackboard()

ggplot(spmet, aes(elev.mean, d)) +
  geom_point(aes(color = bb.sp)) +
  geom_smooth() +
  theme_blackboard() +
  facet_wrap(~year)

# We lose virtually no explanatory power in going from GI, to GS, to S. So, S is the preferred model right now.
gam_d.sp_S <- gam(d ~ year + 
                    s(site, bs = "re") +
                    management +
                    s(elev.mean, bb.sp, bs = "fs", k = 8) +
                    s(fl.rich, k = 8) +
                    s(log.fl.abund, k = 8) +
                    s(log.bb.sp.abund, k = 5),
                  select = TRUE,
                  data = spmet,
                  method = "REML") %>% getViz()

check.gamViz(gam_d.sp_S)
concurvity(gam_d.sp_S, full = TRUE)
concurvity(gam_d.sp_S, full = FALSE)
summary(gam_d.sp_S)
print(plot(gam_d.sp_S, allTerms = TRUE), pages = 1)


###  There remains a lot of noise in my multi-year models above, and a possible explanation for that is that the influence of year extends beyond just variation in the intercept. What if year affects the shape of Y ~ X? In these year subset models, I can drop both 'year' and 's(site, bs = "re")'.

gam_d.sp_GI.2010 <- gam(d ~ management +
                          s(bb.sp, bs = "re") +
                          s(elev.mean, bs = "tp", k = 8) +
                          s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                          s(fl.rich, k = 8) +
                          s(log.fl.abund, k = 8) +
                          s(log.bb.sp.abund, k = 5),
                        select = TRUE,
                        data = filter(spmet, year == 2010),
                        method = "REML") %>% getViz()

check.gamViz(gam_d.sp_GI.2010)
concurvity(gam_d.sp_GI.2010, full = TRUE)
concurvity(gam_d.sp_GI.2010, full = FALSE)
summary(gam_d.sp_GI.2010)
print(plot(gam_d.sp_GI.2010, allTerms = TRUE), pages = 4)

gam_d.sp_GI.2011 <- gam(d ~ management +
                          s(bb.sp, bs = "re") +
                          s(elev.mean, bs = "tp", k = 8) +
                          s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                          s(fl.rich, k = 8) +
                          s(log.fl.abund, k = 8) +
                          s(log.bb.sp.abund, k = 5),
                        select = TRUE,
                        data = filter(spmet, year == 2011),
                        method = "REML") %>% getViz()

check.gamViz(gam_d.sp_GI.2011)
concurvity(gam_d.sp_GI.2011, full = TRUE)
concurvity(gam_d.sp_GI.2011, full = FALSE)
summary(gam_d.sp_GI.2011)
print(plot(gam_d.sp_GI.2011, allTerms = TRUE), pages = 4)

gam_d.sp_GI.2012 <- gam(d ~ management +
                          s(bb.sp, bs = "re") +
                          s(elev.mean, bs = "tp", k = 8) +
                          s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                          s(fl.rich, k = 8) +
                          s(log.fl.abund, k = 8) +
                          s(log.bb.sp.abund, k = 5),
                        select = TRUE,
                        data = filter(spmet, year == 2012),
                        method = "REML") %>% getViz()

check.gamViz(gam_d.sp_GI.2012)
concurvity(gam_d.sp_GI.2012, full = TRUE)
concurvity(gam_d.sp_GI.2012, full = FALSE)
summary(gam_d.sp_GI.2012)
print(plot(gam_d.sp_GI.2012, allTerms = TRUE), pages = 4)

### I-form models
gam_d.sp_I.2010 <- gam(d ~ management +
                          s(bb.sp, bs = "re") +
                          s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                          s(fl.rich, k = 8) +
                          s(log.fl.abund, k = 8) +
                          s(log.bb.sp.abund, k = 5),
                        select = TRUE,
                        data = filter(spmet, year == 2010),
                        method = "REML") %>% getViz()

check.gamViz(gam_d.sp_I.2010)
concurvity(gam_d.sp_I.2010, full = TRUE)
concurvity(gam_d.sp_I.2010, full = FALSE)
summary(gam_d.sp_I.2010)
print(plot(gam_d.sp_I.2010, allTerms = TRUE), pages = 4)

gam_d.sp_I.2011 <- gam(d ~ management +
                          s(bb.sp, bs = "re") +
                          s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                          s(fl.rich, k = 8) +
                          s(log.fl.abund, k = 8) +
                          s(log.bb.sp.abund, k = 5),
                        select = TRUE,
                        data = filter(spmet, year == 2011),
                        method = "REML") %>% getViz()

check.gamViz(gam_d.sp_I.2011)
concurvity(gam_d.sp_I.2011, full = TRUE)
concurvity(gam_d.sp_I.2011, full = FALSE)
summary(gam_d.sp_I.2011)
print(plot(gam_d.sp_I.2011, allTerms = TRUE), pages = 4)

gam_d.sp_I.2012 <- gam(d ~ management +
                          s(bb.sp, bs = "re") +
                          s(elev.mean, by = bb.sp, bs = "tp", k = 8) +
                          s(fl.rich, k = 8) +
                          s(log.fl.abund, k = 8) +
                          s(log.bb.sp.abund, k = 5),
                        select = TRUE,
                        data = filter(spmet, year == 2012),
                        method = "REML") %>% getViz()

check.gamViz(gam_d.sp_I.2012)
concurvity(gam_d.sp_I.2012, full = TRUE)
concurvity(gam_d.sp_I.2012, full = FALSE)
summary(gam_d.sp_I.2012)
print(plot(gam_d.sp_I.2012, allTerms = TRUE), pages = 4)
```

### Does tongue-length / corolla depth matching vary with elevation?
```{r}
bb_traits <- read_csv("../processed_data/bb_traits.csv") %>%
  dplyr::select(subgenus, bb.sp, pbl.w, pbl.w.class)

fl_ktype <- read.csv("../processed_data/floral_k_type_nom_fix.csv") %>%
  dplyr::select(plant.sp, k.type) %>%
  mutate(k.type.s = str_extract(k.type, "[-+]?[0-9]*\\.?[0-9]+"),
         k.type.ss = str_extract(k.type, "[-+]?[0-9]*"))

fl_morph <- read.csv("../processed_data/flower_morphology_GitaBenadi.csv") %>%
  rename(plant.sp = Species) %>%
  group_by(plant.sp) %>%
  summarize(corolla.depth = mean(LN))

fl_tax <- read_csv("../processed_data/floral_tax.csv")

net_traits <- net %>%
  # group_by(site, year, bb.sp, plant.sp) %>% # group by site, date, bee species, plant species
  # summarize(freq = n()) %>%
  # ungroup() %>%
  left_join(bb_traits) %>%
  left_join(fl_ktype) %>%
  left_join(fl_morph) %>%
  separate(plant.sp, c("plant.genus", "plant.species"), sep = " ", remove = FALSE) %>%
  left_join(fl_tax) %>%
  mutate(tongue.mismatch = abs(pbl.w - corolla.depth),
         bb.sp = factor(bb.sp),
         plant.sp = factor(plant.sp),
         plant.genus = factor(plant.genus),
         subgenus = factor(subgenus),
         k.type.s = factor(k.type.s),
         plant.family = factor(plant.family))

ggplot(net_traits, aes(elev.mean, tongue.mismatch)) +
  geom_point(color = "yellow") +
  geom_smooth(method = "lm") +
  facet_wrap(~bb.sp) +
  theme_abyss()
```


