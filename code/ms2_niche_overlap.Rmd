---
title: "visitation_bias"
author: "Doug Sponsler"
date: "12/14/2020"
output: html_document
---
# Preparations
## Packages 
```{r, warning=FALSE, include=FALSE, echo = FALSE}
library(bipartite)
library(mgcv)
library(mgcViz)
library(modelr)
library(vegan)
library(ggvegan)
library(ggrepel)
library(tidymv)
library(patchwork)
library(tidymodels)
library(tidyverse)
library(lubridate)
```

## Load data
```{r message=FALSE, warning=FALSE, include=FALSE, echo = FALSE}
# Site data
site_data <- read_csv("../data/processed_data/site_data.csv") %>%
  dplyr::select(-c(slope.calc, slope.est, elev.min, elev.max, temp.mean)) %>% # drop these variables
  mutate(elev.class2 = factor(elev.class2, levels = c("low", "mid", "high")),
         site = factor(site)) # turn elav.class into an ordered factor and site into a regular factor

# BB traits
bb_traits <- read_csv("../data/processed_data/bb_traits.csv") 

# FL traits
fl_traits <- read_csv("../data/processed_data/fl_traits.csv")

# Visitation data
visitation <- read_csv("../data/processed_data/visitation.csv")
visit_cover <- read_csv("../data/processed_data/visitation.csv")
```

# 2. Ordination of dietary niche
Aggregation changes meaning. Don't forget that. When I pool visitation across dates, I am introducing the effects of relative abundance and floral phenology. Species in bloom when BB abundance is high will be over-represented, and vice-versa. And species with a long bloom time will be over-represented, and vice-versa. This isn't necessarily a problem. I just need to make sure I interpret the results the right way. When I pool data like this, I am comparing the "net" diet of species, which includes the effects of abundance and phenology in addition to the effects of floral preferences. I think that is appropriate for this stage of the analysis, but I need to be careful not to assume that what I'm doing here is the same sort of analysis as what I did above without pooling samples. 
```{r}
# Fl traits with abbreviated names
fl_traits2 <- fl_traits %>%
  left_join(read_csv("../data/processed_data/network.csv")) %>%
  #select(plant.sp, plant.sp.abb, plant.genus, plant.family, k.type.ss, color) %>%
  select(plant.genus, k.type.ss) %>%
  mutate(k.type.ss = factor(k.type.ss)) %>%
  distinct() 

# Totally aggregated; note I'm using the full data, not the aligned and trimmed data. No need for complementary floral survey data.
visitation2 <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  filter(!bb.sp %in% c("humi")) %>% # humi is too rare
  #group_by(bb.sp, plant.sp.abb) %>%
  group_by(bb.sp, plant.genus) %>%
  summarize(visits = n()) %>%
  group_by(bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  select(-visits) %>%
  #pivot_wider(names_from = plant.sp.abb, values_from = prop.visits, values_fill = 0) %>%
  pivot_wider(names_from = plant.genus, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

bb_traits2 <- bb_traits %>%
  filter(!bb.sp %in% c("humi")) %>% # drop humi
  select(bb.sp, pbl.w.class2) %>%
  arrange(bb.sp) %>%
  mutate(pbl.w.class2.pool = case_when(
    pbl.w.class2 == "short" ~ "short",
    pbl.w.class2 == "med" ~ "med/long",
    pbl.w.class2 == "long" ~ "med/long"
  ))

# Generate ordination
pcoa_horn2 <- capscale(visitation2 ~ 1, distance = "horn")
pcoa_horn2_adonis <- adonis(visitation2 ~ pbl.w.class2, data = bb_traits2)
pcoa_horn2_betadisper <- betadisper(vegdist(visitation2, method = "horn"), 
                                    group = bb_traits2$pbl.w.class2,
                                    type = "median")
anova(pcoa_horn2_betadisper) # I think this is not significant because short tongued species are disperse on axis 2, but axis 2 does not explain nearly as much variation.
plot(pcoa_horn2_betadisper)
# I'm surprised that the betadisper test is not significant, but I think it might be driven by the fact that replication is so low for long and medium tongue species. Let's see what happens if we pool long and medium tongue species, since they overlap so much anyway.
pcoa_horn2_betadisper_pool <- betadisper(vegdist(visitation2, method = "horn"), 
                                    group = bb_traits2$pbl.w.class2.pool,
                                    type = "median")
anova(pcoa_horn2_betadisper_pool) # I think this is not significant because short tongued species are dispersed on axis 2, but axis 2 does not explain nearly as much variation.
plot(pcoa_horn2_betadisper_pool)

# Get variance explained
pcoa_horn2_mds1 <- round(pcoa_horn2$CA$eig[[1]] / sum(pcoa_horn2$CA$eig)*100)
pcoa_horn2_mds2 <- round(pcoa_horn2$CA$eig[[2]] / sum(pcoa_horn2$CA$eig)*100)

# Fortify plants
pcoa_horn2.fort1 <- fortify(pcoa_horn2, axes = 1:2) %>%
  filter(Score == "species") %>%
  #rename(plant.sp.abb = Label) %>%
  rename(plant.genus = Label) %>%
  left_join(fl_traits2)

# Fortify bees
pcoa_horn2.fort2 <- fortify(pcoa_horn2, axes = 1:2) %>%
  filter(Score == "sites") %>%
  rename(bb.sp = Label) %>%
  left_join(bb_traits) %>%
  mutate(pbl.w.class2 = factor(pbl.w.class2)) 

# Generate convex hulls around tongue length classes
pcoa_horn2_hulls <- pcoa_horn2.fort2 %>%
  group_by(pbl.w.class2) %>%
  slice(chull(MDS1, MDS2))
  
# Plot
ggplot(pcoa_horn2.fort2, aes(MDS1, MDS2, color = pbl.w.class2)) +
  geom_polygon(data = pcoa_horn2_hulls, 
               aes(fill = pbl.w.class2, color = NULL),
               alpha = 0.25) +
  geom_point(data = filter(pcoa_horn2.fort1, abs(MDS1) >= 0.20 | abs(MDS2) >= 0.20),
            aes(MDS1, MDS2, shape = k.type.ss), inherit.aes = FALSE, color = "gray40", size = 2) +
  geom_text(aes(label = bb.sp), key_glyph = "rect", size = 3) +
  geom_text_repel(data = filter(pcoa_horn2.fort1, abs(MDS1) >= 0.20 | abs(MDS2) >= 0.20), 
            aes(MDS1, MDS2, label = plant.genus), inherit.aes = FALSE, color = "gray40",
            size = 3) +
  scale_shape_discrete() +
  xlab(paste("MDS1 ", "(", pcoa_horn2_mds1, "%", ")", sep = "")) +
  ylab(paste("MDS2 ", "(", pcoa_horn2_mds2, "%", ")", sep = "")) +
  labs(fill = "Tongue length", 
       shape = "Morphotype") +
  guides(color = FALSE) +
  coord_fixed() +
  theme_light(9)

ggsave("../output/pcoa_aggregate.png")
ggsave("../output/pcoa_aggregate.pdf")

```

# 3. Dietary niche overlap (i.e. potential competition)

## 3.1 Check BB distribution patterns to decide whom to retain in the analysis
```{r}
bb_distribution <- visitation %>%
  mutate(year = year(date)) %>%
  left_join(site_data) %>%
  group_by(site, date, elev.mean, bb.sp, year) %>%
  summarize(abund = n()) %>%
  group_by(site, elev.mean, bb.sp, year) %>%
  summarize(abund = mean(abund)) %>%
  group_by(bb.sp) %>%
  mutate(elev.floor = min(elev.mean),
         elev.ceiling = max(elev.mean),
         elev.range = elev.ceiling - elev.floor,
         elev.med = elev.floor + ((elev.ceiling - elev.floor)/2))

ggplot(bb_distribution, aes(reorder(bb.sp, elev.med), elev.mean)) +
  geom_line(size = 2, alpha = 0.25) +
  geom_point(aes(size = abund), alpha = 0.5) +
  facet_wrap(~year, ncol = 1) +
  theme_light(12) +
  scale_size_continuous(name = "Abundance") +
  xlab("BB species") +
  ylab("Elevation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

bb_distribution_pool <- visitation %>%
  left_join(site_data) %>%
  group_by(site, date, elev.mean, bb.sp) %>%
  summarize(abund = n()) %>%
  ungroup() %>%
  complete(site, date, elev.mean, bb.sp, fill = list(abund = 0)) %>%
  group_by(site, elev.mean, bb.sp) %>%
  summarize(abund = mean(abund)) %>%
  filter(abund > 0) %>%
  group_by(bb.sp) %>%
  mutate(elev.floor = min(elev.mean),
         elev.ceiling = max(elev.mean),
         elev.range = elev.ceiling - elev.floor,
         elev.med = elev.floor + ((elev.ceiling - elev.floor)/2))

ggplot(bb_distribution_pool, aes(reorder(bb.sp, elev.med), elev.mean)) +
  geom_line(size = 2, alpha = 0.25) +
  geom_point(aes(size = abund), alpha = 0.5) +
  theme_light(14) +
  scale_size_continuous(name = "Abundance") +
  xlab("BB species") +
  ylab("Elevation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

ggsave("../output/bb_range_ms2.pdf", width = 6, height = 5)
```

## 3.2 Prep data for calculating niche overlap
```{r}
niche_data <- visitation %>%
  left_join(fl_traits) %>%
  mutate(year = factor(year(date)))
```

## 3.3 Function for calculating niche overlap
```{r}
# This one averages visitation and then calculates niche overlaps using 1 - Horn-Morisita distance
niche_overlapper <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  x %>%
    group_by(bb.sp, !!criterion, site, date) %>% # group by site-year and BB-FL pair
    summarize(freq = sum(visits)) %>% # get interaction frequency for each BB-FL pair per site-year
    group_by(bb.sp, site, date) %>% # group by site-year and BB species
    mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair
    group_by(bb.sp, site, !!criterion) %>%
    summarize(mean.prop = mean(prop)) %>%
    pivot_wider(names_from = !!criterion, values_from = mean.prop, values_fill = 0) %>% # spread into the kind of array vegan likes
    group_by(site) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    dplyr::select(site, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>% # unnest back into a single data frame
    left_join(site_data) %>% # add site data
    dplyr::select(site, bb.sp1 = item1, bb.sp2 = item2, distance, elev.mean, management) %>% # dplyr::select and rename vars
    left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>% # add traits for bb.sp1
    rename(subgenus1 = subgenus, tongue1 = pbl.w) %>%
    left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>% # add traits for bb.sp2
    rename(subgenus2 = subgenus, tongue2 = pbl.w) %>%
    dplyr::select(site, bb.sp1, bb.sp2, subgenus1, subgenus2, distance, 
       tongue1, tongue2, elev.mean, management) %>%
    mutate(tongue.diff = abs(tongue1 - tongue2),
           subgenus.diff = if_else(subgenus1 == subgenus2, "same", "different")) %>%
    unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":", remove = FALSE) %>% # create a single species pair column...
    mutate(sp.pair = factor(sp.pair)) %>% # ...and make it a factor so that mgcv can handle it
    mutate(niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
    select(-distance)
}


# This one calculates niche overlap on fully resolved visitation data and then averages niche overlap across dates
# niche_overlapper2 <- function(x, criterion) {
#     
#   criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
#   
#   x %>%
#     #group_by(bb.sp, !!criterion, site, date, year) %>% # group by site-year and BB-FL pair
#     group_by(bb.sp, !!criterion, site, date) %>% # group by site-year and BB-FL pair
#     summarize(freq = sum(visits)) %>% # get interaction frequency for each BB-FL pair per site-year
#     group_by(bb.sp, site, date) %>% # group by site-year and BB species
#     mutate(prop = freq/sum(freq)) %>% # get proportional interaction frequency for each BB-FL pair
#     #group_by(bb.sp, site, year, !!criterion) %>%
#     # group_by(bb.sp, site, !!criterion) %>%
#     # summarize(mean.prop = mean(prop)) %>%
#     unite(sitedate, c(site, date), sep = "_") %>%
#     #pivot_wider(names_from = !!criterion, values_from = mean.prop, values_fill = 0) %>% # spread into the kind of array vegan likes
#     #pivot_wider(names_from = !!criterion, values_from = prop, values_fill = 0) %>% # spread into the kind of array vegan likes
#     #group_by(site, year) %>%
#     #group_by(site) %>%
#     select(-freq) %>%
#     group_by(sitedate) %>%
#     nest() %>% # nest into list-column
#     mutate(data2 = map(data, function(x) pivot_wider(x, names_from = !!criterion, values_from = prop, values_fill = 0)),
#            data3 = map(data2, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
#            dist = map(data3, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
#            tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
#     #dplyr::select(site, year, tidy_dist) %>% # drop intermediate list-columns
#     #dplyr::select(site, tidy_dist) %>% # drop intermediate list-columns
#     dplyr::select(sitedate, tidy_dist) %>% # drop intermediate list-columns
#     unnest(cols = c(tidy_dist)) %>% # unnest back into a single data frame
#     separate(sitedate, c("site", "date"), sep = "_") %>%
#     left_join(site_data) %>% # add site data
#     # dplyr::select(site, year, bb.sp1 = item1, bb.sp2 = item2, distance, elev.mean) %>% # dplyr::select and rename vars
#     dplyr::select(site, date, bb.sp1 = item1, bb.sp2 = item2, distance, elev.mean) %>% # dplyr::select and rename vars
#     left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>% # add traits for bb.sp1
#     rename(subgenus1 = subgenus, tongue1 = pbl.w.class2) %>%
#     left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>% # add traits for bb.sp2
#     rename(subgenus2 = subgenus, tongue2 = pbl.w.class2) %>%
#     # dplyr::select(site, year, bb.sp1, bb.sp2, subgenus1, subgenus2, distance, 
#     #        tongue1, tongue2, elev.mean) %>%
#     dplyr::select(site, date, bb.sp1, bb.sp2, subgenus1, subgenus2, distance, 
#        tongue1, tongue2, elev.mean) %>%
#     mutate(tongue.diff = factor(if_else(tongue1 == tongue2, "same", "different")),
#            tongue.pair = factor(case_when(
#              tongue1 == "med" & tongue2 == "med" ~ "med:med",
#              tongue1 == "med" & tongue2 == "long" ~ "med:long",
#              tongue1 == "med" & tongue2 == "short" ~ "short:med",
#              tongue1 == "long" & tongue2 == "med" ~ "med:long",
#              tongue1 == "short" & tongue2 == "med" ~ "short:med",
#              tongue1 == "long" & tongue2 == "short" ~ "short:long",
#              tongue1 == "short" & tongue2 == "long" ~ "short:long",
#              tongue1 == "long" & tongue2 == "long" ~ "long:long",
#              tongue1 == "short" & tongue2 == "short" ~ "short:short",
#            )),
#            subgenus.diff = if_else(subgenus1 == subgenus2, "same", "different")) %>%
#     unite(sp.pair, c(bb.sp1, bb.sp2), sep = ":", remove = FALSE) %>% # create a single species pair column...
#     mutate(sp.pair = factor(sp.pair)) %>% # ...and make it a factor so that mgcv can handle it
#     mutate(niche.overlap = 1-distance) %>% # express niche overlap so that 1 = perfect overlap and 0 = no overlap
#     select(-distance)
# }
```

## 3.4 Calculate niche overlap pooled within site
```{r}
# Pooled across dates within level, site, and species pair
niche_overlap_gen <- niche_overlapper(niche_data, plant.genus) %>%
  mutate(level = rep("genus", n()))

niche_overlap_fam <- niche_overlapper(niche_data, plant.family) %>%
  mutate(level = rep("family", n()))

niche_overlap_ktype <- niche_overlapper(niche_data, k.type.ss) %>%
  mutate(level = rep("morphotype", n()))


ggplot(niche_overlap_gen, aes(tongue.diff, niche.overlap)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~site)

ggplot(niche_overlap_fam, aes(tongue.diff, niche.overlap)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~site)

ggplot(niche_overlap_ktype, aes(tongue.diff, niche.overlap)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~site)

# Collate across levels
niche_overlap <- bind_rows(niche_overlap_gen,
                           niche_overlap_fam, 
                           niche_overlap_ktype) %>%
  mutate(level = factor(level, levels = c("family", "morphotype", "genus")),
         site = factor(site),
         management = factor(management, levels = c("none", "grasing", "mowing"))) %>%
  separate(sp.pair, c("sp1", "sp2"), sep = ":", remove = FALSE) 

write_csv(niche_overlap, "../output/niche_overlap.csv")

# Pool across species pairs within level and site to get community mean niche overlap
niche_overlap_levels <- niche_overlap %>%
  group_by(site, level, elev.mean, management) %>%
  summarize(mean.niche.overlap = mean(niche.overlap)) %>%
  mutate(level = factor(level, levels = c("family", "morphotype", "genus")))  # ordering them this way will make family the reference level, which is handy since I don't really care about it.

# Isolate genus-level, then pool within sp.pair and site
niche_overlap_sppair <-  niche_overlap %>%
  group_by(site, sp.pair, level, elev.mean, management) %>%
  summarize(mean.niche.overlap = mean(niche.overlap)) %>%
  mutate(level = factor(level, levels = c("family", "morphotype", "genus"))) %>%
  filter(level == "genus") %>%
  separate(sp.pair, c("sp1", "sp2"), sep = ":", remove = FALSE)

# Isolate genus-level, then pool within tongue.pair and site
niche_overlap_tongues <- niche_overlap %>%
  group_by(site, level, tongue.pair, elev.mean, management) %>%
  summarize(mean.niche.overlap = mean(niche.overlap)) %>%
  filter(level == "genus") %>%
  mutate(tongue.pair = factor(tongue.pair, levels = c("short:long", "short:med", "short:short",
                                                      "med:long", "med:med", "long:long")))

# Isolate genus-level, then pool within tongue.diff and site
niche_overlap_tonguediff <- niche_overlap %>%
  group_by(site, level, tongue.diff, elev.mean, management) %>%
  summarize(mean.niche.overlap = mean(niche.overlap)) %>%
  filter(level == "genus")

#################

ggplot(niche_overlap_sppair, aes(management, mean.niche.overlap)) +
  geom_boxplot()
```

## 3.5 Niche overlap ~ level + elevation
### 3.5.1 Model
```{r}
# Beta regression is probably the right way to do this; a gaussian model gives almost identical results, though, since our pooled data are approximately gaussian
niche_gam_00 <- gam(mean.niche.overlap ~
                      level + 
                      #management +
                      s(elev.mean, by = level, k = 8, m = 2),
                    method = "REML",
                    family = betar(eps = 0.001),
                    select = TRUE,
                    data = niche_overlap_levels) %>% getViz()

check.gamViz(niche_gam_00)
summary(niche_gam_00)
print(plot.gamViz(niche_gam_00, allTerms = TRUE), pages = 1)
```

### 3.5.2 Visualize
```{r}
# Adding raw data back in
data_add <- niche_overlap_levels %>%
  ungroup() %>%
  arrange(elev.mean, level) %>%
  select(site, mean.niche.overlap)

# Get predictions using tidymv
niche_gam_00_pred <- get_gam_predictions(niche_gam_00, elev.mean) %>%
  as_tibble() %>%
  mutate(mean.niche.overlap_trans = inv_logit_scaled(mean.niche.overlap),
         CI_upper_trans = inv_logit_scaled(CI_upper),
         CI_lower_trans = inv_logit_scaled(CI_lower)) %>%
  select(-mean.niche.overlap) %>%
  bind_cols(data_add)

# Plot smooths
ggplot(niche_gam_00_pred, aes(elev.mean, mean.niche.overlap, color = level)) +
  geom_point() +
  geom_ribbon(aes(elev.mean, mean.niche.overlap_trans, 
                  ymax = CI_upper_trans, ymin = CI_lower_trans,
                  fill = level),
              alpha = 0.3, inherit.aes = FALSE) +
  geom_line(aes(elev.mean, mean.niche.overlap_trans, 
                color = level), inherit.aes = FALSE) +
  ylab("Niche overlap") +
  xlab("Elevation (m)") +
  guides(fill = FALSE) +
  labs(color = "Level") +
  theme_light()

ggsave(file = "../output/niche_gam_00_plot1.pdf", width = 5, height = 4)
ggsave(file = "../output/niche_gam_00_plot1.png", width = 5, height = 4)

# Plot intercept effect of level
plot(pterm(niche_gam_00, 1))

plotDiff(sm(niche_gam_00, 1), sm(niche_gam_00, 3)) +
  l_ciPoly() + 
  l_fitLine() + 
  geom_hline(yintercept = 0, linetype = 2)
```

## 3.7 Genus-level niche overlap by tongue.diff

### 3.7.1 Model
```{r}
niche_gam_20 <- gam(mean.niche.overlap ~
                     tongue.diff +
                     s(elev.mean, by = tongue.diff, k = 8, m = 2),
                   method = "REML",
                   family = betar(eps = 0.001),
                   select = TRUE,
                   data = niche_overlap_tonguediff) %>% getViz()

check.gamViz(niche_gam_20)
summary(niche_gam_20)
print(plot(niche_gam_20, allTerms = TRUE), pages = 1)

niche_gam_21 <- gam(mean.niche.overlap ~
                     tongue.pair +
                     s(elev.mean, by = tongue.pair, k = 8, m = 2),
                   method = "REML",
                   family = betar(eps = 0.001),
                   select = TRUE,
                   data = niche_overlap_tongues) %>% getViz()

check.gamViz(niche_gam_21)
summary(niche_gam_21)
print(plot(niche_gam_21, allTerms = TRUE), pages = 1)
```


### 3.7.2 Visualize
```{r}
# Tongue diff
# Get predictions
niche_gam_20_pred <- get_gam_predictions(niche_gam_20, elev.mean) %>%
  as_tibble() %>%
  mutate(mean.niche.overlap_trans = inv_logit_scaled(mean.niche.overlap),
         CI_upper_trans = inv_logit_scaled(CI_upper),
         CI_lower_trans = inv_logit_scaled(CI_lower))

# Plot smooths
ggplot(niche_gam_20_pred, aes(elev.mean, mean.niche.overlap_trans, color = tongue.diff)) +
  geom_ribbon(aes(elev.mean, mean.niche.overlap_trans, 
                  ymax = CI_upper_trans, ymin = CI_lower_trans,
                  fill = tongue.diff),
              alpha = 0.3, inherit.aes = FALSE) +
  geom_line() +
  ylab("Niche overlap") +
  xlab("Elevation (m)") +
  guides(fill = FALSE) +
  labs(color = "Tongue class") +
  theme_light()

ggsave(file = "../output/niche_gam_20_plot1.pdf", width = 5, height = 4)
ggsave(file = "../output/niche_gam_20_plot1.png", width = 5, height = 4)

# Plot intercept effect of tongue.diff
plot(pterm(niche_gam_20, 1))

# Tongue pair
# Get predictions
niche_gam_21_pred <- get_gam_predictions(niche_gam_21, elev.mean) %>%
  as_tibble() %>%
  mutate(mean.niche.overlap_trans = inv_logit_scaled(mean.niche.overlap),
         CI_upper_trans = inv_logit_scaled(CI_upper),
         CI_lower_trans = inv_logit_scaled(CI_lower))

# Plot smooths
ggplot(niche_gam_21_pred, aes(elev.mean, mean.niche.overlap_trans, color = tongue.pair)) +
  geom_ribbon(aes(elev.mean, mean.niche.overlap_trans, 
                  ymax = CI_upper_trans, ymin = CI_lower_trans,
                  fill = tongue.pair),
              alpha = 0.3, inherit.aes = FALSE) +
  geom_line() +
  ylab("Niche overlap") +
  xlab("Elevation (m)") +
  guides(fill = FALSE) +
  labs(color = "Tongue pair") +
  theme_light()

ggplot(niche_gam_21_pred, aes(elev.mean, mean.niche.overlap_trans)) +
  geom_ribbon(aes(elev.mean, mean.niche.overlap_trans, 
                  ymax = CI_upper_trans, ymin = CI_lower_trans),
              alpha = 0.3, inherit.aes = FALSE) +
  geom_line() +
  ylab("Niche overlap") +
  xlab("Elevation (m)") +
  guides(fill = FALSE) +
  facet_wrap(~tongue.pair) +
  theme_light()


ggsave(file = "../output/niche_gam_21_plot1.pdf", width = 5, height = 4)
ggsave(file = "../output/niche_gam_21_plot1.png", width = 5, height = 4)

# Plot intercept effect of tongue.diff
pdf("../output/niche_gam_21_plot2.pdf", width = 5, height = 4)
plot(pterm(niche_gam_21, 1)) + labs(x = "Tongue pair", y = "Niche overlap") + theme_light()
dev.off()
```





