---
title: "visitation_bias"
author: "Doug Sponsler"
date: "12/14/2020"
output: html_document
---
# Preparations
## Packages 
```{r, warning=FALSE, include=FALSE, echo = FALSE}
library(bipartite)
library(brms)
library(lme4)
library(sjPlot)
library(DHARMa)
library(bayesplot)
library(tidybayes)
library(modelr)
library(ggdist)
library(vegan)
library(ggvegan)
library(ggrepel)
library(treemapify)
library(patchwork)
library(tidymodels)
library(tidyverse)
library(lubridate)

rstan::rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```

## Load data
```{r message=FALSE, warning=FALSE, include=FALSE, echo = FALSE}
# Site data
site_data <- read_csv("../data/processed_data/site_data.csv") %>%
  dplyr::select(-c(slope.calc, slope.est, elev.min, elev.max, temp.mean)) %>% # drop these variables
  mutate(elev.class2 = factor(elev.class2, levels = c("low", "mid", "high")),
         site = factor(site)) # turn elav.class into an ordered factor and site into a regular factor

# BB traits
bb_traits <- read_csv("../data/processed_data/bb_traits.csv") 

ggplot(bb_traits, aes(pbl.w, pbl.w.durieaux,
                      color = bb.sp, pch = factor(pbl.w.class2))) +
  geom_point()

# FL traits
## family-level taxonomy
fl_tax <- read_csv("../data/processed_data/floral_tax.csv") 

## Kugler morphotypes (accessed through Bioflor)
fl_ktype <- read_csv("../data/processed_data/floral_k_type.csv") 

## Flower colors (accessed through BioFlor)
fl_color <- read_csv("../data/processed_data/floral_color.csv")

## diameter and corolla depth data from Gita Benadi
fl_morph <- read_csv("../data/processed_data/flower_morphology_GitaBenadi.csv") %>% 
  dplyr::select(SampleID, plant.family = Family, plant.sp = Species, 
                Unit, Flowers_per_unit, diam = Diameter, LN) %>%
  group_by(plant.sp) %>%
  summarize(diam = mean(diam), LN = mean(LN))

## verbal description of Kugler morphotypes
fl_ktype_key <- read_delim("../data/processed_data/kugler_key.tsv", delim = "\t", col_names = FALSE) %>%
  dplyr::select(k.type = 1, description = 2)

## join all floral trait tables
fl_traits <- fl_tax %>%
  full_join(fl_ktype) %>%
  full_join(fl_color) %>%
  full_join(fl_morph) %>%
  dplyr::select(plant.sp, plant.genus, plant.family, k.type, k.type.s, k.type.ss, color, diam, LN)
```

## Align survey and visitation data with pseudodates
```{r}
# Site-dates where BB visitation was recorded (excluding dates where only males were recorded)
visitation_samples <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>%
  select(site, date) %>%
  distinct() 

# Site dates where floral surveying was conducted
survey_samples <- read_csv("../data/processed_data/floral_survey.csv") %>%
  select(site, date) %>%
  distinct()

# Site-dates where visitation sampling and floral sampling coincided
shared_dates <- inner_join(visitation_samples, survey_samples)

# Site-dates where visitation was recorded WITHOUT corresponding survey data
visitation_only <- anti_join(visitation_samples, survey_samples) %>%
  mutate(date.v = date) %>%
  select(-date)

# This creates a pseudo date column for unmatched visitation site-dates that will match each visitation date
# to its nearest survey data. For site t4, there is a 2-year mismatch; we will drop these site-dates later.
pseudodates <- full_join(visitation_only, survey_samples) %>%
  mutate(mismatch = abs(date.v - date)) %>%
  group_by(site, date.v) %>%
  filter(mismatch == min(mismatch)) %>%
  rename(date = date.v, pseudo.date = date)
```

## Generate a data frame that represents visitation and survey abundance
```{r}
# BB visitation data
visitation <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  group_by(site, date, bb.sp, plant.sp) %>%
  summarize(visits = n()) %>% # visits per BB-FL pair
  ungroup() %>%
  left_join(pseudodates) %>% # Now we will replace unmatched dates with their pseudo dates
  replace_na(replace = list(mismatch = 0)) %>% # set mismatch to zero for perfectly aligned dates
  filter(mismatch <= 7) %>% # this gets rid of irreconcilable dates (like the t4 dates mentioned above)
  mutate(date2 = if_else(is.na(pseudo.date), date, pseudo.date)) %>% # replace date with pseudodate for all site-dates lacking perfect alignments
  select(-c(date, pseudo.date, mismatch)) %>%
  rename(date = date2) %>%
  group_by(site, date) %>%
  complete(bb.sp, plant.sp, fill = list(visits = 0)) # generate all possible BB-FL combos for each site date and fill in zeros for visits

# Floral cover data
flower_cover <- read_csv("../data/processed_data/floral_survey.csv") %>%
  filter(flower.cover > 0) %>% # ignore plants that were not blooming
  group_by(site, date, plant.sp) %>%
  summarize(flower.cover = sum(flower.cover))

# Get shared dates after adding pseudodates. This will let us filter out survey dates that don't
# have corresponding visitation sampling dates
shared_dates_with_pseudo <- inner_join(visitation, flower_cover, by = c("site", "date")) %>%
  select(site, date) %>%
  distinct()

# Join visitation and flower cover data

## First we need a list of all BB spp. by site and date
sp_by_site <- visitation %>% 
  ungroup() %>%
  select(site, date, bb.sp) %>%
  distinct()

## Then we need a list of unvisited plant.sp by site and date
unvisited <- flower_cover %>% 
  semi_join(shared_dates_with_pseudo) %>% # filter flower cover data to include only site-dates with visitation complement (real or pseudodates)
  full_join(visitation) %>% # join to visitation data
  filter(is.na(bb.sp)) %>% # select only the site-date-plants that were totally unvisited (and therefore have no BB spp to join to)
  select(-bb.sp) %>% # drop bb.sp variable because I just want the plants
  left_join(sp_by_site) %>% # join in the species list by site and date, thus populating the unvisited plants with all the BB spp recorded for each site-date
  replace_na(replace = list(visits = 0)) # replace NAs (created in the line above) with zero

## Now we can combine everything into a single data frame
visit_cover <- flower_cover %>% 
  semi_join(shared_dates_with_pseudo) %>% # filter flower cover data to include only site-dates with visitation complement (real or pseudodates)
  full_join(visitation) %>% # join to visitation data
  replace_na(replace = list(flower.cover = 0.01)) %>% # If a plant was visited but not surveyed, we will assign it the minimum non-zero flower cover value of 0.01.
  filter(!is.na(bb.sp)) %>% # drop the univisited plants
  bind_rows(unvisited) %>% # add them back, with BB spp and zeros
  select(site, date, bb.sp, plant.sp, visits, flower.cover) %>%
  group_by(site, date, bb.sp, plant.sp, flower.cover) %>% # In a few cases, the use of pseudodates causes two sampling period to converge on the same date, which creates apparent duplicate visitation data. We will handle this by averaging the visits.
  summarize(visits = mean(visits)) %>%
  left_join(fl_traits) %>% # add floral traits
  ungroup() %>%
  mutate(k.type.ss = factor(k.type.ss))

ktype_families <- visit_cover %>%
  select(plant.sp, plant.family, k.type.ss) %>%
  distinct()
  
ggplot(ktype_families, aes(plant.family, fill = k.type.ss)) +
  geom_bar(position = "fill") +
  theme(axis.text.x = element_text(angle = 90))

## Get total visits by BB sp and site-date; this will be a measure of BB abundance that we can use after we've calculated d'. I could, of course, work this into the biaseval function, but I'll put that off for now.
bb_abundance <- visit_cover %>%
  group_by(site, date, bb.sp) %>%
  summarize(bb.sp.abund = sum(visits)) %>%
  group_by(site, date) %>%
  mutate(bb.sp.prop.abund = bb.sp.abund/sum(bb.sp.abund))

fl_abundance <- visit_cover %>%
  group_by(site, date) %>%
  summarize(total.flower.cover = sum(flower.cover))
```

## A handy function for calculating Blüthgen's d'
```{r}
# A function for calculating Blüthgen's d', parsed in various ways
biaseval <- function(x, criterion, ...) { # criterion = plant grouping variable, e.g. plant.sp, k.type.ss, color
  
  criterion <- enquo(criterion) # tidy eval
  
  x %>%
    
# Select variables of interest; the ... represents the variables we will use to parse our analysis
    select(..., bb.sp, !!criterion, flower.cover, visits) %>% 
    group_by(..., bb.sp, !!criterion) %>%
    
# If criterion = plant.sp, this next step does nothing. But if criterion is some other grouping variable (e.g. k.type.ss), this sums flower cover and visits over that grouping variable.
    summarize(flower.cover = sum(flower.cover), 
              visits = sum(visits)) %>%
    
# Nest into list column
    group_by(...) %>%
    nest() %>%

# Pivot each nested data frame into the kind of web that bipartite likes
    mutate(webs = map(data, function(x) select(x, bb.sp, !!criterion, visits) %>%
                        pivot_wider(names_from = !!criterion, values_from = visits, values_fill = 0) %>%
                        column_to_rownames("bb.sp"))) %>%

# Pull out the flower.cover variable to use in the "abuns" argument of dfun below
    mutate(low.abund = map(data, function(x) select(x, !!criterion, flower.cover) %>%
                            unique() %>%
                            column_to_rownames(paste(criterion)[2]))) %>% # Tell me why I need to do this, Hadley.

# Call the dfun command from bipartite to calculate Blüthgen's d'
    mutate(d = map2(webs, low.abund, function(x, y) bipartite::dfun(x, abuns = y$flower.cover) %>%
                      data.frame() %>%
                      rownames_to_column(var = "bb.sp"))) %>%
    
    unnest(cols = d) %>%
    na.omit() %>% # in a few cases where the sampling is very sparse, d' cannot be calculated; these are safe to drop
    ungroup() %>%
    mutate(site = factor(site),
         bb.sp = factor(bb.sp),
         year = factor(lubridate::year(date)))
}
```

# 1. Quantifying bias
How does overall bias (Blüthgen's d') vary across species and through elev*time? For now, we will focus on bias at the level of plant species. We'll start considering traits later on when our goal is to explain patterns of bias.
## 1.1 Calculate Blüthgen's d' (i.e. visitation bias)
```{r}
# No grouping -- just plant.sp
bias_plantsp <- biaseval(visit_cover, plant.sp, site, date) %>%
  rename(dprime.sp = dprime) %>%
  select(site, date, bb.sp, dprime.sp)

# Grouped by k.type.ss
bias_ktype <- biaseval(visit_cover, k.type.ss, site, date) %>%
  rename(dprime.ktype = dprime) %>%
  select(site, date, bb.sp, dprime.ktype)

# Grouped by plant.family
bias_family <- biaseval(visit_cover, plant.family, site, date) %>%
  rename(dprime.fam = dprime) %>%
  select(site, date, bb.sp, dprime.fam)

# Collated
## Filtered t0 abund >= 3
bias <- full_join(bias_plantsp, bias_ktype) %>%
  full_join(bias_family) %>%
  left_join(site_data) %>% # add site data
  left_join(bb_abundance) %>% # add BB abundance data
  left_join(fl_abundance) %>% # add fl abundance
  filter(bb.sp.abund >= 3) %>% # dprime tends to become binary when n is very low; this threshold removes more than half the data points, but almost all those were ones and zeros. These ones and zeros probably don't mean much, and they make the models hard to fit.
  mutate(bb.sp = factor(bb.sp), 
         yday = yday(date),
         elev = elev.mean/10) %>% #  scale this down for convenience
  mutate(yday0 = scale(yday),  # normalized versions of variables
         elev0 = scale(elev),
         bb.sp.abund0 = scale(bb.sp.abund),
         dprime.sp0 = scale(dprime.sp),
         dprime.ktype0 = scale(dprime.ktype),
         dprime.fam0 = scale(dprime.fam)) %>%
  select(site, date, bb.sp, dprime.sp, dprime.sp0, dprime.ktype, 
         dprime.ktype0, dprime.fam, dprime.fam0, elev, elev0, 
         yday, yday0, bb.sp.abund, bb.sp.abund0, bb.sp.prop.abund, total.flower.cover)

## Unfiltered
bias2 <- full_join(bias_plantsp, bias_ktype) %>%
  full_join(bias_family) %>%
  left_join(site_data) %>% # add site data
  left_join(bb_abundance) %>% # add BB abundance data
  left_join(fl_abundance) %>% # add fl abundance
  #filter(bb.sp.abund >= 3) %>% # dprime tends to become binary when n is very low; this threshold removes more than half the data points, but almost all those were ones and zeros. These ones and zeros probably don't mean much, and they make the models hard to fit.
  mutate(bb.sp = factor(bb.sp), 
         yday = yday(date),
         elev = elev.mean/10) %>% #  scale this down for convenience
  mutate(yday0 = scale(yday),  # normalized versions of variables
         elev0 = scale(elev),
         bb.sp.abund0 = scale(bb.sp.abund),
         dprime.sp0 = scale(dprime.sp),
         dprime.ktype0 = scale(dprime.ktype),
         dprime.fam0 = scale(dprime.fam)) %>%
  select(site, date, bb.sp, dprime.sp, dprime.sp0, dprime.ktype, 
         dprime.ktype0, dprime.fam, dprime.fam0, elev, elev0, 
         yday, yday0, bb.sp.abund, bb.sp.abund0, bb.sp.prop.abund, total.flower.cover)

ggplot(bias, aes(dprime.sp)) +
  geom_histogram()

ggplot(bias2, aes(dprime.sp)) +
  geom_histogram()

ggplot(filter(bias2, bb.sp.abund >= 5), aes(dprime.sp)) +
  geom_histogram()

ggplot(filter(bias2, bb.sp.abund >= 10), aes(dprime.sp)) +
  geom_histogram()

ggplot(filter(bias, bb.sp %in% c("pasc", "prat", "wurf", "soro", "psit", "hort", "telu")), aes(elev, dprime.sp)) +
  geom_point() +
  geom_smooth() +
  facet_wrap(~bb.sp)
```

## 1.3 Multi-level model: bias ~ yday * elevation + (1 + elevation | bb.sp)
### 1.3.1 Preliminary visualization
```{r}
# I am interested both in the variation of bias through elevation and time and in the intercept effect of each bumble bee species

ggplot(bias, aes(dprime.sp)) +
  geom_histogram()

ggplot(bias2, aes(bb.sp.abund, dprime.sp)) +
  geom_point() +
  geom_smooth(method = "lm") +
  facet_wrap(~bb.sp)

# First, let's look at the distribution of bias per BB sp
ggplot(bias, aes(dprime.sp)) +
  geom_histogram() +
  facet_wrap(~bb.sp)

ggplot(bias, aes(dprime.ktype)) +
  geom_histogram() +
  facet_wrap(~bb.sp)

ggplot(bias, aes(dprime.fam)) +
  geom_histogram() +
  facet_wrap(~bb.sp)

# Now, let's try to get a sense for the shape of the response to elevation and time; we might expect to find nonlinearities here
ggplot(bias, aes(elev, dprime.sp)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~bb.sp)

ggplot(bias, aes(yday, dprime.sp)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~bb.sp)

ggplot(bias, aes(elev, dprime.ktype)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~bb.sp)

ggplot(bias, aes(yday, dprime.ktype)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~bb.sp)

ggplot(bias, aes(elev, dprime.fam)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~bb.sp)

ggplot(bias, aes(yday, dprime.fam)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_wrap(~bb.sp)

# After inspecting these plots, I see no reason to indulge in wiggly models.
```

### 1.3.3 brms models
There's a lot I don't understand about the standardization of variables in the context of Bayesian MLM, but for now I have opted to scale and center the predictor variables but not the response. My reason for scaling and centering the predictors is that is massively speeds up estimation and enables the interaction model to converge (it would not converge with raw variables). My reason for not scaling the response is that it doesn't change the outcome of the model (I've checked) and I am interested in seeing the global intercept for d' on its original scale so that I can compare it with previously reported values. Right now, I am using all default priors. This means flat priors for global effects and student priors for varying effects (I think). My understanding is that brms internally scales priors to match the scale of the data. If I want to define my own priors, which I know I really should, particularly to replace the flat priors on the global effects, then I need to understand how the scaling of the variables affects the specification of the prior.

I am also opting to use beta regression because it acknowledges the (0,1) boundedness of d'. There is a lovely paper on this topic (Douma and Weedon 2019, MEE), and in it the authors explicitly note that beta regression can be applied to derived metrics that are (0,1) bounded. 

"Although we present beta regression in this review as a method for analysing continuous‐based proportions, there are also many examples for using this techniques to analyse data from derived indices that are bound between 0 and 1 (e.g. an evenness index in Nogueira, González‐Troncoso, and Tolimieri (2016); or a straightness index in Shimada et al. (2016)). In addition, it can be applied to variables that are constrained to the interval a and b as they can be rescaled to [0, 1] through (y − a)/(b − a)."

Importantly, the results of beta regression are on the logit scale, so they have to be back-transformed using the inv_logit_scaled() function.

I've played around with every way I can think of to add elevation as a predictor, but there just isn't an elevation effect to be found, and loo model evaluation always favors a varying site intercept to a fixed elevation effect. I'm removing those models for the time being to clean up my script. I can always run them again if we decide it is important ot show the model selection process for the paper.

#### Call models
```{r}
# Full data
brm_dprime.sp10 <- brm(dprime.sp ~ yday0 + bb.sp.abund0 + (1 | bb.sp) + (1 | site),
                       cores = 4,
                       iter = 2000,
                       family = "zero_one_inflated_beta", # 
                       file = "../output/brm_dprime.sp10",
                       data = bias2)

# Abundance threshold >= 3
brm_dprime.sp00 <- brm(dprime.sp ~ yday0 + bb.sp.abund0 + (1 | bb.sp) + (1 | site),
                       cores = 4,
                       iter = 2000,
                       family = "zero_one_inflated_beta", # 
                       file = "../output/brm_dprime.sp00",
                       data = bias)

# Abundance threshold >= 5
brm_dprime.sp20 <- brm(dprime.sp ~ yday + bb.sp.abund + (1 | bb.sp) + (1 | site),
                       cores = 4,
                       iter = 2000,
                       family = "zero_one_inflated_beta", # 
                       file = "../output/brm_dprime.sp20",
                       data = filter(bias, bb.sp.abund >= 5))

# Abundance threshold >= 10
brm_dprime.sp30 <- brm(dprime.sp ~ yday + bb.sp.abund + (1 | bb.sp) + (1 | site),
                       cores = 4,
                       iter = 2000,
                       family = "zero_one_inflated_beta", # 
                       file = "../output/brm_dprime.sp30",
                       data = filter(bias, bb.sp.abund >= 10))
```

#### 1.3.3.1 Evaluate models
They just explains so little variance... d' is too unstable at low abundance. I just don't think there is much that can be said here. 
```{r}
# Full data
pp_check(brm_dprime.sp10)
bayes_R2(brm_dprime.sp10)

## QQ plot
qres_dprime10 <- bias2 %>%
  add_predicted_draws(brm_dprime.sp10, n = 20) %>%
  summarise(
    quant_residual = mean(.prediction < dprime.sp)
  ) 

ggplot(qres_dprime10,
         aes(sample = quant_residual)) +
  geom_qq(distribution = stats::qunif) +
  geom_qq_line(distribution = stats::qunif)

## Predicted vs. data
pred_vs_data_dprime10 <- bias2 %>%
  add_predicted_draws(brm_dprime.sp10, n = 20) 

ggplot(pred_vs_data_dprime10, aes(.prediction, dprime.sp)) +
  geom_point(alpha = 0.25) 


# Abundance >= 3
pp_check(brm_dprime.sp00)
bayes_R2(brm_dprime.sp00)

## QQ plot
qres_dprime00 <- bias %>%
  add_predicted_draws(brm_dprime.sp00, n = 20) %>%
  summarise(
    quant_residual = mean(.prediction < dprime.sp)
  ) 

ggplot(qres_dprime00,
         aes(sample = quant_residual)) +
  geom_qq(distribution = stats::qunif) +
  geom_qq_line(distribution = stats::qunif)

## Predicted vs. data
pred_vs_data_dprime00 <- bias %>%
  add_predicted_draws(brm_dprime.sp00, n = 20) 

ggplot(pred_vs_data_dprime00, aes(.prediction, dprime.sp)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "lm")

# Abundance >= 5
pp_check(brm_dprime.sp20)
bayes_R2(brm_dprime.sp20)

## QQ plot
qres_dprime20 <- filter(bias2, bb.sp.abund >= 5) %>%
  add_predicted_draws(brm_dprime.sp20, n = 20) %>%
  summarise(
    quant_residual = mean(.prediction < dprime.sp)
  ) 

ggplot(qres_dprime20,
         aes(sample = quant_residual)) +
  geom_qq(distribution = stats::qunif) +
  geom_qq_line(distribution = stats::qunif)

## Predicted vs. data
pred_vs_data_dprime20 <-  filter(bias2, bb.sp.abund >= 5) %>%
  add_predicted_draws(brm_dprime.sp20, n = 20) 

ggplot(pred_vs_data_dprime20, aes(.prediction, dprime.sp)) +
  geom_point(alpha = 0.25) +
  geom_smooth(method = "lm")

# Abundance >= 10
pp_check(brm_dprime.sp30)
bayes_R2(brm_dprime.sp30)

## QQ plot
qres_dprime30 <- filter(bias2, bb.sp.abund >= 10) %>%
  add_predicted_draws(brm_dprime.sp30, n = 20) %>%
  summarise(
    quant_residual = mean(.prediction < dprime.sp)
  ) 

ggplot(qres_dprime30,
         aes(sample = quant_residual)) +
  geom_qq(distribution = stats::qunif) +
  geom_qq_line(distribution = stats::qunif)

## Predicted vs. data
pred_vs_data_dprime30 <-  filter(bias2, bb.sp.abund >= 10) %>%
  add_predicted_draws(brm_dprime.sp20, n = 20) 

ggplot(pred_vs_data_dprime30, aes(.prediction, dprime.sp)) +
  geom_point(alpha = 0.210) +
  geom_smooth(method = "lm")


```


#### 1.3.3.2 Preliminary visualization
```{r}
# Full data
conditional_effects(brm_dprime.sp10)
mcmc_plot(brm_dprime.sp10, pars = "^r_bb.sp")
mcmc_plot(brm_dprime.sp10, pars = "^r_site")

# Abundance >= 3
conditional_effects(brm_dprime.sp00)
mcmc_plot(brm_dprime.sp00, pars = "^r_bb.sp")
mcmc_plot(brm_dprime.sp00, pars = "^r_site")
```

#### 1.3.3.4 Final visualization
```{r}
# Full data with zero- one-inflation
get_variables(brm_dprime.sp10)

brm_dprime.sp10_plotframe <- brm_dprime.sp10 %>%
  spread_draws(b_Intercept, r_bb.sp[condition, term]) %>% 
  mutate(condition_mean = b_Intercept + r_bb.sp) %>%
  mutate(condition_mean_invlogit = inv_logit_scaled(condition_mean))

brm_dprime.sp10_plotframe2 <- brm_dprime.sp10 %>%
  spread_draws(b_Intercept, r_site[condition, term]) %>% 
  mutate(condition_mean = b_Intercept + r_site) %>%
  mutate(condition_mean_invlogit = inv_logit_scaled(condition_mean))

brm_dprime.sp10_subplot1 <- ggplot(brm_dprime.sp10_plotframe, aes(condition_mean_invlogit, condition)) +
  stat_halfeye() +
  ylab("Bumble bee species") +
  xlab("Discrimination (d')") +
  theme_light() 

brm_dprime.sp10_subplot2 <- ggplot(brm_dprime.sp10_plotframe2, aes(condition_mean_invlogit, condition)) +
  stat_halfeye() +
  ylab("Site") +
  xlab("Discrimination (d')") +
  theme_light()

brm_dprime.sp10_plot1 <- brm_dprime.sp10_subplot1 | brm_dprime.sp10_subplot2

ggsave(brm_dprime.sp10_plot1, file = "../output/brm_dprime.sp10_plot1.png")

# Subsetted data 
get_variables(brm_dprime.sp00)

brm_dprime.sp00_plotframe <- brm_dprime.sp00 %>%
  spread_draws(b_Intercept, r_bb.sp[condition, term]) %>% 
  mutate(condition_mean = b_Intercept + r_bb.sp) %>%
  mutate(condition_mean_invlogit = inv_logit_scaled(condition_mean))

brm_dprime.sp00_plotframe2 <- brm_dprime.sp00 %>%
  spread_draws(b_Intercept, r_site[condition, term]) %>% 
  mutate(condition_mean = b_Intercept + r_site) %>%
  mutate(condition_mean_invlogit = inv_logit_scaled(condition_mean))

brm_dprime.sp00_subplot1 <- ggplot(brm_dprime.sp00_plotframe, aes(condition_mean_invlogit, condition)) +
  stat_halfeye() +
  ylab("Bumble bee species") +
  xlab("Discrimination (d')") +
  theme_light() 

brm_dprime.sp00_subplot2 <- ggplot(brm_dprime.sp00_plotframe2, aes(condition_mean_invlogit, condition)) +
  stat_halfeye() +
  ylab("Site") +
  xlab("Discrimination (d')") +
  theme_light()

brm_dprime.sp00_plot1 <- brm_dprime.sp00_subplot1 | brm_dprime.sp00_subplot2

ggsave(brm_dprime.sp00_plot1, file = "../output/brm_dprime.sp00_plot1.png")
```

# 2. Explaining bias
## 2.1 Calculate visitation probability per plant morphotype. Instead of keeping the plant species resolved, we will pool visitation by morphotype. The problem with not pooling by morphotype is that more species-rich morphotypes will be penalized simply because their visitation is diluted across more species.
```{r}
prop_visits_ktype <- visit_cover %>%
  group_by(site, date, bb.sp, k.type.ss) %>%
  summarize(flower.cover = sum(flower.cover), # get raw flower cover and visits by site*date*bb.sp*plant.sp
            visits = sum(visits)) %>%
  group_by(site, date) %>%
  mutate(prop.flower.cover = flower.cover/sum(flower.cover))%>% # binary visits
  group_by(site, date, bb.sp) %>%
  mutate(prop.visits = visits/sum(visits),
         bb.sp.abund = sum(visits)) %>% # abundance of each BB sp. per site-date
  ungroup() %>%
  left_join(bb_traits) %>% # add BB traits
  mutate(ktype = factor(k.type.ss), # recode variables
         tongue = factor(pbl.w.class2),
         visits = as.integer(visits)) %>% # so we can run a Poisson model
  left_join(site_data) %>% # add site data
  ungroup() %>%
  mutate(yday = yday(date),
         elev.mean0 = scale(elev.mean),
         yday0 = scale(yday),
         prop.flower.cover0 = scale(prop.flower.cover),
         perc.flower.cover = prop.flower.cover*100,
         bb.sp.abund0 = scale(bb.sp.abund)) %>%
  select(site, elev.mean, date, yday, bb.sp, ktype, visits, 
         prop.visits, perc.flower.cover, bb.sp.abund, tongue,
         elev.mean0, yday0, prop.flower.cover0, bb.sp.abund0) %>%
  mutate(visits.bin = if_else(visits > 0, 1, 0))

write_csv(prop_visits_ktype, "../hpc_packets/prop_visits_ktype.csv")

prop_visits_ktype_pooled <- visit_cover %>%
  group_by(site, date, k.type.ss) %>%
  summarize(flower.cover = sum(flower.cover), # get raw flower cover and visits by site*date*bb.sp*plant.sp
            visits = sum(visits)) %>%
  group_by(site, date) %>%
  mutate(prop.flower.cover = flower.cover/sum(flower.cover),
         prop.visits = visits/sum(visits),
         bb.abund = sum(visits),
         visits = as.integer(visits)) %>%
  mutate(ktype = factor(k.type.ss)) %>%
  left_join(site_data) %>% # add site data
  ungroup() %>%
  mutate(yday = yday(date),
         elev.mean0 = scale(elev.mean),
         yday0 = scale(yday),
         perc.flower.cover = prop.flower.cover*100,
         prop.flower.cover0 = scale(prop.flower.cover),
         bb.abund0 = scale(bb.abund)) %>%
  select(site, elev.mean, date, yday, ktype, visits, 
         prop.visits, bb.abund, perc.flower.cover,
         elev.mean0, yday0, prop.flower.cover0, bb.abund0) %>%
  mutate(visits.bin = if_else(visits > 0, 1, 0))

write_csv(prop_visits_ktype_pooled, "../hpc_packets/prop_visits_ktype_pool.csv")

```

## 2.2 Multi-level models
### I tried fitting proportional visitation with beta regression models, but the models performed really badly, with R2 < 1%. I was depressed for some time. But then I realized that the problem was probably caused by low abundance species, which constitute most of my data.  For low-abundance species, and especially singletons, proportional visitation tends to be 100% for a single ktype and 0% for all others. That's tough to model. But using the raw count data, that's not a problem, because we could accurately predict that the visitation of a rare species would be extremely low, and the difference between 1 visit and 0 visits is small. So, I am opting for negbinomial models (these are more robust than Poisson, allowing for overdispersion I think --- loo likes them better than Poisson anyway). The costs are (1) I now have to condition on the interaction of BB abundance and proportional floral abundance and (2) it's theoretically possible to predict more visits than bumble bees. As long as the models converge, I don't think that (1) is a problem. (2) is undesirable, but I don't think it's really that serious, since the point is get our predictions close to reality, even if the actual predictions are impossible. I would rather get an impossible prediction that is close to reality than a possible one that is far from it (say, a prediction of 0% when reality is 100% --- no wonder my beta models flopped!). With the negbinomial models, I'm explaining ~50% of the variance, and I call that a win.

If these models are legit --- and I need to be patient in making sure of that --- then I have a jackpot of inference here. I have the morphotype:bb.sp and morphotype:tongue effects in spades. But a really cool and unexpected finding is that there is a decoupling of the intercept and slope terms. Some morphotypes have high intercepts but low slopes, indicating that they are visited heavily even when they are at relatively low abundance. Others have lower intercepts but response more steeply to prop flower cover. I think I can tell a story about that. Finally, there is substantial site variation, which could be interpreted as lability of bias. 

But these models need to be scrutinized. In particular, I don't really understand the pp.check output. The negbinomial models seem like they might be weirder than the Poisson models. I could always try zero-inflated models if that seems necessary.
### 2.2.1 Call models
```{r}
## Exploring the differential bias of bumble bee species and tongue length classes towards floral morphotypes
### Bernoulli with binarized visitation
brm_pvis30 <- brm(as.integer(visits.bin) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 + perc.flower.cover | ktype:tongue) + # a random intercept and slope for ktype:tongue
                    (1 + perc.flower.cover | ktype:site), # a random intercept and slope for ktype:site
                  family = "bernoulli", 
                  #file = "../output/brm_prop_visits_ktype_10",  # for running locally
                  file = "brm_prop_visits_ktype_30", # for running on the HPC
                  chains = 4,
                  cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("9", "10")))


### Negbinomial 
brm_pvis10 <- brm(as.integer(visits) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 + perc.flower.cover | ktype:tongue) + # a random intercept and slope for ktype:tongue
                    (1 + perc.flower.cover | ktype:site), # a random intercept and slope for ktype:site
                  family = "negbinomial", 
                  #file = "../output/brm_prop_visits_ktype_10",  # for running locally
                  file = "brm_prop_visits_ktype_10", # for running on the HPC
                  chains = 4,
                  cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("9", "10")))

### Zero-inflated negbinomial
brm_pvis11 <- brm(as.integer(visits) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 + perc.flower.cover | ktype:tongue) + # a random intercept and slope for ktype:tongue
                    (1 + perc.flower.cover | ktype:site), # a random intercept and slope for ktype:site
                  family = "zero_inflated_negbinomial", 
                  #file = "../output/brm_prop_visits_ktype_11",  # for running locally
                  file = "brm_prop_visits_ktype_11", # for running on the HPC
                  chains = 4,
                  cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("9", "10")))

### Poisson
brm_pvis20 <- brm(as.integer(visits) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 + perc.flower.cover | ktype:tongue) + # a random intercept and slope for ktype:tongue
                    (1 + perc.flower.cover | ktype:site), # a random intercept and slope for ktype:site
                  family = "Poisson", # because my proportional data have zeros and ones
                  #file = "../output/brm_prop_visits_ktype_20",  # for running locally
                  file = "brm_prop_visits_ktype_20", # for running on the HPC
                  chains = 4,
                  cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("9", "10")))

### Zero-inflated Poisson
brm_pvis21 <- brm(as.integer(visits) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 + perc.flower.cover | ktype:tongue) + # a random intercept and slope for ktype:tongue
                    (1 + perc.flower.cover | ktype:site), # a random intercept and slope for ktype:site
                  family = "zero_inflated_poisson", # because my proportional data have zeros and ones
                  #file = "../output/brm_prop_visits_ktype_21",  # for running locally
                  file = "brm_prop_visits_ktype_21", # for running on the HPC
                  chains = 4,
                  cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("9", "10")))

brm_pvis22 <- brm(as.integer(visits) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 + perc.flower.cover | ktype:tongue) + # a random intercept and slope for ktype:tongue
                    (1 | ktype:site), # a random intercept and slope for ktype:site
                  family = "zero_inflated_poisson", # because my proportional data have zeros and ones
                  #file = "../output/brm_prop_visits_ktype_22",  # for running locally
                  file = "brm_prop_visits_ktype_22", # for running on the HPC
                  chains = 4,
                  cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("9", "10")))
```
### 2.2.2 Evaluate models
```{r}
# Posterior predictive checks
pp_check(brm_pvis10)
pp_check(brm_pvis11)
pp_check(brm_pvis20)
pp_check(brm_pvis21)

# Predictions vs. data
## Get predictions
brm_pvis10_pred <- predict(brm_pvis10) %>%
  as_tibble()

brm_pvis11_pred <- predict(brm_pvis11) %>%
  as_tibble()

brm_pvis20_pred <- predict(brm_pvis20) %>%
  as_tibble()

brm_pvis21_pred <- predict(brm_pvis21) %>%
  as_tibble()

## Add draws
qres10 <- filter(prop_visits_ktype, !ktype %in% c("9", "10")) %>%
  add_predicted_draws(brm_pvis10, n = 10) 

qres11 <- filter(prop_visits_ktype, !ktype %in% c("9", "10")) %>%
  add_predicted_draws(brm_pvis11, n = 10) 

qres20 <- filter(prop_visits_ktype, !ktype %in% c("9", "10")) %>%
  add_predicted_draws(brm_pvis20, n = 10)

qres21 <- filter(prop_visits_ktype, !ktype %in% c("9", "10")) %>%
  add_predicted_draws(brm_pvis21, n = 10) 

## Plot predictions vs. data
ggplot(qres10, aes(.prediction, visits)) +
  geom_point() +
  geom_smooth()

ggplot(qres11, aes(.prediction, visits)) +
  geom_point() +
  geom_smooth()

ggplot(qres20, aes(.prediction, visits)) +
  geom_point() +
  geom_smooth()

ggplot(qres21, aes(.prediction, visits)) +
  geom_point() +
  geom_smooth()
```

### 2.2.3 Preliminary visualization
```{r}
# Negbinmial
get_variables(brm_pvis10)
conditional_effects(brm_pvis10)
mcmc_plot(brm_pvis10, pars = c("^r_ktype:tongue.*Intercept]$"))
mcmc_plot(brm_pvis10, pars = c("^r_ktype:tongue.*perc.flower.cover]$"))
mcmc_plot(brm_pvis10, pars = c("^r_ktype:bb.sp.*Intercept]$"))
mcmc_plot(brm_pvis10, pars = c("^r_ktype:bb.sp.*perc.flower.cover]$"))
mcmc_plot(brm_pvis10, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis10, pars = c("^r_ktype:site.*perc.flower.cover]$"))

# Zero-inflated negbinomial
get_variables(brm_pvis11)
conditional_effects(brm_pvis11)
mcmc_plot(brm_pvis11, pars = c("^r_ktype:tongue.*Intercept]$"))
mcmc_plot(brm_pvis11, pars = c("^r_ktype:tongue.*perc.flower.cover]$"))
mcmc_plot(brm_pvis11, pars = c("^r_ktype:bb.sp.*Intercept]$"))
mcmc_plot(brm_pvis11, pars = c("^r_ktype:bb.sp.*perc.flower.cover]$"))
mcmc_plot(brm_pvis11, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis11, pars = c("^r_ktype:site.*perc.flower.cover]$"))

# Poisson
get_variables(brm_pvis20)
conditional_effects(brm_pvis20)
mcmc_plot(brm_pvis20, pars = c("^r_ktype:tongue.*Intercept]$"))
mcmc_plot(brm_pvis20, pars = c("^r_ktype:tongue.*perc.flower.cover]$"))
mcmc_plot(brm_pvis20, pars = c("^r_ktype:bb.sp.*Intercept]$"))
mcmc_plot(brm_pvis20, pars = c("^r_ktype:bb.sp.*perc.flower.cover]$"))
mcmc_plot(brm_pvis20, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis20, pars = c("^r_ktype:site.*perc.flower.cover]$"))

# zero-inflated Poisson
get_variables(brm_pvis21)
conditional_effects(brm_pvis21)
mcmc_plot(brm_pvis21, pars = c("^r_ktype:tongue.*Intercept]$"))
mcmc_plot(brm_pvis21, pars = c("^r_ktype:tongue.*perc.flower.cover]$"))
mcmc_plot(brm_pvis21, pars = c("^r_ktype:bb.sp.*Intercept]$"))
mcmc_plot(brm_pvis21, pars = c("^r_ktype:bb.sp.*perc.flower.cover]$"))
mcmc_plot(brm_pvis21, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis21, pars = c("^r_ktype:site.*perc.flower.cover]$"))
```

### 2.2.4 Final visualization
# Note that the intercept is on the log scale, so if you want to transform it back to predicted # visits, you have to exponentiate it. I think. Here is a helplful conversation involving the esteemed Ben Bolker:

---
Dear all,

I used the glm.nb with the default values from the MASS package to run a negative binomial regression. Here is a simple example...The question now is how do I report the results, say, for height? Do I simply take the anti logs. i.e. 1.019613 = exp(0.019423)? 

Bolker:
Yes, exactly. If you look at ?glm.nb you will see that it uses a log link function, and therefore you should exponentiate (anti-log) to back-transform. Natural, not base-10 logs, are used. Don't forget that back-transforming standard errors by themselves is meaningless, you have to back-transform lower and upper confidence limits ...

---

Another conversation, this time with Paul Buerkner

---
I ultimately want to discuss the results of the model fitting on the linear (not log) parameter scale. Is it fine to simply exp() the estimates (samples) when computing credible intervals etc? Obviously means would be stretched, but quantiles should be invariant.

Buerkner: Yes, this is exactly, how it should be done :-)

---

In my workflow, I think this entails first calculating the conditional mean, then running pointinterval() to get the credible intervals **then** exponentiating the conditional mean and the credible intervals.

##### 2.2.2.1.1 morphotype:tongue intercept
```{r}
brm_pvis12_plotframe <- brm_pvis12 %>%
  spread_draws(b_Intercept, `r_ktype:tongue`[condition, term]) %>% # the back ticks are necessary to escape the :
  rename(r_ktype.tongue = `r_ktype:tongue`) %>% # get rid of the problematic :
  filter(term == "Intercept") %>% # drop slope terms for now
  mutate(condition_mean = b_Intercept + r_ktype.tongue) %>% # get conditional mean
  group_by(condition) %>% # group by tongue:morpotype pair
  point_interval(condition_mean, .width = c(0.95, 0.66)) %>% # calculate credible intervals
  mutate(condition_mean_trans = exp(condition_mean), # exponentiating the estimates gets us back to the response scale (negbinomial uses log link function)
         .lower_trans = exp(.lower),
         .upper_trans = exp(.upper)) %>% 
separate(condition, c("ktype", "tongue"), sep = "_", remove = FALSE) %>% # separate condition term into ktype and tongue
  mutate(ktype = case_when( # rename
    ktype == "0" ~ "NA (0)",
    ktype == "1" ~ "Disc (1)",
    ktype == "2" ~ "Funnel (2)",
    ktype == "3" ~ "Bell (3)",
    ktype == "4" ~ "Stalk-disc (4)",
    ktype == "5" ~ "Lip (5)",
    ktype == "6" ~ "Flag (6)",
    ktype == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype, levels = c("Disc (1)", "Funnel (2)", "Bell (3)", # relevel
                                          "Stalk-disc (4)","Lip (5)", "Flag (6)", 
                                          "Head (7)", "NA (0)")))

ggplot(brm_pvis12_plotframe, aes(condition_mean_trans, tongue, 
                                 xmin = .lower_trans, xmax = .upper_trans,
                                 color = tongue, fill = tongue)) +
  geom_pointinterval() +
  facet_grid(ktype~.) +
  theme_light() +
  labs(color = "Tongue length", x = "Mean visits") +
  guides(fill = FALSE) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

ggsave(file = "../output/brm_pvis12_plot1.png", width = 5, height = 7)
```

##### 2.2.2.1.2 morphotype:bb.sp intercept
```{r}
# ktype:bb.sp intercept
brm_pvis12_plotframe2 <- brm_pvis12 %>%
  spread_draws(b_Intercept, `r_ktype:bb.sp`[condition, term]) %>% # the back ticks are necessary to escape the :
  rename(r_ktype.bb.sp = `r_ktype:bb.sp`) %>% # get rid of the problematic :
  filter(term == "Intercept") %>% # drop slope terms for now
  mutate(condition_mean = b_Intercept + r_ktype.bb.sp) %>% # get conditional mean
  group_by(condition) %>% # group by bb.sp:morpotype pair
  point_interval(condition_mean, .width = c(0.95, 0.66)) %>% # calculate credible intervals
  mutate(condition_mean_trans = exp(condition_mean), # exponentiating the estimates gets us back to the response scale (negbinomial uses log link function)
         .lower_trans = exp(.lower),
         .upper_trans = exp(.upper)) %>% 
  separate(condition, c("ktype", "bb.sp"), sep = "_", remove = FALSE) %>% # separate condition term into ktype and bb.sp
  mutate(ktype = case_when( # rename
    ktype == "0" ~ "NA (0)",
    ktype == "1" ~ "Disc (1)",
    ktype == "2" ~ "Funnel (2)",
    ktype == "3" ~ "Bell (3)",
    ktype == "4" ~ "Stalk-disc (4)",
    ktype == "5" ~ "Lip (5)",
    ktype == "6" ~ "Flag (6)",
    ktype == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype, levels = c("Disc (1)", "Funnel (2)", "Bell (3)", # relevel
                                          "Stalk-disc (4)","Lip (5)", "Flag (6)", 
                                          "Head (7)", "NA (0)"))) %>%
  left_join(bb_traits)

ggplot(brm_pvis12_plotframe2, aes(condition_mean_trans, bb.sp, 
                                 xmin = .lower_trans, xmax = .upper_trans,
                                 color = pbl.w.class2, fill = pbl.w.class2)) +
  geom_pointinterval() +
  facet_wrap(~ktype, scales = "free") +
  theme_light(10) +
  labs(color = "Tongue length", x = "Mean visits") +
  guides(fill = FALSE)

ggsave(file = "../output/brm_pvis12_plot2.png", width = 9, height = 6.5)

ggplot(brm_pvis12_plotframe2, aes(condition_mean_trans, ktype, 
                                 xmin = .lower_trans, xmax = .upper_trans)) +
  geom_pointinterval() +
  facet_wrap(~bb.sp, scales = "free") +
  #facet_grid(ktype~.) 
  theme_light(10) +
  labs(color = "Tongue length", x = "Mean visits") +
  guides(fill = FALSE)
```

##### 2.2.2.1.3 morphotype:tongue slope
```{r}
brm_pvis12_plotframe3 <- brm_pvis12 %>%
  spread_draws(b_prop.flower.cover0, `r_ktype:tongue`[condition, term]) %>% # the back ticks are necessary to escape the :
  rename(r_ktype.tongue = `r_ktype:tongue`) %>%
  filter(term == "prop.flower.cover0") %>%
  mutate(condition_slope = b_prop.flower.cover0 + r_ktype.tongue) %>%
  separate(condition, c("ktype", "tongue"), sep = "_", remove = FALSE) %>%
  mutate(ktype = case_when(
    ktype == "0" ~ "NA (0)",
    ktype == "1" ~ "Disc (1)",
    ktype == "2" ~ "Funnel (2)",
    ktype == "3" ~ "Bell (3)",
    ktype == "4" ~ "Stalk-disc (4)",
    ktype == "5" ~ "Lip (5)",
    ktype == "6" ~ "Flag (6)",
    ktype == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype,
                        levels = c("Disc (1)", "Funnel (2)", "Bell (3)", "Stalk-disc (4)",
                                   "Lip (5)", "Flag (6)", "Head (7)", "NA (0)")))

ggplot(brm_pvis12_plotframe3, aes(condition_slope, tongue, color = tongue, fill = tongue)) +
  stat_pointinterval() +
  facet_grid(ktype~.) +
  theme_light() +
  labs(color = "Tongue length", x = "Visits (log-scale)") +
  guides(fill = FALSE) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

ggsave(file = "../output/brm_pvis12_plot2.png", width = 7, height = 5.5)
```


# ktype:bb.sp slope
```{r}
brm_pvis12_plotframe4 <- brm_pvis12 %>%
  spread_draws(b_prop.flower.cover0, `r_ktype:bb.sp`[condition, term]) %>% # the back ticks are necessary to escape the :
  rename(r_ktype.bb.sp = `r_ktype:bb.sp`) %>%
  filter(term == "prop.flower.cover0") %>%
  mutate(condition_slope = b_prop.flower.cover0 + r_ktype.bb.sp) %>%
  separate(condition, c("ktype", "bb.sp"), sep = "_", remove = FALSE) %>%
  mutate(ktype = case_when(
    ktype == "0" ~ "NA (0)",
    ktype == "1" ~ "Disc (1)",
    ktype == "2" ~ "Funnel (2)",
    ktype == "3" ~ "Bell (3)",
    ktype == "4" ~ "Stalk-disc (4)",
    ktype == "5" ~ "Lip (5)",
    ktype == "6" ~ "Flag (6)",
    ktype == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype,
                        levels = c("Disc (1)", "Funnel (2)", "Bell (3)", "Stalk-disc (4)",
                                   "Lip (5)", "Flag (6)", "Head (7)", "NA (0)"))) %>%
  left_join(bb_traits)


ggplot(brm_pvis12_plotframe4, aes(condition_slope, bb.sp, color = pbl.w.class2)) +
  stat_pointinterval() +
  facet_wrap(~ktype, scales = "free") +
  theme_light() +
  labs(color = "Tongue length", x = "Visits (log-scale)") +
  guides(fill = FALSE)

ggsave(file = "../output/brm_pvis12_plot1.png", width = 7, height = 5.5)
```

##### 2.2.2.1.2 Ktype-only model 
```{r}
# Just ktype model
brm_pvis00_plotframe <- brm_pvis00 %>%
  spread_draws(b_Intercept, r_k.type.ss[condition, term]) %>% # the back ticks are necessary to escape the :
  mutate(condition_mean = b_Intercept + r_k.type.ss) %>%
  mutate(ktype = case_when(
    condition == "0" ~ "NA",
    condition == "1" ~ "Disc",
    condition == "2" ~ "Funnel",
    condition == "3" ~ "Bell",
    condition == "4" ~ "Stalk-disc",
    condition == "5" ~ "Lip",
    condition == "6" ~ "Flag",
    condition == "7" ~ "Head")
  ) %>%
  mutate(ktype = factor(ktype,
                        levels = c("Disc", "Funnel", "Bell", "Stalk-disc",
                                   "Lip", "Flag", "Head", "NA")))

ggplot(brm_pvis00_plotframe, aes(condition_mean, ktype)) +
  stat_halfeye() +
  theme_light() +
  guides(fill = FALSE) +
  xlab("Visits (log-scale)") +
  ylab("Morphotype")

ggsave(file = "../output/brm_pvis00_plot1.png", width = 7, height = 5.5)

# What I could do here that I haven't done yet is to plot the predicted curves, incorporating all the slope and intercept information.
ggplot(filter(prop_visits_ktype,!ktype %in% c("9", "10")), aes(bb.sp.abund, prop.flower.cover, size = visits, color = tongue)) +
  geom_point(alpha = 0.15) +
  facet_wrap(~ktype) +
  theme_light()
```

### 2.2.3 The lability of bias: How does the foraging bias of each species with respect to each morphotype vary through elevation and time?
```{r}
# mgcv time
gam1 <- bam(prop.visits ~ prop.flower.cover0 +
              te(yday, elev.mean, by = k.type.ss, bs = c("gp", "tp"), k = c(8, 8)),
            family = "betar",
            method = "fREML",
            discrete = TRUE,
            data = pvis_ktype_pool) %>% getViz()

summary(gam1)
check.gamViz(gam1)
plot.gamViz(gam1)
            
gam2 <- bam(visits ~ te(yday, elev.mean, by = k.type.ss, bs = c("gp", "tp"), k = c(8, 8)),
            family = "quasipoisson",
            method = "fREML",
            discrete = TRUE,
            data = pvis_ktype_pool) %>% getViz()

summary(gam2)
check.gamViz(gam2)
plot.gamViz(gam2)

```

#### We need to do some kind of tensor product gam on this jawn!
```{r}
ggplot(pvis_ktype_pool, aes(yday, elev.mean, color = prop.visits)) +
  geom_point() +
  facet_wrap(~k.type.ss)
```

```{r}
ggplot(pvis_ktype, aes(elev.mean, prop.visits)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_grid(bb.sp ~ k.type.ss)

ggplot(pvis_ktype, aes(elev.mean, prop.visits)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_grid(bb.sp ~ k.type.ss)

ggplot(pvis_ktype, aes(yday0, prop.visits)) +
  geom_point() +
  geom_smooth(method = "gam", formula = y ~ s(x, k = 5)) +
  facet_grid(bb.sp ~ k.type.ss)

brm_pviselev00 <- brm(visits ~ prop.flower.cover0 + 
                        bb.sp.abund0 + 
                        (1 + elev.mean0:yday0 | k.type.ss:bb.sp),
                      family = "poisson",
                      file = "../output/brm_pviselev00",
                      chains = 4,
                      cores = 4,
                      iter = 2000,
                      data = pvis_ktype)

summary(brm_pviselev00)
prior_summary(brm_pviselev00)
parnames(brm_pviselev00)
mcmc_plot(brm_pviselev00, pars = c("^r_k"))
mcmc_plot(brm_pviselev00, pars = c("^r_s"))
mcmc_plot(brm_pviselev00, pars = c("^b_"))
mcmc_plot(brm_pviselev00)
conditional_effects(brm_pviselev00)
pp_check(brm_pviselev00)
bayes_R2(brm_pviselev00)
```


## A related question: do bumble bee species adjust their morphotype preferences along an elevation gradient? Or maybe through time?
```{r}
# Conceptual plot
ggplot(filter(prop_visits_ktype, bb.sp == "prat"), aes(elev.mean, (prop.visits - (perc.flower.cover/100)))) +
  geom_point() +
  facet_wrap(~ktype, scales = "free") +
  geom_smooth()

ggplot(filter(prop_visits_ktype, bb.sp == "pasc"), aes(elev.mean, (prop.visits - (perc.flower.cover/100)))) +
  geom_point() +
  facet_wrap(~ktype, scales = "free") +
  geom_smooth()

ggplot(filter(prop_visits_ktype, bb.sp == "wurf"), aes(elev.mean, (prop.visits - (perc.flower.cover/100)))) +
  geom_point() +
  facet_wrap(~ktype, scales = "free") +
  geom_smooth()

ggplot(filter(prop_visits_ktype, bb.sp == "soro"), aes(elev.mean, (prop.visits - (perc.flower.cover/100)))) +
  geom_point() +
  facet_wrap(~ktype, scales = "free") +
  geom_smooth()

ggplot(filter(prop_visits_ktype, bb.sp == "telu"), aes(elev.mean, (prop.visits - (perc.flower.cover/100)))) +
  geom_point() +
  facet_wrap(~ktype, scales = "free") +
  geom_smooth()

ggplot(filter(prop_visits_ktype, bb.sp == "hort"), aes(elev.mean, (prop.visits - (perc.flower.cover/100)))) +
  geom_point() +
  facet_wrap(~ktype, scales = "free") +
  geom_smooth()
 
# brms model
brm_pvis_elev00 <- brm(as.integer(visits) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover + elev.mean0 | ktype:bb.sp), # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                  family = "zero_inflated_poisson", # because my proportional data have zeros and ones
                  #file = "../output/brm_prop_visits_elev00",  # for running locally
                  file = "brm_prop_visits_elev00", # for running on the HPC
                  chains = 4,
                  cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("9", "10")))

# an mgcv approach
library(mgcv)
library(mgcViz)
gam_data <- prop_visits_ktype %>%
  filter(!ktype %in% c("0", "1", "9", "10") &
           bb.sp %in% c("telu", "prat", "pasc", "hort", "soro", "wurf")) %>%
  unite(pair, c(bb.sp, ktype), sep = "_", remove = FALSE) %>%
  mutate(pair = factor(pair),
         bin.visits = if_else(visits > 0, 1, 0))

ggplot(gam_data, aes(elev.mean, bin.visits)) +
  geom_point() +
  geom_smooth() +
  facet_grid(ktype~bb.sp)

gam_pvis_elev00 <- gam(as.integer(visits) ~ s(elev.mean0, pair, bs = "fs") +
                         bb.sp.abund*perc.flower.cover,
                       family = "ziP",
                       method = "REML",
                       #discrete = TRUE,
                       data = gam_data) %>% getViz()

summary(gam_pvis_elev00)
check.gamViz(gam_pvis_elev00)
plot.gamViz(gam_pvis_elev00)
plot(gam_pvis_elev00)

gam_pvis_elev01 <- gam(as.integer(visits) ~ s(elev.mean0, by = ktype, k = 4) +
                         #s(elev.mean0, by = pair, k = 4) +
                         bb.sp.abund*perc.flower.cover,
                       family = "poisson",
                       method = "REML",
                      # discrete = TRUE,
                       data = filter(gam_data, bb.sp %in% c("soro", "wurf", "hort", 
                                                            "telu", "pasc", "prat"))) %>% getViz()

summary(gam_pvis_elev01)
check.gamViz(gam_pvis_elev01)
print(plot.gamViz(gam_pvis_elev01, allTerms = TRUE), pages = 6)

gam_pvis_elev02 <- bam(bin.visits ~ 
                         s(elev.mean0, by = pair, k = 4) +
                         s(bb.sp.abund, perc.flower.cover),
                       family = "binomial",
                       method = "fREML",
                       discrete = TRUE,
                       data = filter(gam_data, bb.sp %in% c("soro", "wurf", "hort", 
                                                            "telu", "pasc", "prat"))) %>% getViz()

summary(gam_pvis_elev02)
check.gamViz(gam_pvis_elev02)
plot.gamViz(gam_pvis_elev02, allTerms = TRUE)
```

# 3. Effects of bias

## 3.1 Relationship between bias(d') and niche overlap
### 3.1.1 A function for calculating niche overlap
Niche overlap (Horn's distance) is first calculated for each species pair and each site-date. Naturally, site-dates in which only one BB species was observed return empty niche overlap matrices and so are excluded from further analysis.  
```{r}
# Niche overlap by sp.pair * site * year
niche_overlapper <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  no1 <- x %>%
    group_by(bb.sp, !!criterion, site, date) %>% # group by site-year and BB-FL pair
    summarize(visits = sum(visits)) %>%
    group_by(bb.sp, site, date) %>% # group by site-year and BB species
    mutate(prop.visits = visits/sum(visits)) %>% # get proportional interaction frequency for each BB-FL pair
    select(site, date, bb.sp, !!criterion, prop.visits) %>%
    pivot_wider(names_from = !!criterion, values_from = prop.visits, values_fill = 0) %>% # spread into the kind of array vegan likes
    group_by(site, date) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           richness = map(data, function(x) length(x$bb.sp)),
           dist = map(data2, function(x) vegdist(x, method = "jaccard")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    #dplyr::select(site, date, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>%
    rename(bb.sp1 = item1, bb.sp2 = item2) %>%
    mutate(niche.overlap = 1-distance,  # express niche overlap so that 1 = perfect overlap and 0 = no overlap
           telu = if_else(bb.sp1 == "telu" | bb.sp2 == "telu", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           humi = if_else(bb.sp1 == "humi" | bb.sp2 == "humi", TRUE, FALSE),
           muci = if_else(bb.sp1 == "muci" | bb.sp2 == "muci", TRUE, FALSE),
           pyre = if_else(bb.sp1 == "pyre" | bb.sp2 == "pyre", TRUE, FALSE),
           mont = if_else(bb.sp1 == "mont" | bb.sp2 == "mont", TRUE, FALSE),
           mend = if_else(bb.sp1 == "mend" | bb.sp2 == "mend", TRUE, FALSE),
           psit = if_else(bb.sp1 == "psit" | bb.sp2 == "psit", TRUE, FALSE),
           gers = if_else(bb.sp1 == "gers" | bb.sp2 == "gers", TRUE, FALSE),
           jone = if_else(bb.sp1 == "jone" | bb.sp2 == "jone", TRUE, FALSE),
           hypn = if_else(bb.sp1 == "hypn" | bb.sp2 == "hypn", TRUE, FALSE),
           lapi = if_else(bb.sp1 == "lapi" | bb.sp2 == "lapi", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE))
}

# Aggregating over site
niche_overlapper2 <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  no1 <- x %>%
    group_by(bb.sp, !!criterion, site) %>% # group by site-year and BB-FL pair
    summarize(visits = sum(visits)) %>%
    group_by(bb.sp, site) %>% # group by site-year and BB species
    mutate(prop.visits = visits/sum(visits)) %>% # get proportional interaction frequency for each BB-FL pair
    select(site, bb.sp, !!criterion, prop.visits) %>%
    pivot_wider(names_from = !!criterion, values_from = prop.visits, values_fill = 0) %>% # spread into the kind of array vegan likes
    group_by(site) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           richness = map(data, function(x) length(x$bb.sp)),
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    #dplyr::select(site, date, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>%
    rename(bb.sp1 = item1, bb.sp2 = item2) %>%
    mutate(niche.overlap = 1-distance,  # express niche overlap so that 1 = perfect overlap and 0 = no overlap
           telu = if_else(bb.sp1 == "telu" | bb.sp2 == "telu", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           humi = if_else(bb.sp1 == "humi" | bb.sp2 == "humi", TRUE, FALSE),
           muci = if_else(bb.sp1 == "muci" | bb.sp2 == "muci", TRUE, FALSE),
           pyre = if_else(bb.sp1 == "pyre" | bb.sp2 == "pyre", TRUE, FALSE),
           mont = if_else(bb.sp1 == "mont" | bb.sp2 == "mont", TRUE, FALSE),
           mend = if_else(bb.sp1 == "mend" | bb.sp2 == "mend", TRUE, FALSE),
           psit = if_else(bb.sp1 == "psit" | bb.sp2 == "psit", TRUE, FALSE),
           gers = if_else(bb.sp1 == "gers" | bb.sp2 == "gers", TRUE, FALSE),
           jone = if_else(bb.sp1 == "jone" | bb.sp2 == "jone", TRUE, FALSE),
           hypn = if_else(bb.sp1 == "hypn" | bb.sp2 == "hypn", TRUE, FALSE),
           lapi = if_else(bb.sp1 == "lapi" | bb.sp2 == "lapi", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE))
}

niche_overlapper3 <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  no1 <- x %>%
    group_by(bb.sp, !!criterion, site) %>% # group by site-year and BB-FL pair
    summarize(visits = sum(visits)) %>%
    group_by(site, bb.sp) %>%
    mutate(prop.visits = visits/sum(visits)) %>%
    select(site, bb.sp, !!criterion, prop.visits) %>%
    pivot_wider(names_from = !!criterion, values_from = prop.visits, values_fill = 0) %>% # spread into the kind of array vegan likes
    group_by(site) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           richness = map(data, function(x) length(x$bb.sp)),
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    #dplyr::select(site, date, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>%
    rename(bb.sp1 = item1, bb.sp2 = item2) %>%
    mutate(niche.overlap = 1-distance,  # express niche overlap so that 1 = perfect overlap and 0 = no overlap
           telu = if_else(bb.sp1 == "telu" | bb.sp2 == "telu", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           humi = if_else(bb.sp1 == "humi" | bb.sp2 == "humi", TRUE, FALSE),
           muci = if_else(bb.sp1 == "muci" | bb.sp2 == "muci", TRUE, FALSE),
           pyre = if_else(bb.sp1 == "pyre" | bb.sp2 == "pyre", TRUE, FALSE),
           mont = if_else(bb.sp1 == "mont" | bb.sp2 == "mont", TRUE, FALSE),
           mend = if_else(bb.sp1 == "mend" | bb.sp2 == "mend", TRUE, FALSE),
           psit = if_else(bb.sp1 == "psit" | bb.sp2 == "psit", TRUE, FALSE),
           gers = if_else(bb.sp1 == "gers" | bb.sp2 == "gers", TRUE, FALSE),
           jone = if_else(bb.sp1 == "jone" | bb.sp2 == "jone", TRUE, FALSE),
           hypn = if_else(bb.sp1 == "hypn" | bb.sp2 == "hypn", TRUE, FALSE),
           lapi = if_else(bb.sp1 == "lapi" | bb.sp2 == "lapi", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE))
}
```

### 3.1.2 My first question is how niche overlap compares across species pairs
#### 3.1.2.1 Calculate pairwise niche overlap
```{r}
# Get bb.sp abundances; this time without filtering out the sites without matching floral data
bb_abundance2 <-  read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  group_by(site, date, bb.sp, plant.sp) %>%
  summarize(visits = n()) %>%
  group_by(site, date, bb.sp) %>%
  summarize(bb.sp.abund = sum(visits)) %>%
  group_by(site, date) %>%
  mutate(bb.sp.prop.abund = bb.sp.abund/sum(bb.sp.abund))

bb_abundance2_agg <-  read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  group_by(site, bb.sp, plant.sp) %>%
  summarize(visits = n()) %>%
  group_by(site, bb.sp) %>%
  summarize(bb.sp.abund = sum(visits)) %>%
  group_by(site) %>%
  mutate(bb.sp.prop.abund = bb.sp.abund/sum(bb.sp.abund))

# Un-aggregated niche overlap per species pair per site-date
niche_overlap <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  group_by(site, date, bb.sp, plant.sp) %>%
  summarize(visits = n()) %>%
  niche_overlapper(plant.sp) %>%
  mutate(yday = yday(date)) %>%
  left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>%
  rename(pbl.w.class2_sp1 = pbl.w.class2) %>%
  left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>%
  rename(pbl.w.class2_sp2 = pbl.w.class2) %>%
  mutate(same.class = case_when(
    pbl.w.class2_sp1 == "short" & pbl.w.class2_sp2 == "short" ~ "short:short",
    pbl.w.class2_sp1 == "med" & pbl.w.class2_sp2 == "med" ~ "med:med",
    pbl.w.class2_sp1 == "long" & pbl.w.class2_sp2 == "long" ~ "long:long",
    pbl.w.class2_sp1 == "short" & pbl.w.class2_sp2 == "med" ~ "short:med",
    pbl.w.class2_sp1 == "med" & pbl.w.class2_sp2 == "short" ~ "short:med",
    pbl.w.class2_sp1 == "short" & pbl.w.class2_sp2 == "long" ~ "short:long",
    pbl.w.class2_sp1 == "long" & pbl.w.class2_sp2 == "short" ~ "short:long",
    pbl.w.class2_sp1 == "med" & pbl.w.class2_sp2 == "long" ~ "med:long",
    pbl.w.class2_sp1 == "long" & pbl.w.class2_sp2 == "med" ~ "med:long")
    ) %>%
  left_join(bb_abundance2, by = c("site", "date", "bb.sp1" = "bb.sp")) %>%
  rename(bb.sp1.abund = bb.sp.abund) %>%
  left_join(bb_abundance2, by = c("site", "date", "bb.sp2" = "bb.sp")) %>%
  rename(bb.sp2.abund = bb.sp.abund) %>%
  unite(sp.pair, c(bb.sp1, bb.sp2), sep = "_", remove = FALSE) %>%
  left_join(site_data) %>%
  mutate(yday = yday(date)) %>%
  select(site, date, yday, elev.mean, sp.pair, bb.sp1, bb.sp2, bb.sp1.abund, 
         bb.sp2.abund, niche.overlap, same.class) %>%
  mutate(log.bb.sp1.abund = log(bb.sp1.abund),
         log.bb.sp2.abund = log(bb.sp2.abund))

write_csv(niche_overlap, "../hpc_packets/niche_overlap.csv")

# # Aggregated niche overlap per species pair per site
# niche_overlap2 <- read_csv("../data/processed_data/network.csv") %>%
#   filter(caste != "male") %>% # we will ignore males 
#   group_by(site, bb.sp, plant.sp) %>%
#   summarize(visits = n()) %>%
#   niche_overlapper2(plant.sp) %>%
#   left_join(bb_traits, by = c("bb.sp1" = "bb.sp")) %>%
#   rename(pbl.w.class2_sp1 = pbl.w.class2) %>%
#   left_join(bb_traits, by = c("bb.sp2" = "bb.sp")) %>%
#   rename(pbl.w.class2_sp2 = pbl.w.class2) %>%
#   mutate(same.class = case_when(
#     pbl.w.class2_sp1 == "short" & pbl.w.class2_sp2 == "short" ~ "short:short",
#     pbl.w.class2_sp1 == "med" & pbl.w.class2_sp2 == "med" ~ "med:med",
#     pbl.w.class2_sp1 == "long" & pbl.w.class2_sp2 == "long" ~ "long:long",
#     pbl.w.class2_sp1 == "short" & pbl.w.class2_sp2 == "med" ~ "short:med",
#     pbl.w.class2_sp1 == "med" & pbl.w.class2_sp2 == "short" ~ "short:med",
#     pbl.w.class2_sp1 == "short" & pbl.w.class2_sp2 == "long" ~ "short:long",
#     pbl.w.class2_sp1 == "long" & pbl.w.class2_sp2 == "short" ~ "short:long",
#     pbl.w.class2_sp1 == "med" & pbl.w.class2_sp2 == "long" ~ "med:long",
#     pbl.w.class2_sp1 == "long" & pbl.w.class2_sp2 == "med" ~ "med:long")
#     ) %>%
#   left_join(bb_abundance2_agg, by = c("site", "bb.sp1" = "bb.sp")) %>%
#   rename(bb.sp1.abund = bb.sp.abund) %>%
#   left_join(bb_abundance2_agg, by = c("site", "bb.sp2" = "bb.sp")) %>%
#   rename(bb.sp2.abund = bb.sp.abund) %>%
#   unite(sp.pair, c(bb.sp1, bb.sp2), sep = "_", remove = FALSE) %>%
#   mutate(site = factor(site)) %>%
#   select(site, bb.sp1, bb.sp2, sp.pair, niche.overlap, same.class, bb.sp1.abund, bb.sp2.abund) %>%
#   left_join(site_data) %>%
#   ungroup() %>%
#   mutate(elev0 = scale(elev.mean)) %>%
#   select(site, elev0, sp.pair, bb.sp1, bb.sp2, bb.sp1.abund, 
#          bb.sp2.abund, niche.overlap, same.class) %>%
#   mutate(log.bb.sp1.abund = log(bb.sp1.abund),
#          log.bb.sp2.abund = log(bb.sp2.abund))

write_csv(niche_overlap2, "../hpc_packets/niche_overlap2.csv")
```

#### 3.1.2.2 Preliminary visualization
```{r}
# Not aggregated
ggplot(niche_overlap, aes(niche.overlap)) +
  geom_histogram()

ggplot(niche_overlap, aes(niche.overlap)) +
  geom_histogram() +
  facet_wrap(~sp.pair)

ggplot(niche_overlap, aes(sp.pair, niche.overlap)) +
  geom_boxplot() +
  facet_wrap(~same.class)

ggplot(niche_overlap, aes(same.class, niche.overlap)) +
  geom_boxplot() 
  

# Aggregate by site
ggplot(niche_overlap2, aes(niche.overlap)) +
  geom_histogram()

ggplot(niche_overlap2, aes(niche.overlap)) +
  geom_histogram() +
  facet_wrap(~sp.pair)
```

#### 3.1.2.3 brms model ... still a mess
```{r}
# Not aggregated
brm_niche10 <- brm(niche.overlap ~ log.bb.sp1.abund*log.bb.sp2.abund + 
                     (1 | sp.pair) + 
                     (1 | same.class) + 
                     (1 | site),
                   family = "zero_one_inflated_beta",
                   chains = 4,
                   cores = 4,
                   iter = 2000,
                   #file = "../output/brm_niche10",
                   file = "./brm_niche10",
                   data = niche_overlap)
```

#### 3.2.2.4 Plot model
```{r}
## Sp.pair and same class, for convenience
sp_pair_class <- niche_overlap2 %>%
  ungroup() %>%
  select(sp.pair, same.class) %>%
  distinct()
  
## Tongue length combos
brm_niche61_plotframe1 <- brm_niche61 %>%
  spread_draws(b_Intercept, r_same.class[condition, term]) %>% 
  mutate(condition_mean = b_Intercept + r_same.class) 

ggplot(brm_niche61_plotframe1, aes(condition_mean, reorder(condition, condition_mean))) +
  stat_halfeye() +
  ylab("Tongue length combination") +
  xlab("Niche overlap")

ggsave(file = "../output/brm_niche61_plot1.png", width = 7, height = 5.5)

## Species pairs
brm_niche61_plotframe2 <- brm_niche61 %>%
  spread_draws(b_Intercept, r_sp.pair[condition, term]) %>% 
  mutate(condition_mean = b_Intercept + r_sp.pair) %>%
  left_join(sp_pair_class, by = c("condition" = "sp.pair"))

ggplot(brm_niche61_plotframe2, aes(condition_mean, 
                                   reorder(condition, condition_mean), 
                                   color = same.class)) +
  stat_pointinterval() +
  ylab("Species pair") +
  xlab("Niche overlap")

ggsave(file = "../output/brm_niche61_plot1.png", width = 7, height = 5.5)
```

### 3.1.3 Now I'd be interested to know how niche overlap relates to dprime
```{r}
niche_overlap_bias <- niche_overlap %>%
  inner_join(bias, by = c("site", "date", c("bb.sp1" = "bb.sp"))) %>%
  rename(dprime.sp1 = dprime.sp) %>%
  inner_join(bias, by = c("site", "date", c("bb.sp2" = "bb.sp"))) %>%
  rename(dprime.sp2 = dprime.sp) %>%
  select(site, date, sp.pair, bb.sp1, bb.sp2, bb.sp1.abund, bb.sp2.abund, 
         dprime.sp1, dprime.sp2, niche.overlap, same.class)

niche_overlap_bias2 <- niche_overlap %>%
  inner_join(bias2, by = c("site", "date", c("bb.sp1" = "bb.sp"))) %>%
  rename(dprime.sp1 = dprime.sp) %>%
  inner_join(bias, by = c("site", "date", c("bb.sp2" = "bb.sp"))) %>%
  rename(dprime.sp2 = dprime.sp) %>%
  select(site, date, sp.pair, bb.sp1, bb.sp2, bb.sp1.abund, bb.sp2.abund, 
         dprime.sp1, dprime.sp2, niche.overlap, same.class)

ggplot(niche_overlap_bias, aes(dprime.sp1, dprime.sp2, color = niche.overlap)) +
  geom_point() 

ggplot(niche_overlap_bias, aes(log(bb.sp1.abund), log(bb.sp2.abund), color = niche.overlap)) +
  geom_point() 


# When bias is high, it could mean that there are few good options on which all (or many) BB species converge. But apparently it doesn't. When bias is high, BB spp are biased toward DIFFERENT flora, and thus their niches diverge. 
ggplot(niche_overlap_bias, aes(dprime.sp, mean.niche.overlap)) +
  geom_point(alpha = 0.1) +
  geom_smooth(method = "lm") +
  #geom_smooth(method = "gam", formula = y ~ s(x, k = 5), se = TRUE) +
  facet_wrap(~sp.pair) +
  ylim(c(0,1))

brm.bias_niche <- brm(mean.niche.overlap ~ dprime.sp + (1 + dprime.sp | bb.sp) + (1 + dprime.sp | site),
                     cores = 4,
                     chains = 4,
                     iter = 2000,
                     file = "../output/brm_bias_nicheoverlap",
                     data = bias_nicheoverlap)

parnames(brm.bias_niche)
conditional_effects(brm.bias_niche)
mcmc_plot(brm.bias_niche, pars = c("^r_"))
hypothesis(brm.bias_niche, "dprime = 0")
pp_check(brm.bias_niche)
bayes_R2(brm.bias_niche)


brm.dprime_niche00 <- brm(mean.niche.overlap ~ dprime.sp + (1 | bb.sp) + (1 | site),
                     cores = 4,
                     chains = 4,
                     iter = 2000,
                     file = "../output/brm_bias_niche00",
                     data = bias_nicheoverlap)

parnames(brm.dprime_niche00)
conditional_effects(brm.dprime_niche00)
mcmc_plot(brm.dprime_niche00, pars = c("^r_bb"))
mcmc_plot(brm.dprime_niche00, pars = c("^b_"))
hypothesis(brm.dprime_niche00, "dprime = 0")
pp_check(brm.dprime_niche00)
bayes_R2(brm.dprime_niche00)
```

## 3.2 Ordination of dietary niche
Aggregation changes meaning. Don't forget that. When I pool visitation across dates, I am introducing the effects of relative abundance and floral phenology. Species in bloom when BB abundance is high will be over-represented, and vice-versa. And species with a long bloom time will be over-represented, and vice-versa. This isn't necessarily a problem. I just need to make sure I interpret the results the right way. When I pool data like this, I am comparing the "net" diet of species, which includes the effects of abundance and phenology in addition to the effects of floral preferences. I think that is appropriate for this stage of the analysis, but I need to be careful not to assume that what I'm doing here is the same sort of analysis as what I did above without pooling samples. 

### 3.2.1 Fully pooled
```{r}
# Fl traits with abbreviated names
fl_traits2 <- fl_traits %>%
  left_join(read_csv("../data/processed_data/network.csv")) %>%
  select(plant.sp, plant.sp.abb, plant.genus, plant.family, k.type.ss, color) %>%
  mutate(k.type.ss = factor(k.type.ss)) %>%
  distinct()

# Totally aggregated; note I'm using the full data, not the aligned and trimmed data. No need for complementary floral survey data.
visitation2 <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  filter(!bb.sp %in% c("humi")) %>% # humi is too rare
  group_by(bb.sp, plant.sp.abb) %>%
  summarize(visits = n()) %>%
  group_by(bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  select(-visits) %>%
  pivot_wider(names_from = plant.sp.abb, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

# Generate ordination
pcoa_horn2 <- capscale(visitation2 ~ 1, distance = "horn")

# Get variance explained
pcoa_horn2_mds1 <- round(pcoa_horn2$CA$eig[[1]] / sum(pcoa_horn2$CA$eig)*100)
pcoa_horn2_mds2 <- round(pcoa_horn2$CA$eig[[2]] / sum(pcoa_horn2$CA$eig)*100)

# Fortify plants
pcoa_horn2.fort1 <- fortify(pcoa_horn2, axes = 1:2) %>%
  filter(Score == "species") %>%
  rename(plant.sp.abb = Label) %>%
  left_join(fl_traits2)

# Fortify bees
pcoa_horn2.fort2 <- fortify(pcoa_horn2, axes = 1:2) %>%
  filter(Score == "sites") %>%
  rename(bb.sp = Label) %>%
  left_join(bb_traits) %>%
  mutate(pbl.w.class2 = factor(pbl.w.class2)) 

# Generate convex hulls around tongue length classes
pcoa_horn2_hulls <- pcoa_horn2.fort2 %>%
  group_by(pbl.w.class2) %>%
  slice(chull(MDS1, MDS2))
  
# Plot
ggplot(pcoa_horn2.fort2, aes(MDS1, MDS2, color = pbl.w.class2)) +
  geom_polygon(data = pcoa_horn2_hulls, 
               aes(fill = pbl.w.class2, color = NULL),
               alpha = 0.25) +
  geom_text(aes(label = bb.sp), key_glyph = "rect") +
  geom_text_repel(data = filter(pcoa_horn2.fort1, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2), 
            aes(MDS1, MDS2, label = plant.sp.abb), inherit.aes = FALSE, color = "gray40") +
  geom_point(data = filter(pcoa_horn2.fort1, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2),
            aes(MDS1, MDS2, shape = k.type.ss), inherit.aes = FALSE, color = "gray40", size = 3) +
  scale_shape_discrete() +
  xlab(paste("MDS1 ", "(", pcoa_horn2_mds1, "%", ")", sep = "")) +
  ylab(paste("MDS2 ", "(", pcoa_horn2_mds2, "%", ")", sep = "")) +
  labs(fill = "Tongue length", 
       shape = "Morphotype") +
  guides(color = FALSE) +
  coord_fixed() +
  theme_light(10)

ggsave("../output/pcoa_aggregate.png")
```

### 3.2.1 Pooled within elev.class2
```{r}
# Get visitation
visitation_low <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  filter(!bb.sp %in% c("humi")) %>% # humi is too rare
  left_join(site_data) %>%
  filter(elev.class2 == "low") %>%
  group_by(bb.sp, plant.sp.abb) %>%
  summarize(visits = n()) %>%
  group_by(bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  select(-visits) %>%
  pivot_wider(names_from = plant.sp.abb, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

visitation_mid <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  filter(!bb.sp %in% c("humi")) %>% # humi is too rare
  left_join(site_data) %>%
  filter(elev.class2 == "mid") %>%
  group_by(bb.sp, plant.sp.abb) %>%
  summarize(visits = n()) %>%
  group_by(bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  select(-visits) %>%
  pivot_wider(names_from = plant.sp.abb, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

visitation_high <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  filter(!bb.sp %in% c("humi")) %>% # humi is too rare
  left_join(site_data) %>%
  filter(elev.class2 == "high") %>%
  group_by(bb.sp, plant.sp.abb) %>%
  summarize(visits = n()) %>%
  group_by(bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  select(-visits) %>%
  pivot_wider(names_from = plant.sp.abb, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

# Generate ordination
pcoa_horn_low <- capscale(visitation_low ~ 1, distance = "horn")
pcoa_horn_mid <- capscale(visitation_mid ~ 1, distance = "horn")
pcoa_horn_high <- capscale(visitation_high ~ 1, distance = "horn")

# Get variance explained
pcoa_horn_low_mds1 <- round(pcoa_horn_low$CA$eig[[1]] / sum(pcoa_horn_low$CA$eig)*100)
pcoa_horn_low_mds2 <- round(pcoa_horn_low$CA$eig[[2]] / sum(pcoa_horn_low$CA$eig)*100)

pcoa_horn_mid_mds1 <- round(pcoa_horn_mid$CA$eig[[1]] / sum(pcoa_horn_mid$CA$eig)*100)
pcoa_horn_mid_mds2 <- round(pcoa_horn_mid$CA$eig[[2]] / sum(pcoa_horn_mid$CA$eig)*100)

pcoa_horn_high_mds1 <- round(pcoa_horn_high$CA$eig[[1]] / sum(pcoa_horn_high$CA$eig)*100)
pcoa_horn_high_mds2 <- round(pcoa_horn_high$CA$eig[[2]] / sum(pcoa_horn_high$CA$eig)*100)

# Fortify plants
pcoa_horn.fort1_low <- fortify(pcoa_horn_low, axes = 1:2) %>%
  filter(Score == "species") %>%
  rename(plant.sp.abb = Label) %>%
  left_join(fl_traits2)

pcoa_horn.fort1_mid <- fortify(pcoa_horn_mid, axes = 1:2) %>%
  filter(Score == "species") %>%
  rename(plant.sp.abb = Label) %>%
  left_join(fl_traits2)

pcoa_horn.fort1_high <- fortify(pcoa_horn_high, axes = 1:2) %>%
  filter(Score == "species") %>%
  rename(plant.sp.abb = Label) %>%
  left_join(fl_traits2)

# Fortify bees
pcoa_horn.fort2_low <- fortify(pcoa_horn_low, axes = 1:2) %>%
  filter(Score == "sites") %>%
  rename(bb.sp = Label) %>%
  left_join(bb_traits) %>%
  mutate(pbl.w.class2 = factor(pbl.w.class2))

pcoa_horn.fort2_mid <- fortify(pcoa_horn_mid, axes = 1:2) %>%
  filter(Score == "sites") %>%
  rename(bb.sp = Label) %>%
  left_join(bb_traits) %>%
  mutate(pbl.w.class2 = factor(pbl.w.class2))

pcoa_horn.fort2_high <- fortify(pcoa_horn_high, axes = 1:2) %>%
  filter(Score == "sites") %>%
  rename(bb.sp = Label) %>%
  left_join(bb_traits) %>%
  mutate(pbl.w.class2 = factor(pbl.w.class2))

# Generate convex hulls around tongue length classes
pcoa_horn_hulls_low <- pcoa_horn.fort2_low %>%
  group_by(pbl.w.class2) %>%
  slice(chull(MDS1, MDS2))
  
pcoa_horn_hulls_mid <- pcoa_horn.fort2_mid %>%
  group_by(pbl.w.class2) %>%
  slice(chull(MDS1, MDS2))
  
pcoa_horn_hulls_high <- pcoa_horn.fort2_high %>%
  group_by(pbl.w.class2) %>%
  slice(chull(MDS1, MDS2))
  
# Plot
ggplot(pcoa_horn.fort2_low, aes(MDS1, MDS2, color = pbl.w.class2)) +
  geom_polygon(data = pcoa_horn_hulls_low, 
               aes(fill = pbl.w.class2, color = NULL),
               alpha = 0.25) +
  geom_text(aes(label = bb.sp), key_glyph = "rect") +
  geom_text_repel(data = filter(pcoa_horn.fort1_low, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2), 
            aes(MDS1, MDS2, label = plant.sp.abb), inherit.aes = FALSE, color = "gray40") +
  geom_point(data = filter(pcoa_horn.fort1_low, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2),
            aes(MDS1, MDS2, shape = k.type.ss), inherit.aes = FALSE, color = "gray40", size = 3) +
  scale_shape_discrete() +
  xlab(paste("MDS1 ", "(", pcoa_horn_low_mds1, "%", ")", sep = "")) +
  ylab(paste("MDS2 ", "(", pcoa_horn_low_mds2, "%", ")", sep = "")) +
  labs(fill = "Tongue length", 
       shape = "Morphotype") +
  guides(color = FALSE) +
  coord_fixed() +
  theme_light(10)

ggplot(pcoa_horn.fort2_mid, aes(MDS1, MDS2, color = pbl.w.class2)) +
  geom_polygon(data = pcoa_horn_hulls_mid, 
               aes(fill = pbl.w.class2, color = NULL),
               alpha = 0.25) +
  geom_text(aes(label = bb.sp), key_glyph = "rect") +
  geom_text_repel(data = filter(pcoa_horn.fort1_mid, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2), 
            aes(MDS1, MDS2, label = plant.sp.abb), inherit.aes = FALSE, color = "gray40") +
  geom_point(data = filter(pcoa_horn.fort1_mid, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2),
            aes(MDS1, MDS2, shape = k.type.ss), inherit.aes = FALSE, color = "gray40", size = 3) +
  scale_shape_discrete() +
  xlab(paste("MDS1 ", "(", pcoa_horn_mid_mds1, "%", ")", sep = "")) +
  ylab(paste("MDS2 ", "(", pcoa_horn_mid_mds2, "%", ")", sep = "")) +
  labs(fill = "Tongue length", 
       shape = "Morphotype") +
  guides(color = FALSE) +
  coord_fixed() +
  theme_light(10)

ggplot(pcoa_horn.fort2_high, aes(MDS1, MDS2, color = pbl.w.class2)) +
  geom_polygon(data = pcoa_horn_hulls_high, 
               aes(fill = pbl.w.class2, color = NULL),
               alpha = 0.25) +
  geom_text(aes(label = bb.sp), key_glyph = "rect") +
  geom_text_repel(data = filter(pcoa_horn.fort1_high, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2), 
            aes(MDS1, MDS2, label = plant.sp.abb), inherit.aes = FALSE, color = "gray40") +
  geom_point(data = filter(pcoa_horn.fort1_high, abs(MDS1) >= 0.2 | abs(MDS2) >= 0.2),
            aes(MDS1, MDS2, shape = k.type.ss), inherit.aes = FALSE, color = "gray40", size = 3) +
  scale_shape_discrete() +
  xlab(paste("MDS1 ", "(", pcoa_horn_high_mds1, "%", ")", sep = "")) +
  ylab(paste("MDS2 ", "(", pcoa_horn_high_mds2, "%", ")", sep = "")) +
  labs(fill = "Tongue length", 
       shape = "Morphotype") +
  guides(color = FALSE) +
  coord_fixed() +
  theme_light(10)


ggsave("../output/pcoa_aggregate.png")
```



```{r}
# Totally aggregated
visitation2 <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  filter(!bb.sp %in% c("humi")) %>% # humi is too rare
  group_by(bb.sp, plant.sp) %>%
  summarize(visits = n()) %>%
  group_by(bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  select(-visits) %>%
  pivot_wider(names_from = plant.sp, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

# Ordinated separately by site
visitation3 <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  filter(!bb.sp %in% c("humi")) %>% # humi is too rare
  group_by(site, bb.sp, plant.sp) %>%
  summarize(visits = n()) %>%
  group_by(site, bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  select(-visits) %>%
  group_by(site) %>%
  nest() %>%
  mutate(data2 = map(data, 
                     function(x) pivot_wider(x, 
                                             names_from = plant.sp, 
                                             values_from = prop.visits, 
                                             values_fill = 0)),
         data3 = map(data2, function(x) column_to_rownames(x, "bb.sp")),
         pcoa = map(data3, function(x) capscale(x ~ 1, distance = "horn")),
         pcoa_quickplot = map(pcoa, function(x) plot(x, type = "t"))) 

plot(visitation3$pcoa[[1]], type = "t")
plot(visitation3$pcoa[[2]], type = "t")
plot(visitation3$pcoa[[3]], type = "t")
plot(visitation3$pcoa[[4]], type = "t")
plot(visitation3$pcoa[[5]], type = "t")
plot(visitation3$pcoa[[6]], type = "t")
plot(visitation3$pcoa[[7]], type = "t")
plot(visitation3$pcoa[[8]], type = "t")
plot(visitation3$pcoa[[9]], type = "t")
plot(visitation3$pcoa[[10]], type = "t")

  
# Aggregation 1

# Aggregation 2
pcoa_horn2 <- capscale(visitation2 ~ 1, distance = "horn")
plot(pcoa_horn2, type = "t")

pcoa_horn2.fort1 <- fortify(pcoa_horn2, axes = 1:2) %>%
  filter(Score == "species") %>%
  rename(plant.sp = Label) %>%
  left_join(fl_traits)
pcoa_horn2.fort2 <- fortify(pcoa_horn2, axes = 1:2) %>%
  filter(Score == "sites") %>%
  rename(bb.sp = Label) %>%
  left_join(bb_traits)

ggplot(pcoa_horn2.fort2, aes(MDS1, MDS2)) +
  geom_text(aes(label = bb.sp)) +
  coord_fixed()

ggplot(pcoa_horn2.fort2, aes(MDS1, MDS2)) +
  geom_text(aes(label = bb.sp, color = factor(pbl.w.class2))) +
  geom_point(aes(color = factor(pbl.w.class2))) +
  coord_fixed()

# Disaggregated
pcoa_horn <- capscale(visitation2 ~ 1, distance = "horn")
pcoa_horn.fort <- fortify(pcoa_horn, axes = 1:2)
pcoa_horn.fort1 <- pcoa_horn.fort %>%
  filter(Score == "species") %>%
  rename(plant.sp = Label) %>%
  left_join(fl_traits)
pcoa_horn.fort2 <- pcoa_horn.fort %>%
  filter(Score == "sites") %>%
  separate(Label, c("site", "date", "bb.sp"), sep = "_") %>%
  left_join(bb_traits)

ggplot(pcoa_horn.fort1, aes(MDS1, MDS2, color = factor(k.type.ss))) +
  geom_point(alpha = 0.25) +
  coord_fixed() 

ggplot(pcoa_horn.fort2, aes(MDS1, MDS2, color = factor(pbl.w.class2))) +
  geom_point(alpha = 0.5) +
  coord_fixed() 

ggplot(pcoa_horn.fort2, aes(MDS1, MDS2, color = factor(pbl.w.class2))) +
  geom_density2d() +
  coord_fixed() 











visitation3 <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste != "male") %>% # we will ignore males 
  group_by(bb.sp, plant.sp) %>%
  summarize(visits = n()) %>%
  group_by(bb.sp) %>%
  mutate(prop.visits = visits/sum(visits))

visitation_aggregate2 <- visitation2 %>%
  group_by(bb.sp, plant.sp) %>%
  summarize(mean.prop.visits = mean(prop.visits)) %>%
  pivot_wider(names_from = plant.sp, values_from = mean.prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

visitation_aggregate3 <- visitation3 %>%
  pivot_wider(names_from = plant.sp, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("bb.sp")

bb_traits2 <- bb_traits %>%
  select(bb.sp, pbl.w.class2) %>%
  arrange(bb.sp)

pcoa_horn <- capscale(visitation_aggregate ~ 1, distance = "horn")
envfit_horn <- envfit(pcoa_horn ~ pbl.w.class2, data = bb_traits2)
plot(pcoa_horn, type = "t")
plot(envfit_horn, add = TRUE)
pcoa_horn.fort <- fortify(pcoa_horn, axes = 1:2)


# What if I did not aggregate the data?
visit_cover_prop.plantsp2 <- visit_cover %>%
  filter(bb.sp %in% c("pasc", "prat", "telu", "soro", "wurf", "psit")) %>%
  select(site, date, bb.sp, plant.sp, k.type.ss, visits, flower.cover) %>%
  group_by(site, date, bb.sp) %>%
  mutate(prop.visits = visits/sum(visits)) %>%
  group_by(site, date, plant.sp) %>%
  mutate(prop.flower.cover = flower.cover/sum(flower.cover)) %>%
  unite(id, c(site, date, bb.sp), remove = TRUE) %>%
  select(id, plant.sp, prop.visits) %>%
  pivot_wider(names_from = plant.sp, values_from = prop.visits, values_fill = 0) %>%
  column_to_rownames("id")

traits <- bb_traits %>%
  filter(bb.sp %in% c("pasc", "prat", "telu", "soro", "wurf", "psit")) %>%
  select(bb.sp, pbl.w.class2) %>%
  arrange(bb.sp)

pcoa_horn2 <- capscale(visit_cover_prop.plantsp2 ~ 1, distance = "horn")
envfit_horn2 <- envfit(pcoa_horn2 ~ pbl.w.class2, data = traits)
plot(pcoa_horn2, type = "t")
plot(envfit_horn2, add = TRUE)

pcoa_horn2_fort <- fortify(pcoa_horn2) 

pcoa_horn2_plot <- pcoa_horn2_fort %>%
  filter(Score == "sites") %>%
  separate(Label, c("site", "date", "bb.sp"), sep = "_") %>%
  mutate(date = ymd(date)) %>%
  mutate(yday = yday(date))

ggplot(pcoa_horn2_plot, aes(MDS1, MDS2, color = bb.sp)) +
  geom_point() +
  coord_fixed() 

ggplot(pcoa_horn2_plot, aes(MDS1, MDS2, color = yday)) +
  geom_point() +
  coord_fixed() 
```

# Trash can

```{r}
niche_overlapper <- function(x, criterion) {
    
  criterion <- enquo(criterion) # criterion is set to either plant.sp (for taxonomic) or k.type.s (for morphological)
  
  no1 <- x %>%
    group_by(bb.sp, !!criterion, site, date) %>% # group by site-year and BB-FL pair
    summarize(visits = sum(visits)) %>%
    group_by(bb.sp, site, date) %>% # group by site-year and BB species
    mutate(prop.visits = visits/sum(visits)) %>% # get proportional interaction frequency for each BB-FL pair
    select(site, date, bb.sp, !!criterion, prop.visits) %>%
    pivot_wider(names_from = !!criterion, values_from = prop.visits, values_fill = 0) %>% # spread into the kind of array vegan likes
    group_by(site, date) %>%
    nest() %>% # nest into list-column
    mutate(data2 = map(data, function(x) column_to_rownames(x, var = "bb.sp")), # column to rownames
           richness = map(data, function(x) length(x$bb.sp)),
           dist = map(data2, function(x) vegdist(x, method = "horn")), # convert to Horn's distance matrix
           tidy_dist = map(dist, tidy)) %>% # convert to tidy array of Horn's distances
    #dplyr::select(site, date, tidy_dist) %>% # drop intermediate list-columns
    unnest(cols = c(tidy_dist)) %>%
    rename(bb.sp1 = item1, bb.sp2 = item2) %>%
    mutate(niche.overlap = 1-distance,  # express niche overlap so that 1 = perfect overlap and 0 = no overlap
           telu = if_else(bb.sp1 == "telu" | bb.sp2 == "telu", TRUE, FALSE),
           pasc = if_else(bb.sp1 == "pasc" | bb.sp2 == "pasc", TRUE, FALSE),
           wurf = if_else(bb.sp1 == "wurf" | bb.sp2 == "wurf", TRUE, FALSE),
           prat = if_else(bb.sp1 == "prat" | bb.sp2 == "prat", TRUE, FALSE),
           soro = if_else(bb.sp1 == "soro" | bb.sp2 == "soro", TRUE, FALSE),
           humi = if_else(bb.sp1 == "humi" | bb.sp2 == "humi", TRUE, FALSE),
           muci = if_else(bb.sp1 == "muci" | bb.sp2 == "muci", TRUE, FALSE),
           pyre = if_else(bb.sp1 == "pyre" | bb.sp2 == "pyre", TRUE, FALSE),
           mont = if_else(bb.sp1 == "mont" | bb.sp2 == "mont", TRUE, FALSE),
           mend = if_else(bb.sp1 == "mend" | bb.sp2 == "mend", TRUE, FALSE),
           psit = if_else(bb.sp1 == "psit" | bb.sp2 == "psit", TRUE, FALSE),
           gers = if_else(bb.sp1 == "gers" | bb.sp2 == "gers", TRUE, FALSE),
           jone = if_else(bb.sp1 == "jone" | bb.sp2 == "jone", TRUE, FALSE),
           hypn = if_else(bb.sp1 == "hypn" | bb.sp2 == "hypn", TRUE, FALSE),
           lapi = if_else(bb.sp1 == "lapi" | bb.sp2 == "lapi", TRUE, FALSE),
           hort = if_else(bb.sp1 == "hort" | bb.sp2 == "hort", TRUE, FALSE))
  
  no <- list(
    
  no_telu <- no1 %>%
    group_by(site, date, telu) %>% 
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%
    mutate(bb.sp = rep("telu", n())) %>%
    filter(telu == TRUE),
  
  no_pasc <- no1 %>%
    group_by(site, date, pasc) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("pasc", n())) %>%
    filter(pasc == TRUE),
  
  no_wurf <- no1 %>%
    group_by(site, date, wurf) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("wurf", n())) %>%
    filter(wurf == TRUE),
  
  no_prat <- no1 %>%
    group_by(site, date, prat) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%   
    mutate(bb.sp = rep("prat", n())) %>%
    filter(prat == TRUE),
  
  no_soro <- no1 %>%
    group_by(site, date, soro) %>% 
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("soro", n())) %>%
    filter(soro == TRUE),
  
  no_humi <- no1 %>%
    group_by(site, date, humi) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("humi", n())) %>%
    filter(humi == TRUE),
  
  no_muci <- no1 %>%
    group_by(site, date, muci) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("muci", n())) %>%
    filter(muci == TRUE),
  
  no_pyre <- no1 %>%
    group_by(site, date, pyre) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%   
    mutate(bb.sp = rep("pyre", n())) %>%
    filter(pyre == TRUE),
  
  no_mont <- no1 %>%
    group_by(site, date, mont) %>% 
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("mont", n())) %>%
    filter(mont == TRUE),
  
  no_mend <- no1 %>%
    group_by(site, date, mend) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("mend", n())) %>%
    filter(mend == TRUE),
  
  no_psit <- no1 %>%
    group_by(site, date, psit) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("psit", n())) %>%
    filter(psit == TRUE),
  
  no_gers <- no1 %>%
    group_by(site, date, gers) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("gers", n())) %>%
    filter(gers == TRUE),
  
  no_jone <- no1 %>%
    group_by(site, date, jone) %>% 
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("jone", n())) %>%
    filter(jone == TRUE),
  
  no_hypn <- no1 %>%
    group_by(site, date, hypn) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("hypn", n())) %>%
    filter(hypn == TRUE),
  
  no_lapi <- no1 %>%
    group_by(site, date, lapi) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("lapi", n())) %>%
    filter(lapi == TRUE),
  
  no_hort <- no1 %>%
    group_by(site, date, hort) %>%
    summarize(mean.niche.overlap = mean(niche.overlap),
              max.niche.overlap = max(niche.overlap)) %>%    
    mutate(bb.sp = rep("hort", n())) %>%
    filter(hort == TRUE)
  ) %>%
    
    bind_rows() %>%
    select(site, date, bb.sp, mean.niche.overlap, max.niche.overlap)
}
```

## 2.1 Defining bias

Deciding exactly how to represent bias turns out to be rather tricky. I am trying out a few options right now.   

1. Bias could  be treated simply as the Euclidean difference between prop.flower.cover and prop.visits. This has the effect of weighting bias by flower.cover, particularly negative bias, since an abundant plant can have a greater negative bias (because it is farther from 0) than a rare plant. Euclidean bias is bounded between -1 and 1. Its symmetry is a nice property that sets it apart from proportional or fold-change bias. If, for whatever reason, I decided that a log-transformation of this measure were desirable, I think I could simply add a constant of 1 to all values, which would move the boundary up to (0, 2). I think the biggest problem with measuring bias in this way is that it makes no distinction between a plant that was visited a little and one that was visited not at all, and that could be an important biological difference. For example, consider two plants, one with a proportional abundance = 0.01 and proportional visitation = 0.01, and the second with proportional abundance = 0.01 and proportional visitation = 0.00. These will look identical in our analysis, but it is possible that the unvisited plant would not have been visited no matter how high its abundance was. **For starters, though, I am going to proceed with this metric because it is the simplest. And because DJ thought it was a good idea.**

2. Alternatively, bias could be calculated as a simple proportion: prop.visits/prop.flower.cover. If anything, this might tend to reverse the weighting, since a small Euclidean change in a rare species would be a large proportional change. Proportional change has a lower boundary of 0 and no upper boundary. This approach highlights cases of positive bias, but it is even worse than euclidean bias in terms of obscuring the distinction between plants visited slightly and those visited not at all. Worse in a sense. In another sense, it is better than euclidean bias, because with proportional visitation a plant visited 0 times is at least numerical distinguishable from one visited 1 time (visited plants will always have non-zero proportional bias). 

3. Similarly to proportional bias, I could calculate bias as fold change. This converges to be virtually identical to proportional change as bias becomes more positive, but fold change has a lower bound of -1 instead of 0. 

4. If the distinction between plants that were visited and those that were not is what we're most interested in, we could simply treat bias as binary. This, of course, comes at the price of not being able to distinguish a plant that received 0.01 proportional visitation and one that recevied  0.99 proportional visitation, and this distinction is arguably important. 

5. An interesting option is to first separate visited from unvisited plants, set the bias of unvisited plants to 0, and then exponentiate the euclidean bias of all visited plant species. This has some desirable properties. First, it clearly distinguished visited plants from unvisited ones. Second, it assigns plants visited perfectly in proportion to their abundance a sensible bias of 1 (just like proportional bias). Thus, plants with a psotive bias are > 1 (bounded at 2.718282 -- okay, so that's a bit inelegant), those with a negative bias are < 1 (bounded at 0.367895), and those not visited at all = 0. 

6. The problem with the option above is that is adds weight to positive bias. Another approach is to separate the unvisited plants from the visited, set unvisited bias = 0, and visited bias = prop.visits - prop.flower.cover + 1. The +1 serves to make the distribution positive, with 1 represening perfect proportionality between visitation and floral abundance. This creates a symmetrically bounded distribution between 0 (not inclusive) and 2 (inclusive), plus the true zeros from the unvisited plants. It feels a bit...slapped together, though.

*We will adopt the term representation to avoid confusion with the object defined above.*

## 2.2 Function for calculating bias per group (= criterion)
```{r}
biaseval_group <- function(x, criterion) {
  
  criterion <- enquo(criterion)
  
  x %>%
    mutate(criterion = factor(!!criterion)) %>% # having this as a factor will help with modeling later on
    group_by(site, date, bb.sp, criterion) %>%
    summarize(flower.cover = sum(flower.cover), # get raw floer cover and visits by group
              visits = sum(visits)) %>%
    group_by(site, date, bb.sp) %>%
    mutate(prop.flower.cover = flower.cover/sum(flower.cover), # get proportional flower cover and visits by group
           prop.visits = visits/sum(visits)) %>%
    mutate(bias = prop.visits - prop.flower.cover, # bias as difference
           bias.prop = prop.visits/prop.flower.cover, # bias as proportion
           bias.fold = bias/prop.flower.cover, # bias as fold change
           bias.bin = if_else(bias > 0, 1, 0), # bias as binary
           bias.exp = if_else(visits == 0, 0, exp(prop.visits - prop.flower.cover)),  # bias as exponentiated difference
           bias.split = if_else(visits == 0, 0, (prop.visits - prop.flower.cover + 1))) %>%
    mutate(yday = yday(date)) %>%
    select(site, date, yday, bb.sp, criterion, 
           bias, bias.prop, bias.fold, bias.bin, bias.exp, bias.split,
           visits, flower.cover, prop.visits, prop.flower.cover)
}
```

```{r}
# # BB spp. pooled, only interested in comparing ktypes here
# brm_pvis00 <- brm(visits ~ bb.abund*prop.flower.cover +
#                     (1 + prop.flower.cover | ktype/site),
#                   family = "negbinomial",
#                   file = "../output/brm_pvis00",  # for running locally
#                   #file = "brm_pvis00", # for running on the HPC
#                   chains = 4,
#                   cores = 4,
#                   iter = 2000,
#                   data = prop_visits_ktype_pooled)
# 
# get_variables(brm_pvis00)
# pp_check(brm_pvis00, type='stat', stat='mean')
# pp_check(brm_pvis00, type = "error_scatter_avg")
# pp_check(brm_pvis00,  x = 'prop.flower.cover', type = "error_scatter_avg_vs_x")
# pp_check(brm_pvis00,  x = 'bb.abund', type = "error_scatter_avg_vs_x")
# 
# 
# bayes_R2(brm_pvis00)
# conditional_effects(brm_pvis00)
# 
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*0_.*Intercept]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*1_.*Intercept]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*2_.*Intercept]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*3_.*Intercept]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*4_.*Intercept]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*5_.*Intercept]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*6_.*Intercept]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*7_.*Intercept]$"))
# 
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*0_.*prop.flower.cover]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*1_.*prop.flower.cover]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*2_.*prop.flower.cover]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*3_.*prop.flower.cover]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*4_.*prop.flower.cover]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*5_.*prop.flower.cover]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*6_.*prop.flower.cover]$"))
# mcmc_plot(brm_pvis00, pars = c("^r_ktype:site.*7_.*prop.flower.cover]$"))
# 
# mcmc_plot(brm_pvis00, pars = c("r_ktype[0,Intercept]",
#                                "r_ktype[1,Intercept]",
#                                "r_ktype[2,Intercept]",
#                                "r_ktype[3,Intercept]",
#                                "r_ktype[4,Intercept]",
#                                "r_ktype[5,Intercept]",
#                                "r_ktype[6,Intercept]",
#                                "r_ktype[7,Intercept]"), fixed =  TRUE)
# 
# mcmc_plot(brm_pvis00, pars = c("r_ktype[0,prop.flower.cover]",
#                                "r_ktype[1,prop.flower.cover]",
#                                "r_ktype[2,prop.flower.cover]",
#                                "r_ktype[3,prop.flower.cover]",
#                                "r_ktype[4,prop.flower.cover]",
#                                "r_ktype[5,prop.flower.cover]",
#                                "r_ktype[6,prop.flower.cover]",
#                                "r_ktype[7,prop.flower.cover]"), fixed =  TRUE)
# 
# 
# brm_pvis03 <- brm(visits ~ bb.abund*prop.flower.cover +
#                     (1 + prop.flower.cover | ktype),
#                   family = "negbinomial",
#                   file = "../output/brm_pvis03",  # for running locally
#                   #file = "brm_pvis03", # for running on the HPC
#                   chains = 4,
#                   cores = 4,
#                   iter = 2000,
#                   data = prop_visits_ktype_pooled)
# 
# pp_check(brm_pvis03)
# bayes_R2(brm_pvis03)
# conditional_effects(brm_pvis03)
# mcmc_plot(brm_pvis03, pars = c("^r_k"))
# 

```

