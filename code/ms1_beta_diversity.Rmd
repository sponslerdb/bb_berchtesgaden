---
title: "Beta Diversity through Elevation"
output: html_document
---

# 1. Prepare environment
## 1.1 Packages 
```{r message=FALSE, warning=FALSE}
library(sf)
library(magick)
library(gdm)
library(patchwork)
library(bipartite)
library(vegan)
library(ecodist)
library(flextable)
library(tidyverse)
library(lubridate)
library(cowplot)
```
## 1.2 Define functions
### 1.2.1 `sfc_as_cols`: convert geometry column back to x and y columns
```{r}
# A function for converting a geometry column back to x and y columns
# https://github.com/r-spatial/sf/issues/231
sfc_as_cols <- function(x, names = c("x","y")) {
  stopifnot(inherits(x,"sf") && inherits(sf::st_geometry(x),"sfc_POINT"))
  ret <- sf::st_coordinates(x)
  ret <- tibble::as_tibble(ret)
  stopifnot(length(names) == ncol(ret))
  x <- x[ , !names(x) %in% names]
  ret <- setNames(ret,names)
  dplyr::bind_cols(x,ret)
}
```

### 1.2.2 `web_prep`: convert networks to webs arrays
```{r}
# Function to convert networks to webs arrays
web_prep <- function(net) {
  
  out <- net %>%
    filter(caste != "male") %>%
    group_by(site, bb.sp, plant.sp) %>%
    summarize(freq = n()) %>%
    group_by(site) %>%
    mutate(bb.sp.count = length(unique(bb.sp)),
           plant.sp.count = length(unique(plant.sp))) %>%
    ungroup() %>%
    dplyr::select(higher = bb.sp, lower = plant.sp, webID = site, freq) %>% # rename columns to match bipartite's expectations
    data.frame() %>% # convert to data frame
    frame2webs(type.out = "array")
}
```


### 1.2.3 `betalinkr_set1`: betalinkr settings and conversion to tibble
```{r}
# Function for betalinkr settings and conversion to tibble()
betalinkr_set1 <- function(x) {
  betalinkr_multi(x, partition.st = TRUE, partition.rr = TRUE, # partition both species turnover and richness/replacement
                  binary = TRUE, # treating beta-diversity as binary is an appropriate complement to our abundance analysis
                  index = "jaccard") %>% # the Jaccard index is best, I think, for binary analysis
  as_tibble() # for convenience
}
```

### 1.2.4 `interaction_gdm_prep`: convert visitation data into site-pair table for GDM analysis
```{r}
# Function for converting visitation data into site-pair table for GDM analysis 
interaction_gdm_prep <- function(x) {
  
  spdat <- net %>%
    filter(caste != "male") %>%
    dplyr::select(bb.sp, plant.sp.abb, site) %>% 
    distinct() %>% # each unique bb-fl-site combo
    mutate(present = rep(1, length(.[,1]))) %>% # we will treat abundance as binary
    unite(interaction, c(bb.sp, plant.sp.abb), sep = "_") %>% # unite bb and fl into interaction "species", i.e. a unique bb-fl combo
    pivot_wider(names_from = interaction, values_from = present) %>% # spread so that columns are interaction "species"
    replace(is.na(.), 0) %>% # replace NAs with absences
    as_tibble()

  envdat <- net %>%
    filter(caste != "male") %>%
    group_by(site) %>%
    summarize(samples = length(unique(date))) %>%
    left_join(site_data) %>% # add site data
    ungroup() %>%
    mutate(mowing = if_else(management == "mowing", 1, 0),
           grasing = if_else(management == "grasing", 1, 0),
           none = if_else(management == "none", 1, 0)) %>%
    dplyr::select(site, elev.mean, x, y, samples, mowing, grasing, none) %>%
    distinct() # return unique site-dates

  # Prep site-pairs for GDM analysis
  sitepair <- formatsitepair(spdat, 
                             bioFormat = 1, # i.e. samples as rows, species as columns, site-dates as rows
                             siteColumn = "site", 
                             dist = "jaccard", # I think Jaccard is the right choice
                             XColumn = "x", YColumn = "y", # spatial columns
                             predData = envdat, 
                             abundance = FALSE) %>% # abundance = FALSE means binary
    filter(s1.elev.mean != s2.elev.mean) # this drops within-site comparisons
}
```

### 1.2.5 `biodata_prep_survey`: prepare the floral survey biodata input to gdm's `formatsitepair()` function
```{r}
# Function for preparing the floral survey biodata input to gdm's formatsitepair function
biodata_prep_survey <- function(surv) {
  surv %>%
    filter(flower.cover > 0) %>%
    mutate(plant.sp = str_replace_all(plant.sp, " ", "_")) %>%
    group_by(site, plant.sp) %>%
    summarize(cover = sum(flower.cover)) %>%
    mutate(cover = rep(1, n())) %>% # this makes the data binary, which I think is what I want here; otherwise, just comment out
    spread(plant.sp, cover) %>%
    replace(is.na(.), 0) %>%
    arrange(site)
}
```

### 1.2.6 `predData_prep_survey`: prepare the floral survey predictor data input to gdm's `formatsitepair()` function
```{r}
# Function for preparing the floral survey predictor data input to gdm's formatsitepair function
predData_prep_survey <- function(surv) {
  surv %>%
    filter(flower.cover > 0) %>%
    group_by(site) %>%
    summarize(samples = length(unique(date))) %>%
    dplyr::select(site, samples) %>%
    left_join(site_data) %>%
    ungroup() %>%
    mutate(mowing = if_else(management == "mowing", 1, 0),
           grasing = if_else(management == "grasing", 1, 0),
           none = if_else(management == "none", 1, 0)) %>%
    dplyr::select(site, elev.mean, x, y, samples, mowing, grasing, none) %>%
    distinct() %>%
    arrange(site) 
}
```

### 1.2.7 `biodata_prep_BB`: prepare the visitation biodata input to gdm's `formatsitepair()` function
```{r}
# Function for preparing the visitation biodata input to gdm's formatsitepair function
biodata_prep_BB <- function(net) {
  net %>%
    filter(caste != "male") %>%
    group_by(site, bb.sp) %>%
    summarize(count = n()) %>%
    mutate(count = rep(1, n())) %>% # this makes the data binary, which I think is what I want here; otherwise, just comment out
    spread(bb.sp, count) %>%
    replace(is.na(.), 0) %>%
    ungroup()
}
```

### 1.2.8 `predData_prep_BB`: prepare the visitation predictor data input to gdm's `formatsitepair()` function
```{r}
# Function for preparing the visitation predictor data input to gdm's formatsitepair function
predData_prep_BB <- function(net) {
  net %>%
    filter(caste != "male") %>%
    group_by(site) %>%
    summarize(samples = length(unique(date))) %>%
    dplyr::select(site, samples) %>%
    left_join(site_data) %>%
    ungroup() %>%
    mutate(mowing = if_else(management == "mowing", 1, 0),
           grasing = if_else(management == "grasing", 1, 0),
           none = if_else(management == "none", 1, 0)) %>%
    dplyr::select(site, elev.mean, x, y, samples, mowing, grasing, none) %>%
    unique() %>%
    arrange(site) 
}
```

### 1.2.9 `format_set`: setting for gdm's `formatsitepair()` function
```{r}
# Function with setting for gdm's formatsitepair function
format_set <- function(bio, pred) {
  formatsitepair(bio, bioFormat = 1, siteColumn = "site", 
                 dist = "jaccard", XColumn = "x", YColumn = "y", 
                 predData = pred, abundance = FALSE) %>%
  filter(s1.elev.mean != s2.elev.mean) # this avoids comparing repeated measures of the same site (taking advantage of the fact that each site has a unique elevation in our dataset)
} 
```

### 1.2.10 `gdm_tab`: tabulate `gdm.varImp()` output 
```{r}
# Function for tabulating gdm.varImp output 
gdm_tab <- function(x, response) {
  x %>%
    as.data.frame() %>%
    rownames_to_column(var = "predictor") %>%
    mutate(model = rep(response, n()),
           predictor = case_when(
             predictor == "elev.mean" ~ "elevation",
             predictor == "samples" ~ "samples",
             predictor == "Geographic" ~ "distance")
             # predictor == "mowing" ~ "mowing",
             # predictor == "grasing" ~ "grazing",
             # predictor == "none" ~ "none")
           ) %>%
    mutate(importance = round(importance, 2),
           model.var.exp = round(model.var.exp, 2)) %>%
    select(Model = model, Variable = predictor, 
           "Importance [%]" = importance, Var.pval = pval, 
           Model.pval = model.pval, "Model.dev.exp [%]" = model.var.exp) %>%
    tibble() %>%
    mutate(Variable = factor(Variable, levels = c("elevation", "distance", "samples"))) %>%
    arrange(Variable)
}
```

### 1.2.11 `isplineExtract2`: Fixes a bug in `isplineExtract()` that causes it to break when non-default number of splines are used
```{r}
##Extracts Ispline data from a gdm model
isplineExtract2 <- function (model){
  ###########################
  #model = gdmOb
  ###########################
  ##error checking
  ##checks to make sure a gdm model is given
  if(!is(model, "gdm")){
    stop("model argument must be of class = 'gdm'.")
  }
  
  ##Collects or sets simple data
  options(warn.FPU = FALSE)
  PSAMPLE <- 200
  preddata <- rep(0, times = PSAMPLE)
  pn <- model$predictors
  nPreds <- length(pn)
  yDat <- xDat <- matrix(0,PSAMPLE,nPreds)
  colnames(yDat) <- colnames(xDat) <- pn
  pmin <- 1
  pmax <- PSAMPLE
  
  ##cycles through each prodictor and fills the spline matrices
  splineindex <- 1
  for (i in 1:nPreds){ 
    #i<-1
    numsplines <- model$splines[i]
    z <- .C("GetPredictorPlotData", 
            pdata = as.double(preddata), 
            as.integer(PSAMPLE), 
            as.double(model$coefficients[splineindex:(splineindex + numsplines - 1)]), 
            as.double(model$knots[splineindex:(splineindex + numsplines - 1)]), 
            as.integer(numsplines),
            PACKAGE = "gdm")
    yDat[,i] <- z$pdata
    pmin <- pmin + PSAMPLE
    pmax <- pmax + PSAMPLE
    xDat[,i] <-  seq(from=model$knots[[(i*numsplines)-(numsplines-1)]],to=model$knots[[(i*numsplines)]], length=PSAMPLE)
    splineindex <- splineindex + numsplines
  }
  
  ##lists and returns matrices
  outData <- list(x=xDat,y=yDat)
  return(outData)
}
```

### 1.2.12 `plotUncertainty2` Tweaked to call `isplineExtract2` instead of the broken version
```{r}
##########################################################################
plotUncertainty2 <- function(spTable, sampleSites, bsIters, geo=FALSE, splines=NULL, 
                           knots=NULL, splineCol="blue", errCol="grey80", 
                           plot.linewidth=2.0, plot.layout=c(2,2), parallel=FALSE,
                           cores=2){
  ##A function to plot the uncertantiy of each variable from a GDM model
  #################
  #spTable <- sitePairTab          ##the input site-pair table to subsample from
  #sampleSites <- 0.9     ##fraction of sites that should be retained from site pair table 
  #bsIters <- 50       ##the number of times the site-pair table should be sampled
  #geo <- F              ##rather or not the gdm model takes geography into account, see gdm
  #splines <- NULL       ##splines gdm setting, see gdm
  #knots <- NULL         ##knots gdm setting, see gdm
  #splineCol <- "blue"    ##color of the center line
  #errCol <- "grey80"        ##color of the uncertainty polygon
  #plot.linewidth <- 2.0    ##line width of the center line
  #plot.layout <- c(3,3)    ##number of plots per page
  #parallel <- F            ##rather or not the sampling should happen in parallel processing, to speed it up
  #cores <- 6               ##number of cores to if parallel processing
  #################
  ##function breaks and warnings
  ##makes sure that table is a properly formated site-pair table
  if(!is(spTable, "gdmData")){
    warning("The spTable object is not of class 'gdmData'. See the formatsitepair function for help.")
  }
  ##checks to makes sure table is a matrix or table frame
  if(!(is(spTable, "gdmData") | is(spTable, "matrix") | is(spTable, "data.frame"))){
    stop("The spTable object must be of class 'gdmData', 'matrix', or 'data.frame'.")
  }
  
  ##sanity check on the data table
  if(ncol(spTable) < 6){
    stop("spTable object requires at least 6 columns: Observed, weights, s1.xCoord, s1.yCoord, s2.xCoord, s2.yCoord")
  }  
  if(nrow(spTable) < 1){
    stop("spTable object has < 1 rows.")
  }
  
  ##checks that geo has either TRUE or FALSE
  if(!(geo==TRUE | geo==FALSE)){
    stop("geo argument must be either TRUE or FALSE")
  }
  ##makes sure splines is a numeric vector
  if(is.null(splines)==FALSE & !is(splines, "numeric")){
    stop("splines object must of of class = 'numeric'.")
  }
  ##checks knots inputs
  if(is.null(knots)==FALSE & !is(knots, "numeric")){
    stop("knots object must of of class = 'numeric'.")
  }
  
  ##checks that parallel has either TRUE or FALSE
  if(!(parallel==TRUE | parallel==FALSE)){
    stop("parallel argument must be either TRUE or FALSE")
  }
  ##makes sure that cores has a value when parallel is true
  if(parallel==TRUE & is.null(cores)==TRUE){
    stop("If parallel==TRUE, the number of cores must be specified")
  }
  ##makes sure that cores is a positive integer 
  if((is.null(cores)==FALSE & is.numeric(cores)==FALSE) | cores<1){
    stop("argument cores needs to be a positive integer")
  }
  
  ##makes sure that bsIters is a positive integer 
  if((is.null(bsIters)==FALSE & is.numeric(bsIters)==FALSE) | bsIters<1){
    stop("argument bsIters needs to be a positive integer")
  }
  ##makes sure sampleSites is a number
  if(is.numeric(sampleSites)==FALSE){
    stop("sampleSites must be a number between 0 and 1")
  }
  ##makes sure that sampleSites is between 0 and 1
  if(sampleSites < 0){
    stop("sampleSites must be a number between 0 and 1")
  }
  if(sampleSites > 1){
    stop("sampleSites must be a number between 0 and 1")
  }
  if(sampleSites==0){
    stop("a sampleSites value of 0 will remove all sites from the analysis (bad).")
  }
  ##double makes sure these values are integers, seems to truncate if not
  cores <- as.integer(cores)
  bsIters <- as.integer(bsIters)
  
  ##assign k to prevent issues to cran checking
  k <- NULL
  
  ##makes copies of the site-pair table in order to randomly subsample each one differently
  lstSP <- lapply(1:bsIters, function(i){spTable})
  
  ##runs parallel if desired by the users
  if(parallel==TRUE){
    ##loads libraries
    #require(foreach)
    #require(doParallel)
    #requireNamespace("foreach")
    #requireNamespace("parallel")
    #requireNamespace("doParallel")
    
    ##sets cores
    cl <- makeCluster(cores, outfile="")
    registerDoParallel(cl)
    ##first removes a number of sites according to input
    subSamps <- foreach(k=1:length(lstSP), .verbose=F, .packages=c("gdm")) %dopar%
                      removeSitesFromSitePair(lstSP[[k]], sampleSites=sampleSites)
    ##models the subsamples
    gdmMods <- foreach(k=1:length(subSamps), .verbose=F, .packages=c("gdm")) %dopar%
                     #gdmMods <- try(foreach(k=1, .verbose=F, .packages=c("gdm")) %dopar%
                     gdm(subSamps[[k]], geo=geo, splines=splines, knots=knots)
    stopCluster(cl)
  }else{
    ##first removes a number of sites according to input
    subSamps <- lapply(lstSP, removeSitesFromSitePair, sampleSites=sampleSites)
    ##models the subsamples
    gdmMods <- lapply(subSamps, gdm, geo=geo, splines=splines, knots=knots)
  }
  
  ##models the full gdm
  fullGDMmodel <- gdm(spTable, geo=geo, splines=splines, knots=knots)
    
  ##Extracts the splines for each model
  exUncertSplines <- lapply(gdmMods, isplineExtract2)
  fullGDMsplines <- isplineExtract2(fullGDMmodel)
  
  ##get the names of the predictor variables
  predVars <- colnames(exUncertSplines[[1]][[1]])
  
  ##establish what plot layout to use
  thisplot <- 0
  one_page_per_plot <- FALSE
  if ((plot.layout[1]==1) && (plot.layout[2]==1)){
    one_page_per_plot <- TRUE
  }else{
    par(mfrow=plot.layout)
  }
  
  ##sets the plotting minimum and maximum y-values 
  totalYmin <- Inf
  totalYmax <- -Inf
  
  ##determines the bounds of the plots
  for(p in 1:length(predVars)){
    #p=1
    predV <- predVars[p]
    
    ##gets the minimum and maximum, to set the ploting extent
    for(nm in 1:length(exUncertSplines)){
      #nm=1
      selPlot <- exUncertSplines[[nm]]
      
      spYmax <- max(selPlot[[2]][,predV])
      spYmin <- min(selPlot[[2]][,predV])
      
      totalYmax <- max(c(totalYmax, spYmax))
      totalYmin <- min(c(totalYmin, spYmin))
    }
  }
  
  ##plots by variable
  for(p in 1:length(predVars)){
    #p <- 1
    predV <- predVars[p]
    
    ##sets the plotting minimum and maximum x-values
    totalXmin <- Inf
    totalXmax <- -Inf
    ##gets the minimum and maximum, to set the ploting extent
    for(nm in 1:length(exUncertSplines)){
      #nm=1
      selPlot <- exUncertSplines[[nm]]
      
      spXmax <- max(selPlot[[1]][,predV])
      spXmin <- min(selPlot[[1]][,predV])
      
      if(spXmax > totalXmax){totalXmax = spXmax}
      if(spXmin < totalXmin){totalXmin = spXmin}
    }
    
    ##checks to make sure that there is some significance, if there is the the data is plotted
    if(totalYmax!=0){
      ##add mean of subsets to plot
      plotX <- NULL
      plotY <- NULL
      byVarMatX <- NULL
      byVarMatY <- NULL
      ##create matrices based on the variable and its x and y location for each model iteration
      for(nn in 1:length(exUncertSplines)){
        #nn=1
        plotX[[nn]] <- exUncertSplines[[nn]][[1]]
        plotY[[nn]] <- exUncertSplines[[nn]][[2]]
        byVarMatY <- cbind(byVarMatY, plotY[[nn]][,predV])
        byVarMatX <- cbind(byVarMatX, plotX[[nn]][,predV])
      }
      ##gets spline data from the full gdm model
      fullPlotX <- fullGDMsplines[[1]]
      fullPlotX <- fullPlotX[,predV]
      fullPlotY <- fullGDMsplines[[2]]
      fullPlotY <- fullPlotY[,predV]
      
      ##calculates the confidence intervals for plotting
      sdX <- apply(as.matrix(byVarMatX), 1, sd)
      sdY <- apply(as.matrix(byVarMatY), 1, sd)
      highBoundX <- fullPlotX + sdX
      lowBoundX <- fullPlotX - sdX
      highBoundY <- fullPlotY + sdY
      lowBoundY <- fullPlotY - sdY
      
      ##collects the data to be used in the rug plot
      if(predV=="Geographic"){
        ##calculates unique eucildian distance between sites
        rugData <- unique(sqrt(((spTable$s1.xCoord-spTable$s2.xCoord)^2)+((spTable$s1.yCoord-spTable$s2.yCoord)^2)))
      }else{
        ##gets unique values of variable data
        varDat <- grep(predV, colnames(spTable))
        rugData <- unique(c(spTable[,c(varDat[1])], spTable[,c(varDat[2])]))
      }
      
      ##plots one graph per page, unless specified otherwise
      if (one_page_per_plot){
        dev.new()
        dev.next()
      }else{
        thisplot <- thisplot + 1
        if(thisplot > (plot.layout[1] * plot.layout[2])){    			
          thisplot <- 1
          par(mfrow=plot.layout)	
        }
      }
      #settings <- par(pars)
      ##plots mean data line and polygon of uncertanty 
      plot(NULL, xlim=c(totalXmin, totalXmax), ylim=c(totalYmin, totalYmax), xlab=predV, ylab="Partial Ecological Distance")
      polygon(c(lowBoundX, rev(highBoundX)), c(lowBoundY, rev(highBoundY)), col=errCol, border=NA)
      lines(fullPlotX, fullPlotY, col=splineCol, lwd=plot.linewidth)
      rug(rugData)
    }
  }
}
##########################################################################
```

## 1.3 Load data
```{r}
net <- read_csv("../data/processed_data/network.csv") %>%
  filter(caste  != "male") %>%
  unite(site.year.day, site, year, dayofyear, sep = "_", remove = FALSE) %>% 
  mutate(year = factor(year)) 

survey <- read_csv("../data/processed_data/floral_survey.csv") %>%
  filter(flower.cover > 0) %>%
  semi_join(net, by = "plant.sp") %>% # Consider only visited plant spp. (anytime, anywhere, not specifically for a given site*date)
  dplyr::select(site, date, plant.sp, flower.cover) 

site_data <- read_csv("../data/processed_data/site_data.csv") %>%
  dplyr::select(-c(slope.calc, slope.est, elev.min, elev.max, temp.mean, elev.class, elev.class2)) %>% #
  mutate(site = factor(site),
         tree_line = factor(tree_line)) %>% 
  semi_join(net, by = "site") %>% # drop sites that were not sampled
  st_as_sf(coords = c("lon", "lat")) %>%
  st_set_crs(4326) %>%
  st_transform(5684) %>%
  sfc_as_cols() %>%
  as_tibble() %>%
  dplyr::select(-geometry)
```

## 1.4 Load images
```{r}
BB <- image_read("../ms_1/figures/phylopic_BB.png")
FL <- image_read("../ms_1/figures/phylopic_FL.png")
BBxFL <- image_read("../ms_1/figures/phylopic_BBxFL.png")
```

# 2. Process data
## 2.1 BB and FL beta-diversity
```{r}
# Bumble bee beta-diversity based on interaction sampling
bb_beta <- net %>%
  group_by(site, bb.sp) %>%
  summarize(count = n()) %>% 
  pivot_wider(names_from = bb.sp, values_from = count) %>%
  replace(is.na(.), 0) %>%
  column_to_rownames("site") %>%
  vegdist(method = "jaccard", binary = TRUE) %>% # Jaccard and binary settings make this comparable to the way I'm running betalinkr
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column(var = "site1") %>%
  pivot_longer(cols = -site1, names_to = "site2", values_to = "BB") 

# Flora beta-diversity based on floral survey data (filtered to include only species visited by BBs)
fl_beta <- survey %>%
  group_by(site, plant.sp) %>%
  summarize(count = sum(flower.cover)) %>%
  pivot_wider(names_from = plant.sp, values_from = count) %>%
  replace(is.na(.), 0) %>%
  column_to_rownames("site") %>%
  vegdist(method = "jaccard", binary = TRUE, upper = TRUE) %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column(var = "site1") %>%
  pivot_longer(cols = -site1, names_to = "site2", values_to = "FL")

# Join into single data frame for visualization
species_beta <- full_join(bb_beta, fl_beta) %>%
  left_join(site_data, by = c("site1" = "site")) %>% # add site data
  dplyr::select(site1, site2, FL, BB, # first for site 1
                elev1 = elev.mean, x1 = x, y1 = y, mgmt1 = management) %>%
  left_join(site_data, by = c("site2" = "site")) %>%
  dplyr::select(site1, site2, FL, BB, # then for site 2
                elev1, elev2 = elev.mean, x1, y1, x2 = x, y2 = y, mgmt1, mgmt2 = management) %>%
  mutate(site1 = factor(site1), 
         site2 = factor(site2),
         elev.diff = elev1 - elev2,
         mean.elev = (elev1 + elev2)/2, mgmt.diff = if_else(mgmt1 == mgmt2, 0, 1)) %>%
  pivot_longer(cols = c(BB, FL), names_to = "group", values_to = "beta") %>%
  filter(elev.diff >= 0) 

# For each site pair, one will be higher and the other lower; thus, when their order is reversed only the sign of the difference changes. Since no two sites have exactly the same elevation, `filter(elev.diff >= 0)` deduplicates the data by dropping the ordering of a given pair of sites (one of the two orderings) that yields a negative elevation difference while retaining the alternative ordering that yields a positive elevation difference. By >= 0, I retain comparisons of a site to itself. I drop (in the ggplot call) within-site comparisons when I plot against elevation difference, and I isolate within-site comparison when I plot against time. In the latter case, it is also necessary to deduplicate, since each pair of site dates occurs in A-B and B-A. For that, I filter (again, in the ggplot call) so that yday.diff > 0, similarly dropping the orderings that yield negative differences. Note that all this deduplication nonsense is not necessary for the betalinkr call because it deduplicates internally.
```

## 3.2  Interaction beta-diversity and partitioning
S	= beta_S, the dissimilarity in species composition
OS = beta_OS, the dissimilarity (component) explained by "rewiring" among shared species
WN = beta_WN, the dissimilarity between the two networks
ST = beta_ST, the dissimilarity (component) explained by difference in species community composition 
```{r message=FALSE}
# Create webs
net_web <- web_prep(net)

# Calculate beta-diversity
beta_site <- betalinkr_set1(net_web) %>%
  rename(site1 = i, site2 = j)

# Add site data
beta_mit_data <- beta_site %>%
  left_join(site_data, by = c("site1" = "site")) %>%
  dplyr::select(site1, site2, S, OS, WN, ST, 
                ST.l, ST.h, ST.lh, WN.repl, OS.repl, WN.rich, OS.rich, 
                elev1 = elev.mean, x1 = x, y1 = y, mgmt1 = management) %>%
  left_join(site_data, by = c("site2" = "site")) %>%
  dplyr::select(site1, site2, S, OS, WN, ST, 
                ST.l, ST.h, ST.lh, WN.repl, OS.repl, WN.rich, OS.rich, 
                elev1, elev2 = elev.mean, x1, y1, x2 = x, y2 = y, mgmt1, mgmt2 = management) %>%
  mutate(elev.diff = abs(elev1 - elev2),
         mean.elev = (elev1 + elev2)/2,
         mgmt.diff = if_else(mgmt1 == mgmt2, 0, 1)) %>%
  gather(metric, value, -c(site1, site2, elev1, elev2, 
                           elev.diff, mean.elev, 
                           x1, y1, x2, y2, mgmt1, mgmt2, mgmt.diff)) %>%
  mutate(metric.class = case_when(
    metric %in% c("WN", "ST", "OS", "S") ~ "aggregate",
    metric %in% c("WN.repl", "WN.rich") ~ "WN.partition",
    metric %in% c("ST.h", "ST.l", "ST.lh") ~ "ST.partition",
    metric %in% c("OS.repl", "OS.rich") ~ "OS.partition"),
    metric = factor(metric, levels = c("WN", "ST", "OS", "S", "ST.h", "ST.l", 
                                       "ST.lh", "WN.repl", "WN.rich", 
                                       "OS.repl", "OS.rich")))

# Write to csv for archiving
#write_csv(beta_mit_data, "../Dryad_ms1/partitioned_beta_diversity")
```

# 4. Visualize beta-diversity ~ elevation diff
```{r}
# Set palette
p1 <- c("OS" = "#e7298a", "ST" = "#66a61e", "WN" = "black")

p2 <- c("ST.h" = "#7570b3", "ST.l" = "#1b9e77", "ST.lh" = "#d95f02")

# BB + FL elevation diff
beta_plot1 <- ggplot(filter(species_beta, 
                    site1 != site2), # no within-site comparisons
             aes(elev.diff, beta, color = group)) +
  geom_point(alpha = 0.25, pch = 16) +
  geom_smooth(method = "glm", 
              method.args = list(family = "binomial"), 
              se = FALSE) +
  labs(x = NULL,
       y = "Species turnover",
       color = "Taxon") +
  theme_light()

# BB * FL elevation diff (aggregate)
beta_plot2 <- ggplot(filter(beta_mit_data, 
                      site1 != site2 & # no within-site comparisons
                      metric != "S" &
                      metric.class == "aggregate"), 
             aes(elev.diff, value, color = metric))  +
  geom_point(alpha = 0.20, pch = 16) +
  geom_smooth(method = "glm", 
              method.args = list(family = "binomial"), 
              se = FALSE) +
  scale_color_manual(values = p1, name = "Partition") +
  xlab(NULL) +
  ylab("Interaction turnover") +
  theme_light()

# BB * FL elevation diff (ST partition)
beta_plot3 <- ggplot(filter(beta_mit_data, 
                      site1 != site2 & # no within-site comparisons
                      metric.class ==  "ST.partition"), 
             aes(elev.diff, value, color = metric))  +
  geom_point(alpha = 0.20, pch = 16) +
  geom_smooth(method = "glm", 
              method.args = list(family = "binomial"), 
              se = FALSE) +
  scale_color_manual(values = p2, name = "ST partition") +
  xlab("Elevation difference [m]") +
  ylab("Prop. species turnover") +
  theme_light()

# Patchwork plot for comparing species beta-diversity with interaction beta-diversity
beta_plot <- (beta_plot1 / beta_plot2 / beta_plot3) + 
  plot_annotation(tag_levels = c("A", "B", "C"))
# & 
#   theme_classic() 

ggsave("../ms_1/figures/fig6.pdf", beta_plot, height = 8.5, width = 4.5)
```

# 5. GDM analysis

## 5.1 Interactions
```{r message=FALSE, warning=FALSE}
# Prep sitepairs
## GDM is not really built for handling categorical variables; when I include 
## management in the models, they effect is weak, and I don't know how to
## interpret the curves. So, I think it is better to drop the mgmt variables
## from the models and just interpret the continuous effects.
sitepair_WN <- interaction_gdm_prep(net) %>%
  select(-c(s1.mowing, s1.grasing, s1.none, 
            s2.mowing, s2.grasing, s2.none))

# Run GDM analysis
gdm_WN <- gdm(sitepair_WN, 
              geo = TRUE, 
              splines = c(6, 6, 6))

summary(gdm_WN)

gdm.varImp_WN <- gdm.varImp(sitepair_WN, 
                            geo = TRUE,
                            fullModelOnly = TRUE,
                            splines = c(6, 6, 6),
                            nPerm = 500)

# Plot
plot(gdm_WN)

# Plot with confidence intervals 
# pdf("../output/gdm_interactions.pdf", height = 2.5, width =  6.5)
# plotUncertainty2(sitepair_WN, 
#                 sampleSites = 0.7, 
#                 bsIters = 100, 
#                 geo  = TRUE,
#                 splines = c(6, 6, 6),
#                 splineCol = "black", 
#                 plot.layout = c(1,3))
# dev.off()
```

## 5.2 Bumble bees
```{r}
## GDM is not really built for handling categorical variables; when I include 
## management in the models, they effect is weak, and I don't know how to
## interpret the curves. So, I think it is better to drop the mgmt variables
## from the models and just interpret the continuous effects.

# Prep input for GDM
bioData_BB <- biodata_prep_BB(net)
predData_BB <- predData_prep_BB(net) %>%
  select(-c(mowing, grasing, none))
sitepair_BB <- format_set(bioData_BB, predData_BB)

# Call GDMs
gdm_BB <- gdm(sitepair_BB, 
              geo = TRUE, 
              splines = c(6, 6, 6))

# Summarize
summary(gdm_BB)

# Determine variable importance and significance by permutation test
gdm.varImp_BB <- gdm.varImp(sitepair_BB, 
                            geo = TRUE,
                            fullModelOnly = TRUE, 
                            splines = c(6, 6, 6),
                            nPerm = 500)

# Preliminary plot
plot(gdm_BB)

# Plot with confidence intervals 
# pdf("../output/gdm_BB.pdf", height = 2.5, width =  6.5)
# plotUncertainty2(sitepair_BB, 
#                  sampleSites = 0.7, 
#                  bsIters = 100, 
#                  geo  = TRUE,
#                  splines = c(6, 6, 6),
#                  splineCol = "black", 
#                  plot.layout = c(1,3))
# dev.off() 
```

## 5.3 Flora
```{r}
# Prep input for GDM
bioData_survey <- biodata_prep_survey(survey)
predData_survey <- predData_prep_survey(survey) %>%
  select(-c(mowing, grasing, none))
sitepair_survey <- format_set(bioData_survey, predData_survey)

# Call GDM
gdm_survey <- gdm(sitepair_survey, geo = TRUE, splines = c(6, 6, 6))

# Summarize
summary(gdm_survey)

# Determine variable importance and significance by permutation test
gdm.varImp_survey <- gdm.varImp(sitepair_survey, 
                                geo = TRUE,
                                fullModelOnly = TRUE,
                                splines = c(6, 6, 6),
                                nPerm = 500)

# Preliminary plot
plot(gdm_survey)

# Plot with confidence intervals 
# pdf("../output/gdm_survey.pdf", height = 2.5, width =  6.5)
# plotUncertainty2(sitepair_survey, 
#                  sampleSites = 0.7, 
#                  bsIters = 100, 
#                  geo  = TRUE,
#                  splines = c(6, 6, 6),
#                  splineCol = "black", 
#                  plot.layout = c(1,3))
# dev.off()
```


## 5.4 Tabulate `gdm.varImp()` results
### 5.4.1 Interactions
```{r}
# Extract tables
gdm.varImp_WN.tab1 <- gdm.varImp_WN[[1]] %>%
  as.data.frame() %>%
  dplyr::select(val = 1)

gdm.varImp_WN.tab2 <- gdm.varImp_WN[[2]] %>%
  as.data.frame() %>%
  dplyr::select(importance = 1) 

gdm.varImp_WN.tab3 <- gdm.varImp_WN[[3]] %>%
  as.data.frame() %>%
  dplyr::select(pval = 1)

# Assemble summary table
gdm.varImp_WN.tab <- bind_cols(gdm.varImp_WN.tab2, gdm.varImp_WN.tab3) %>%
  mutate(model.pval = rep(gdm.varImp_WN.tab1$val[3], n())) %>%
  mutate(pval = as.character(pval),
         pval = if_else(pval == "0", "<0.001", pval),
         model.pval = as.character(model.pval),
         model.pval = if_else(model.pval == "0", "<0.001", model.pval),
         model.var.exp = rep(gdm.varImp_WN.tab1$val[2]), n()) %>%
  gdm_tab("Interactions")
```

### 5.4.2 Bumble bees
```{r}
# Extract tables
gdm.varImp_BB.tab1 <- gdm.varImp_BB[[1]] %>%
  as.data.frame() %>%
  dplyr::select(val = 1)

gdm.varImp_BB.tab2 <- gdm.varImp_BB[[2]] %>%
  as.data.frame() %>%
  dplyr::select(importance = 1) 

gdm.varImp_BB.tab3 <- gdm.varImp_BB[[3]] %>%
  as.data.frame() %>%
  dplyr::select(pval = 1)

# Assemble summary table
gdm.varImp_BB.tab <- bind_cols(gdm.varImp_BB.tab2, gdm.varImp_BB.tab3) %>%
  mutate(model.pval = rep(gdm.varImp_BB.tab1$val[3], n())) %>%
  mutate(pval = as.character(pval),
         pval = if_else(pval == "0", "<0.001", pval),
         model.pval = as.character(model.pval),
         model.pval = if_else(model.pval == "0", "<0.001", model.pval),
         model.var.exp = rep(gdm.varImp_BB.tab1$val[2]), n()) %>%
  gdm_tab("Bumble bees")
```

### 5.4.3 Flora
```{r}
# Extract tables
gdm.varImp_survey.tab1 <- gdm.varImp_survey[[1]] %>%
  as.data.frame() %>%
  dplyr::select(val = 1)

gdm.varImp_survey.tab2 <- gdm.varImp_survey[[2]] %>%
  as.data.frame() %>%
  dplyr::select(importance = 1) 

gdm.varImp_survey.tab3 <- gdm.varImp_survey[[3]] %>%
  as.data.frame() %>%
  dplyr::select(pval = 1)

# Assemble summary table
gdm.varImp_survey.tab <- bind_cols(gdm.varImp_survey.tab2, gdm.varImp_survey.tab3) %>%
  mutate(model.pval = rep(gdm.varImp_survey.tab1$val[3], n())) %>%
  mutate(pval = as.character(pval),
         pval = if_else(pval == "0", "<0.001", pval),
         model.pval = as.character(model.pval),
         model.pval = if_else(model.pval == "0", "<0.001", model.pval),
         model.var.exp = rep(gdm.varImp_survey.tab1$val[2]), n()) %>%
  gdm_tab("Flora")
```

### 5.4.4 Merge and format
```{r}
colourer <- scales::col_numeric(
  palette = c("transparent", "red"),
  domain = c(0, 100))

# Merge and format
gdm.varImp.tab <- bind_rows(gdm.varImp_BB.tab,
                            gdm.varImp_survey.tab, 
                            gdm.varImp_WN.tab
                            ) %>%
  as_grouped_data(group = "Model") %>%
  flextable::as_flextable() %>%
  merge_v(j = c("Model.pval", "Model.dev.exp [%]")) %>%
  valign(j = c("Model.pval", "Model.dev.exp [%]"), valign = "top") %>%
  autofit() %>%
  bg(j = "Importance [%]",
     bg = colourer, part = "body")

save_as_image(gdm.varImp.tab, "../ms_1/figures/table4.png")
```



## 5.5. Plot GDM splines
```{r}
# Interaction model
gdm_WN_splines1 <- isplineExtract2(gdm_WN)$x %>%
  as.data.frame() %>%
  dplyr::select(elevation = elev.mean)

gdm_WN_splines2 <- isplineExtract2(gdm_WN)$y %>%
  as.data.frame() %>%
  dplyr::select(response = elev.mean)

gdm_WN_splines <- bind_cols(gdm_WN_splines1, gdm_WN_splines2) %>%
  mutate(level = rep("Interactions"))

# Flora model
gdm_survey_splines1 <- isplineExtract2(gdm_survey)$x %>%
  as.data.frame() %>%
  dplyr::select(elevation = elev.mean)

gdm_survey_splines2 <- isplineExtract2(gdm_survey)$y %>%
  as.data.frame() %>%
  dplyr::select(response = elev.mean)

gdm_survey_splines <- bind_cols(gdm_survey_splines1, gdm_survey_splines2) %>%
  mutate(level = rep("Flora"))

# BB model
gdm_BB_splines1 <- isplineExtract2(gdm_BB)$x %>%
  as.data.frame() %>%
  dplyr::select(elevation = elev.mean)

gdm_BB_splines2 <- isplineExtract2(gdm_BB)$y %>%
  as.data.frame() %>%
  dplyr::select(response = elev.mean)

gdm_BB_splines <- bind_cols(gdm_BB_splines1, gdm_BB_splines2) %>%
  mutate(level = rep("Bumble bees"))

# Combine
gdm_splines <- bind_rows(gdm_WN_splines, gdm_survey_splines, gdm_BB_splines) %>%
  mutate(Level = factor(level, levels = c("Interactions", "Flora", "Bumble bees"))) %>%
  select(-level)

tree_line <- site_data %>%
  dplyr::select(elevation = elev.mean, tree_line)

# Plot
# gdm_plot_ <- ggplot(gdm_splines, aes(elevation, response, linetype = Level)) +
#   geom_line(size = 0.75) +
#   #geom_vline(xintercept = 1500) +
#   geom_rug(data = tree_line, aes(elevation, color = tree_line), inherit.aes = FALSE) +
#   labs(color = "Tree Line", x = "Elevation", y = "Conditional effect") +
#   theme_classic(14) +
#   guides(linetype = "none") +
#   theme(legend.position = c(0.12, 0.85),
#         plot.margin = margin(1, 3, 0.5, 0.5, "cm"),)
# 
# gdm_plot <- ggdraw() +
#   draw_plot(gdm_plot_) +
#   draw_image(BB, scale = 0.11, x = 0.34, y = -0.19) +
#   draw_image(FL, scale = 0.15, x = 0.33, y = 0.15) +
#   draw_image(BBxFL, scale = 0.18, x = 0.38, y = 0.41)

#ggsave("../ms_1/figures/fig7.pdf", width = 7, height = 5)

gdm_plot <- ggplot(gdm_splines, aes(elevation, response)) +
  geom_line() +
  geom_rug(data = tree_line, aes(elevation, color = tree_line), inherit.aes = FALSE) +
  labs(color = "Tree Line", x = "Elevation", y = "Conditional effect") +
  theme_light(12) +
  guides(linetype = "none") +
  facet_wrap(~Level, scales = "free", ncol = 1)

ggsave("../ms_1/figures/fig7.pdf", gdm_plot, width = 4, height = 6.5)
```


# 6. MRM analysis (not included in paper)
```{r, warning=FALSE}
survey_sample_diff <- survey %>%
  group_by(site) %>%
  summarize(samples = length(unique(date))) %>%
  remove_rownames() %>%
  column_to_rownames("site") %>%
  vegdist(method = "euclidean", upper = TRUE) %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column(var = "site1") %>%
  pivot_longer(cols = -site1, names_to = "site2", values_to = "sample.diff")

net_sample_diff <- net %>%
  group_by(site) %>%
  summarize(samples = length(unique(date))) %>%
  remove_rownames() %>%
  column_to_rownames("site") %>%
  vegdist(method = "euclidean", upper = TRUE) %>%
  as.matrix() %>%
  as.data.frame() %>%
  rownames_to_column(var = "site1") %>%
  pivot_longer(cols = -site1, names_to = "site2", values_to = "sample.diff")

mrm_survey_data <- species_beta %>%
  filter(group == "FL" & site1 != site2) %>%
  left_join(survey_sample_diff) %>%
  dplyr::select(site1, site2, beta, elev.diff, sample.diff, mgmt.diff) %>%
  mutate(elev.diff = scale(elev.diff), # gotta scale variables for MRM
         sample.diff = scale(sample.diff))

mrm_net_data <- species_beta %>%
  filter(group == "BB" & site1 != site2) %>%
  left_join(net_sample_diff)  %>%
  dplyr::select(site1, site2, beta, elev.diff, sample.diff, mgmt.diff) %>%
  mutate(elev.diff = scale(elev.diff),
         sample.diff = scale(sample.diff))

mrm_beta_data <- beta_mit_data %>%
  filter(site1 != site2) %>%
  left_join(net_sample_diff)  %>%
  dplyr::select(site1, site2, value, metric, elev.diff, sample.diff, mgmt.diff) %>%
  mutate(elev.diff = scale(elev.diff),
         sample.diff = scale(sample.diff))

# Function for tabulating modle coefficients
mrm_tab <- function(x, response) {
  x %>%
    as.data.frame() %>%
    rownames_to_column(var = "predictor") %>%
    slice(-1) %>%
    mutate(response = rep(response, n()),
           Predictor = case_when(
             predictor == "elev.diff" ~ "elevation",
             predictor == "sample.diff" ~ "sampling freq.",
             predictor == "mgmt.diff" ~ "management")) %>%
    dplyr::select(response, Predictor, b, pval) %>%
    tibble()
}

# Call models
mrm_fl <- MRM(beta ~ elev.diff + sample.diff + mgmt.diff, 
              data = mrm_survey_data,
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("Flora")

mrm_bb <- MRM(beta ~ elev.diff + sample.diff + mgmt.diff, 
              data = mrm_net_data,
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("Bumble bees")

mrm_WN <- MRM(value ~ elev.diff + sample.diff + mgmt.diff, 
              data = filter(mrm_beta_data, metric == "WN"),
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("Total interactions")

mrm_ST <- MRM(value ~ elev.diff + sample.diff + mgmt.diff, 
              data = filter(mrm_beta_data, metric == "ST"),
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("ST partition")

mrm_ST.l <- MRM(value ~ elev.diff + sample.diff + mgmt.diff, 
              data = filter(mrm_beta_data, metric == "ST.l"),
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("ST.l partition")

mrm_ST.h <- MRM(value ~ elev.diff + sample.diff + mgmt.diff, 
              data = filter(mrm_beta_data, metric == "ST.h"),
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("ST.h partition")

mrm_ST.lh <- MRM(value ~ elev.diff + sample.diff + mgmt.diff, 
              data = filter(mrm_beta_data, metric == "ST.lh"),
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("ST.lh partition")

mrm_OS <- MRM(value ~ elev.diff + sample.diff + mgmt.diff, 
              data = filter(mrm_beta_data, metric == "OS"),
              nperm = 1000,
              method = "logistic")$coef %>%
  mrm_tab("Rewiring partition")

# Tabulate results
mrm_results <- bind_rows(mrm_fl, mrm_bb, mrm_WN, mrm_ST, 
                         mrm_ST.h, mrm_ST.l, mrm_ST.lh, mrm_OS) %>%
  gt(groupname_col = "response") %>%
  tab_style(
    style = list(cell_text(weight = "bold")),
    locations = list(cells_column_labels(everything()))
  ) %>%
  tab_style(
    style = list(cell_text(style = "italic")),
    locations = list(cells_group(everything()))
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = vars(pval),
      rows = pval < 0.05
    ))

gtsave(mrm_results,"../output/mrm_tab.pdf")

mrm_results_sub <- bind_rows(mrm_fl, mrm_bb, mrm_WN) %>%
  gt(groupname_col = "response") %>%
  tab_style(
    style = list(cell_text(weight = "bold")),
    locations = list(cells_column_labels(everything()))
  ) %>%
  tab_style(
    style = list(cell_text(style = "italic")),
    locations = list(cells_group(everything()))
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold")
      ),
    locations = cells_body(
      columns = vars(pval),
      rows = pval < 0.05
    ))
```

# Making plotUncertainty not suck
```{r}
test <- plotUncertainty3(sitepair_survey, 
                sampleSites = 0.7, 
                bsIters = 100, 
                geo  = FALSE,
                splines = c(6, 6, 6, 6, 6),
                splineCol = "black", 
                plot.layout = c(1,3))

fullPlotX_list[p] <- tibble(fullPlotX)
fullPlotY_list[p] <- tibble(fullPlotY)
highBoundX_list[p] <- tibble(highBoundX)
highBoundY_list[p] <- tibble(highBoundY)
lowBoundX_list[p] <- tibble(lowBoundX)
lowBoundY_list[p] <- tibble(lowBoundY)
      

elev_tab <- tibble(test[[1]][[1]],
                   test[[1]][[2]],
                   test[[1]][[3]],
                   test[[1]][[4]],
                   test[[1]][[5]]) %>%
  select(a = 1, b = 2, c = 3, d = 4, e = 5)

ggplot(elev_tab, aes(a, b)) +
  geom_line()

ggplot(elev_tab, aes(a, c)) +
  geom_line()

ggplot(elev_tab, aes(a, d)) +
  geom_line()

ggplot(elev_tab, aes(a, e)) +
  geom_line()

ggplot(elev_tab, aes(b, c)) +
  geom_line()

##########################################################################
plotUncertainty3 <- function(spTable, sampleSites, bsIters, geo=FALSE, splines=NULL, 
                           knots=NULL, splineCol="blue", errCol="grey80", 
                           plot.linewidth=2.0, plot.layout=c(2,2), parallel=FALSE,
                           cores=2){
  fullPlotX_list <- list()
  fullPlotY_list <- list()
  highBoundX_list <- list()
  highBoundY_list <- list()
  lowBoundX_list <- list()
  lowBoundY_list <- list()
  
  ##A function to plot the uncertantiy of each variable from a GDM model
  #################
  #spTable <- sitePairTab          ##the input site-pair table to subsample from
  #sampleSites <- 0.9     ##fraction of sites that should be retained from site pair table 
  #bsIters <- 50       ##the number of times the site-pair table should be sampled
  #geo <- F              ##rather or not the gdm model takes geography into account, see gdm
  #splines <- NULL       ##splines gdm setting, see gdm
  #knots <- NULL         ##knots gdm setting, see gdm
  #splineCol <- "blue"    ##color of the center line
  #errCol <- "grey80"        ##color of the uncertainty polygon
  #plot.linewidth <- 2.0    ##line width of the center line
  #plot.layout <- c(3,3)    ##number of plots per page
  #parallel <- F            ##rather or not the sampling should happen in parallel processing, to speed it up
  #cores <- 6               ##number of cores to if parallel processing
  #################
  ##function breaks and warnings
  ##makes sure that table is a properly formated site-pair table
  if(!is(spTable, "gdmData")){
    warning("The spTable object is not of class 'gdmData'. See the formatsitepair function for help.")
  }
  ##checks to makes sure table is a matrix or table frame
  if(!(is(spTable, "gdmData") | is(spTable, "matrix") | is(spTable, "data.frame"))){
    stop("The spTable object must be of class 'gdmData', 'matrix', or 'data.frame'.")
  }
  
  ##sanity check on the data table
  if(ncol(spTable) < 6){
    stop("spTable object requires at least 6 columns: Observed, weights, s1.xCoord, s1.yCoord, s2.xCoord, s2.yCoord")
  }  
  if(nrow(spTable) < 1){
    stop("spTable object has < 1 rows.")
  }
  
  ##checks that geo has either TRUE or FALSE
  if(!(geo==TRUE | geo==FALSE)){
    stop("geo argument must be either TRUE or FALSE")
  }
  ##makes sure splines is a numeric vector
  if(is.null(splines)==FALSE & !is(splines, "numeric")){
    stop("splines object must of of class = 'numeric'.")
  }
  ##checks knots inputs
  if(is.null(knots)==FALSE & !is(knots, "numeric")){
    stop("knots object must of of class = 'numeric'.")
  }
  
  ##checks that parallel has either TRUE or FALSE
  if(!(parallel==TRUE | parallel==FALSE)){
    stop("parallel argument must be either TRUE or FALSE")
  }
  ##makes sure that cores has a value when parallel is true
  if(parallel==TRUE & is.null(cores)==TRUE){
    stop("If parallel==TRUE, the number of cores must be specified")
  }
  ##makes sure that cores is a positive integer 
  if((is.null(cores)==FALSE & is.numeric(cores)==FALSE) | cores<1){
    stop("argument cores needs to be a positive integer")
  }
  
  ##makes sure that bsIters is a positive integer 
  if((is.null(bsIters)==FALSE & is.numeric(bsIters)==FALSE) | bsIters<1){
    stop("argument bsIters needs to be a positive integer")
  }
  ##makes sure sampleSites is a number
  if(is.numeric(sampleSites)==FALSE){
    stop("sampleSites must be a number between 0 and 1")
  }
  ##makes sure that sampleSites is between 0 and 1
  if(sampleSites < 0){
    stop("sampleSites must be a number between 0 and 1")
  }
  if(sampleSites > 1){
    stop("sampleSites must be a number between 0 and 1")
  }
  if(sampleSites==0){
    stop("a sampleSites value of 0 will remove all sites from the analysis (bad).")
  }
  ##double makes sure these values are integers, seems to truncate if not
  cores <- as.integer(cores)
  bsIters <- as.integer(bsIters)
  
  ##assign k to prevent issues to cran checking
  k <- NULL
  
  ##makes copies of the site-pair table in order to randomly subsample each one differently
  lstSP <- lapply(1:bsIters, function(i){spTable})
  
  ##runs parallel if desired by the users
  if(parallel==TRUE){
    ##loads libraries
    #require(foreach)
    #require(doParallel)
    #requireNamespace("foreach")
    #requireNamespace("parallel")
    #requireNamespace("doParallel")
    
    ##sets cores
    cl <- makeCluster(cores, outfile="")
    registerDoParallel(cl)
    ##first removes a number of sites according to input
    subSamps <- foreach(k=1:length(lstSP), .verbose=F, .packages=c("gdm")) %dopar%
                      removeSitesFromSitePair(lstSP[[k]], sampleSites=sampleSites)
    ##models the subsamples
    gdmMods <- foreach(k=1:length(subSamps), .verbose=F, .packages=c("gdm")) %dopar%
                     #gdmMods <- try(foreach(k=1, .verbose=F, .packages=c("gdm")) %dopar%
                     gdm(subSamps[[k]], geo=geo, splines=splines, knots=knots)
    stopCluster(cl)
  }else{
    ##first removes a number of sites according to input
    subSamps <- lapply(lstSP, removeSitesFromSitePair, sampleSites=sampleSites)
    ##models the subsamples
    gdmMods <- lapply(subSamps, gdm, geo=geo, splines=splines, knots=knots)
  }
  
  ##models the full gdm
  fullGDMmodel <- gdm(spTable, geo=geo, splines=splines, knots=knots)
    
  ##Extracts the splines for each model
  exUncertSplines <- lapply(gdmMods, isplineExtract2)
  fullGDMsplines <- isplineExtract2(fullGDMmodel)
  
  ##get the names of the predictor variables
  predVars <- colnames(exUncertSplines[[1]][[1]])
  
  ##establish what plot layout to use
  thisplot <- 0
  one_page_per_plot <- FALSE
  if ((plot.layout[1]==1) && (plot.layout[2]==1)){
    one_page_per_plot <- TRUE
  }else{
    par(mfrow=plot.layout)
  }
  
  ##sets the plotting minimum and maximum y-values 
  totalYmin <- Inf
  totalYmax <- -Inf
  
  ##determines the bounds of the plots
  for(p in 1:length(predVars)){
    #p=1
    predV <- predVars[p]
    
    ##gets the minimum and maximum, to set the ploting extent
    for(nm in 1:length(exUncertSplines)){
      #nm=1
      selPlot <- exUncertSplines[[nm]]
      
      spYmax <- max(selPlot[[2]][,predV])
      spYmin <- min(selPlot[[2]][,predV])
      
      totalYmax <- max(c(totalYmax, spYmax))
      totalYmin <- min(c(totalYmin, spYmin))
    }
  }
  
  ##plots by variable
  for(p in 1:length(predVars)){
    #p <- 1
    predV <- predVars[p]
    
    ##sets the plotting minimum and maximum x-values
    totalXmin <- Inf
    totalXmax <- -Inf
    ##gets the minimum and maximum, to set the ploting extent
    for(nm in 1:length(exUncertSplines)){
      #nm=1
      selPlot <- exUncertSplines[[nm]]
      
      spXmax <- max(selPlot[[1]][,predV])
      spXmin <- min(selPlot[[1]][,predV])
      
      if(spXmax > totalXmax){totalXmax = spXmax}
      if(spXmin < totalXmin){totalXmin = spXmin}
    }
    
    ##checks to make sure that there is some significance, if there is the the data is plotted
    if(totalYmax!=0){
      ##add mean of subsets to plot
      plotX <- NULL
      plotY <- NULL
      byVarMatX <- NULL
      byVarMatY <- NULL
      ##create matrices based on the variable and its x and y location for each model iteration
      for(nn in 1:length(exUncertSplines)){
        #nn=1
        plotX[[nn]] <- exUncertSplines[[nn]][[1]]
        plotY[[nn]] <- exUncertSplines[[nn]][[2]]
        byVarMatY <- cbind(byVarMatY, plotY[[nn]][,predV])
        byVarMatX <- cbind(byVarMatX, plotX[[nn]][,predV])
      }
      ##gets spline data from the full gdm model
      fullPlotX <- fullGDMsplines[[1]]
      fullPlotX <- fullPlotX[,predV]
      fullPlotY <- fullGDMsplines[[2]]
      fullPlotY <- fullPlotY[,predV]
      
      ##calculates the confidence intervals for plotting
      sdX <- apply(as.matrix(byVarMatX), 1, sd)
      sdY <- apply(as.matrix(byVarMatY), 1, sd)
      highBoundX <- fullPlotX + sdX
      lowBoundX <- fullPlotX - sdX
      highBoundY <- fullPlotY + sdY
      lowBoundY <- fullPlotY - sdY
      
      # outList[p] <- tibble(fullPlotX, fullPlotY,
      #                      highBoundX, highBoundY,
      #                      lowBoundX, lowBoundY)
      
      fullPlotX_list[p] <- tibble(fullPlotX)
      fullPlotY_list[p] <- tibble(fullPlotY)
      highBoundX_list[p] <- tibble(highBoundX)
      highBoundY_list[p] <- tibble(highBoundY)
      lowBoundX_list[p] <- tibble(lowBoundX)
      lowBoundY_list[p] <- tibble(lowBoundY)

      # ##collects the data to be used in the rug plot
      # if(predV=="Geographic"){
      #   ##calculates unique eucildian distance between sites
      #   rugData <- unique(sqrt(((spTable$s1.xCoord-spTable$s2.xCoord)^2)+((spTable$s1.yCoord-spTable$s2.yCoord)^2)))
      # }else{
      #   ##gets unique values of variable data
      #   varDat <- grep(predV, colnames(spTable))
      #   rugData <- unique(c(spTable[,c(varDat[1])], spTable[,c(varDat[2])]))
      # }
      # 
      # ##plots one graph per page, unless specified otherwise
      # if (one_page_per_plot){
      #   dev.new()
      #   dev.next()
      # }else{
      #   thisplot <- thisplot + 1
      #   if(thisplot > (plot.layout[1] * plot.layout[2])){
      #     thisplot <- 1
      #     par(mfrow=plot.layout)
      #   }
      # }
      # #settings <- par(pars)
      # ##plots mean data line and polygon of uncertanty
      # plot(NULL, xlim=c(totalXmin, totalXmax), ylim=c(totalYmin, totalYmax), xlab=predV, ylab="Partial Ecological Distance")
      # polygon(c(lowBoundX, rev(highBoundX)), c(lowBoundY, rev(highBoundY)), col=errCol, border=NA)
      # lines(fullPlotX, fullPlotY, col=splineCol, lwd=plot.linewidth)
      # rug(rugData)
    }
  }
  return(list(fullPlotX_list, fullPlotY_list,
              highBoundX_list, highBoundY_list,
              lowBoundX_list, lowBoundY_list))
}
##########################################################################
```