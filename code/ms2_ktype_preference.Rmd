---
title: "visitation_bias"
author: "Doug Sponsler"
date: "12/14/2020"
output: html_document
---
# Preparations
## Packages 
```{r, warning=FALSE, include=FALSE, echo = FALSE}
library(bipartite)
library(brms)
library(bayesplot)
library(tidybayes)
library(mgcv)
library(mgcViz)
library(DHARMa)
library(modelr)
library(ggdist)
library(vegan)
library(ggvegan)
library(ggrepel)
library(tidymv)
library(patchwork)
library(tidymodels)
library(tidyverse)
library(lubridate)

rstan::rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
```

## Load data
```{r message=FALSE, warning=FALSE, include=FALSE, echo = FALSE}
prop_visits_ktype <- read_csv("../data/processed_data/prop_visits_ktype.csv") %>%
  mutate(ktype = factor(ktype), # recode variables
         tongue = factor(tongue),
         visits = as.integer(visits))
 
prop_visits_ktype_pooled <- read_csv("../data/processed_data/prop_visits_ktype_pool.csv") %>%
  mutate(ktype = factor(ktype), # recode variables
         visits = as.integer(visits))
```


1.2 Binomial multi-level regression models
### 1.2.1 Choose priors
```{r}
# For starters, I'm just going to replace the flat prior on the fixed effects we a weakly regularizing prior (on the logit scale)
brm_pvis_prior <- prior(normal(0, 1.5), 
                        class = b) 
```

### 1.2.2 Call models
All these run cleanly. Well, brm_pvis_01 throws maximum tree depth warnings, but these are just about efficiency, not validity. These warnings are evidently a consequence of increasing adapt_delta to 0.99, which succeeded in getting rid of the divergent transition warnings (those warnings are much more serious and pertain to the validity of the model). 
```{r}
## Exploring the differential bias of bumble bee species and tongue length classes towards floral morphotypes
### Bernoulli with binarized visitation
brm_pvis_00 <- brm(as.integer(visits.bin) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 + perc.flower.cover | ktype:tongue) + # a random intercept and slope for ktype:tongue
                    (1 | ktype:site), # a varying intercept and slope for ktype:site
                  family = "bernoulli", 
                  prior = brm_pvis_prior, # weakly regularizing
                  file = "../output/brm_pvis_ktype_00",  # for running locally
                  #file = "brm_pvis_ktype_00", # for running on the HPC
                  chains = 4,
                  #cores = 12,
                  iter = 5000,
                  data = filter(prop_visits_ktype, !ktype %in% c("0", "9", "10")))


brm_pvis_01 <- brm(as.integer(visits.bin) ~
                    bb.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype) + # a random intercept and slope for ktype
                    (1 | ktype:site),  # a varying intercept term for ktype:site
                  family = "bernoulli", 
                  prior = brm_pvis_prior, # weakly regularizing
                  control = list(adapt_delta = 0.99), # the default setting yielded divergent transitions
                  file = "../output/brm_pvis_ktype_01",  # for running locally
                  #file = "brm_pvis_ktype_01", # for running on the HPC
                  chains = 4,
                  #cores = 12,
                  iter = 5000,
                  data = filter(prop_visits_ktype_pooled, !ktype %in% c("0", "9", "10")))


# If I want to make inference about species visitation rates, I don't need the tongue-length class effect; I just need the site effect. But, when I want to make inference about the tongue length classes, I do need the species-level effect.
brm_pvis_02 <- brm(as.integer(visits.bin) ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 | ktype:site), # a varying intercept and slope for ktype:site
                  family = "bernoulli", 
                  prior = brm_pvis_prior, # weakly regularizing
                  file = "../output/brm_pvis_ktype_02",  # for running locally
                  #file = "brm_pvis_ktype_02", # for running on the HPC
                  chains = 4,
                  #cores = 12,
                  iter = 5000, # Bulk ESS was a bit low wit 2000 iter
                  data = filter(prop_visits_ktype, !ktype %in% c("0", "9", "10")))
```

### Fixed effects versions of the models
```{r}
brm_pvis_10 <- brm(visits.bin ~
                    bb.sp.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    ktype:tongue +
                     perc.flower.cover:ktype:tongue +
                    (1 + perc.flower.cover | ktype:bb.sp) + # a random intercept and random slope for ktype:species; I think I need to model this before I can make conclusions about ktype:pbl.class
                    (1 | ktype:site), # a varying intercept and slope for ktype:site
                  family = "bernoulli", 
                  prior = brm_pvis_prior, # weakly regularizing
                  #file = "../output/brm_pvis_ktype_10",  # for running locally
                  file = "brm_pvis_ktype_10", # for running on the HPC
                  chains = 4,
                  #cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype, !ktype %in% c("0", "9", "10")))

conditional_effects(brm_pvis_10)

brm_pvis_11 <- brm(as.integer(visits.bin) ~
                    bb.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    ktype +
                    perc.flower.cover:ktype +
                    (1 | ktype:site),  # a varying intercept term for ktype:site
                  family = "bernoulli", 
                  prior = brm_pvis_prior, # weakly regularizing
                  #control = list(adapt_delta = 0.99), # the default setting yielded divergent transitions
                  file = "../output/brm_pvis_ktype_11",  # for running locally
                  #file = "brm_pvis_ktype_11", # for running on the HPC
                  chains = 4,
                  #cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype_pooled, !ktype %in% c("0", "9", "10")))

conditional_effects(brm_pvis_11)

# My intention is that ~ 0 will force the intercept of the fixed slope effects to be zero, since in fact visitation probability must be zero when there are either no  bees or  no flowers.
brm_pvis_11b <- brm(as.integer(visits.bin) ~ 0 +
                    bb.abund*perc.flower.cover + # fixed term: because more abundant flowers will tend to be more visited,and more abundance bees visit more
                    ktype +
                    perc.flower.cover:ktype +
                    (1 | ktype:site),  # a varying intercept term for ktype:site
                  family = "bernoulli", 
                  prior = brm_pvis_prior, # weakly regularizing
                  #control = list(adapt_delta = 0.99), # the default setting yielded divergent transitions
                  file = "../output/brm_pvis_ktype_11b",  # for running locally
                  #file = "brm_pvis_ktype_11b", # for running on the HPC
                  chains = 4,
                  #cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype_pooled, !ktype %in% c("0", "9", "10")))

conditional_effects(brm_pvis_11b)

brm_pvis_21 <- brm(prop.visits ~
                    perc.flower.cover*ktype +
                    (1 | ktype:site),  # a varying intercept term for ktype:site
                  family = "zero_one_inflated_beta", 
                  #prior = brm_pvis_prior, # weakly regularizing
                  #control = list(adapt_delta = 0.99), # the default setting yielded divergent transitions
                  #file = "../output/brm_pvis_ktype_21",  # for running locally
                  file = "brm_pvis_ktype_21", # for running on the HPC
                  chains = 4,
                  #cores = 12,
                  iter = 2000,
                  data = filter(prop_visits_ktype_pooled, !ktype %in% c("0", "9", "10")))

conditional_effects(brm_pvis_11)
```

## 1.3 Evaluate models
```{r eval=FALSE, include=FALSE}
# Summary
summary(brm_pvis_00)
summary(brm_pvis_01)
summary(brm_pvis_02)

# Posterior predictive checks
pp_check(brm_pvis_00)
pp_check(brm_pvis_01)
pp_check(brm_pvis_02)

# MCMC convergence
plot(brm_pvis_00)
plot(brm_pvis_01)
plot(brm_pvis_02)

# Bayes R2
bayes_R2(brm_pvis_00)
bayes_R2(brm_pvis_01)
bayes_R2(brm_pvis_02)
```

## 1.4 Preliminary visualization
```{r eval=FALSE, include=FALSE}
get_variables(brm_pvis_00)
conditional_effects(brm_pvis_00)
mcmc_plot(brm_pvis_00, pars = c("^r_ktype:tongue.*Intercept]$"))
mcmc_plot(brm_pvis_00, pars = c("^r_ktype:tongue.*perc.flower.cover]$"))
mcmc_plot(brm_pvis_00, pars = c("^r_ktype:bb.sp.*Intercept]$"))
mcmc_plot(brm_pvis_00, pars = c("^r_ktype:bb.sp.*perc.flower.cover]$"))
mcmc_plot(brm_pvis_00, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis_00, pars = c("^r_ktype:site.*perc.flower.cover]$"))


get_variables(brm_pvis_01)
conditional_effects(brm_pvis_01)
mcmc_plot(brm_pvis_01, pars = c("^r_ktype*"))
mcmc_plot(brm_pvis_01, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis_01, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis_01, pars = c("^r_ktype:site.*perc.flower.cover]$"))

get_variables(brm_pvis_02)
conditional_effects(brm_pvis_02)
mcmc_plot(brm_pvis_02, pars = c("^r_ktype"))
mcmc_plot(brm_pvis_02, pars = c("^r_ktype:bb.sp.*Intercept]$"))
mcmc_plot(brm_pvis_02, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis_02, pars = c("^r_ktype:bb.sp.*perc.flower.cover]$"))
mcmc_plot(brm_pvis_02, pars = c("^r_ktype:site.*Intercept]$"))
mcmc_plot(brm_pvis_02, pars = c("^r_ktype:site.*perc.flower.cover]$"))
```

## 1.5 Final visualization
### 1.5.1 morphotype:tongue intercept
```{r}
brm_pvis_00_plotframe1 <- brm_pvis_00 %>%
  spread_draws(b_Intercept, `r_ktype:tongue`[condition, term]) %>% # the back ticks are necessary to escape the :
  rename(r_ktype.tongue = `r_ktype:tongue`) %>% # get rid of the problematic :
  filter(term == "Intercept") %>% # drop slope terms for now
  mutate(condition_mean = b_Intercept + r_ktype.tongue) %>% # get conditional mean
  group_by(condition) %>% # group by tongue:morpotype pair
  point_interval(condition_mean, .width = c(0.95, 0.66)) %>% # calculate credible intervals
  mutate(condition_mean_trans = exp(condition_mean), # exponentiating the estimates gets us back to the response scale (negbinomial uses log link function)
         .lower_trans = exp(.lower),
         .upper_trans = exp(.upper)) %>% 
separate(condition, c("ktype", "tongue"), sep = "_", remove = FALSE) %>% # separate condition term into ktype and tongue
  mutate(ktype = case_when( # rename
    ktype == "1" ~ "Disc (1)",
    ktype == "2" ~ "Funnel (2)",
    ktype == "3" ~ "Bell (3)",
    ktype == "4" ~ "Stalk-disc (4)",
    ktype == "5" ~ "Lip (5)",
    ktype == "6" ~ "Flag (6)",
    ktype == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype, levels = c("Disc (1)", "Funnel (2)", # relevel
                                          "Bell (3)", "Stalk-disc (4)", "Lip (5)", 
                                          "Flag (6)", "Head (7)"))) %>%
  mutate(tongue = factor(tongue, levels = c("long", "med", "short")))

ggplot(brm_pvis_00_plotframe1, aes(condition_mean_trans, rev(tongue), 
                                 xmin = .lower_trans, xmax = .upper_trans,
                                 color = tongue, fill = tongue)) +
  geom_pointinterval() +
  facet_wrap(~ktype, scales = "free") +
  theme_light() +
  labs(color = "Tongue length", x = "Visitation probability") +
  guides(fill = FALSE) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

ggsave(file = "../output/brm_pvis_00_plot1.pdf", width = 6, height = 5)
ggsave(file = "../output/brm_pvis_00_plot1.png", width = 6, height = 5)
```

### 1.5.2 morphotype:bb.sp intercept
```{r}
brm_pvis_02_plotframe2 <- brm_pvis_02 %>%
  spread_draws(b_Intercept, `r_ktype:bb.sp`[condition, term]) %>% # the back ticks are necessary to escape the :
  rename(r_ktype.bb.sp = `r_ktype:bb.sp`) %>% # get rid of the problematic :
  filter(term == "Intercept") %>% # drop slope terms for now
  mutate(condition_mean = b_Intercept + r_ktype.bb.sp) %>% # get conditional mean
  group_by(condition) %>% # group by bb.sp:morpotype pair
  point_interval(condition_mean, .width = c(0.95, 0.66)) %>% # calculate credible intervals
  mutate(condition_mean_trans = inv_logit_scaled(condition_mean), # exponentiating the estimates gets us back to the response scale (negbinomial uses log link function)
         .lower_trans = inv_logit_scaled(.lower),
         .upper_trans = inv_logit_scaled(.upper)) %>% 
separate(condition, c("ktype", "bb.sp"), sep = "_", remove = FALSE) %>% # separate condition term into ktype and bb.sp
  mutate(ktype = case_when( # rename
    ktype == "1" ~ "Disc (1)",
    ktype == "2" ~ "Funnel (2)",
    ktype == "3" ~ "Bell (3)",
    ktype == "4" ~ "Stalk-disc (4)",
    ktype == "5" ~ "Lip (5)",
    ktype == "6" ~ "Flag (6)",
    ktype == "7" ~ "Head (7)")
  ) %>%
   mutate(ktype = factor(ktype, levels = c("Disc (1)", "Funnel (2)", # relevel
                                          "Bell (3)", "Stalk-disc (4)", "Lip (5)", 
                                          "Flag (6)", "Head (7)"))) %>%
  left_join(bb_traits) %>%
  mutate(bb.sp = factor(bb.sp, levels = c("telu", "soro", "pyre", "psit", "prat", "lapi", "jone",
                                           "wurf", "pasc", "muci", "mont", "hypn",
                                           "mend", "hort", "gers")))

ggplot(brm_pvis_02_plotframe2, aes(condition_mean_trans, bb.sp, 
                                 xmin = .lower_trans, xmax = .upper_trans,
                                 color = pbl.w.class2, fill = pbl.w.class2)) +
  geom_pointinterval() +
  facet_wrap(~ktype, scales = "free") +
  theme_light() +
  labs(color = "Tongue length", x = "Visitation probability", y = "Morphotype") +
  guides(fill = FALSE) 

ggsave(file = "../output/brm_pvis_02_plot1.pdf", width = 8, height = 8)
ggsave(file = "../output/brm_pvis_02_plot1.png", width = 8, height = 8)
```

### 1.5.3 morphotype:tongue slope
```{r eval=FALSE, include=FALSE}
brm_pvis_00_plotframe3 <- brm_pvis_00 %>%
  spread_draws(b_perc.flower.cover, `r_ktype:tongue`[condition, term]) %>% # the back ticks are necessary to escape the :
  rename(r_ktype.tongue = `r_ktype:tongue`) %>%
  filter(term == "perc.flower.cover") %>%
  mutate(condition_slope = b_perc.flower.cover + r_ktype.tongue) %>%
  separate(condition, c("ktype", "tongue"), sep = "_", remove = FALSE) %>%
  mutate(ktype = case_when(
    ktype == "1" ~ "Disc (1)",
    ktype == "2" ~ "Funnel (2)",
    ktype == "3" ~ "Bell (3)",
    ktype == "4" ~ "Stalk-disc (4)",
    ktype == "5" ~ "Lip (5)",
    ktype == "6" ~ "Flag (6)",
    ktype == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype,
                        levels = c("Disc (1)", "Funnel (2)", "Bell (3)", "Stalk-disc (4)",
                                   "Lip (5)", "Flag (6)", "Head (7)")))


ggplot(brm_pvis_00_plotframe3, aes(condition_slope, tongue, color = tongue)) +
  stat_pointinterval() +
  facet_grid(ktype~.) +
  theme_light() +
  labs(color = "Tongue length", x = "Slope of logit-likelihood") +
  guides(fill = FALSE) +
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank())

ggsave(file = "../output/brm_pvis_00_plot3.png", width = 7, height = 5.5)
```

### 1.5.3 morphotype intercept
```{r}
brm_pvis_01_plotframe1 <- brm_pvis_01 %>%
  spread_draws(b_Intercept, r_ktype[condition, term]) %>% # the back ticks are necessary to escape the :
  filter(term == "Intercept") %>% # drop slope terms for now
  mutate(condition_mean = b_Intercept + r_ktype) %>% # get conditional mean
  group_by(condition) %>% # group by tongue:morpotype pair
  point_interval(condition_mean, .width = c(0.95, 0.66)) %>% # calculate credible intervals
  mutate(condition_mean_trans = inv_logit_scaled(condition_mean), # exponentiating the estimates gets us back to the response scale (negbinomial uses log link function)
         .lower_trans = inv_logit_scaled(.lower),
         .upper_trans = inv_logit_scaled(.upper)) %>% 
  mutate(ktype = case_when( # rename
    condition == "1" ~ "Disc (1)",
    condition == "2" ~ "Funnel (2)",
    condition == "3" ~ "Bell (3)",
    condition == "4" ~ "Stalk-disc (4)",
    condition == "5" ~ "Lip (5)",
    condition == "6" ~ "Flag (6)",
    condition == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype, levels = c("Head (7)", "Flag (6)", # relevel
                                          "Lip (5)", "Stalk-disc (4)", "Bell (3)", 
                                          "Funnel (2)", "Disc (1)")))

ggplot(brm_pvis_01_plotframe1, aes(condition_mean_trans, ktype, 
                                 xmin = .lower_trans, xmax = .upper_trans)) +
  geom_pointinterval() +
  theme_light(16) +
  labs(x = "Visitation probability", y= "Morphotype") +
  guides(fill = FALSE)

ggsave(file = "../output/brm_pvis_01_plot1.pdf", width = 6, height = 7)
ggsave(file = "../output/brm_pvis_01_plot1.png", width = 6, height = 7)
```

### 1.5.3 morphotype slope
```{r eval=FALSE, include=FALSE}
brm_pvis_01_plotframe2 <- brm_pvis_01 %>%
  spread_draws(b_perc.flower.cover, r_ktype[condition, term]) %>% # the back ticks are necessary to escape the :
  filter(term == "perc.flower.cover") %>%
  mutate(condition_slope = b_perc.flower.cover + r_ktype) %>%
  mutate(ktype = case_when(
    condition == "0" ~ "NA (0)",
    condition == "1" ~ "Disc (1)",
    condition == "2" ~ "Funnel (2)",
    condition == "3" ~ "Bell (3)",
    condition == "4" ~ "Stalk-disc (4)",
    condition == "5" ~ "Lip (5)",
    condition == "6" ~ "Flag (6)",
    condition == "7" ~ "Head (7)")
  ) %>%
  mutate(ktype = factor(ktype,
                        levels = c("Disc (1)", "Funnel (2)", "Bell (3)", "Stalk-disc (4)",
                                   "Lip (5)", "Flag (6)", "Head (7)", "NA (0)"))) 

ggplot(brm_pvis_01_plotframe2, aes(condition_slope, ktype)) +
  stat_pointinterval() +
  theme_light() +
  labs(color = "Tongue length", x = "Slope of visitation probability ~ percent flower cover") +
  guides(fill = FALSE)

ggsave(file = "../output/brm_pvis_01_plot2.png", width = 7, height = 5.5)
```

## 1.6 Model 1 hypothesis tests
```{r}
get_variables(brm_pvis_01)

hypothesis(brm_pvis_01, "r_ktype[1,Intercept] = r_ktype[4,Intercept]", class = "") 
hypothesis(brm_pvis_01, "r_ktype[2,Intercept] = r_ktype[4,Intercept]", class = "")

hypothesis(brm_pvis_01, "r_ktype[2,Intercept] = r_ktype[1,Intercept]", class = "")
hypothesis(brm_pvis_01, "r_ktype[1,Intercept] = r_ktype[3,Intercept]", class = "") 
hypothesis(brm_pvis_01, "r_ktype[2,Intercept] = r_ktype[3,Intercept]", class = "")
hypothesis(brm_pvis_01, "r_ktype[4,Intercept] = r_ktype[3,Intercept]", class = "")


hypothesis(brm_pvis_01, "r_ktype[5,Intercept] = r_ktype[6,Intercept]", class = "") 
hypothesis(brm_pvis_01, "r_ktype[5,Intercept] = r_ktype[7,Intercept]", class = "") 
```


## 1.7 Model 2 hypothesis tests
```{r}
get_variables(brm_pvis_00)

# Disc (group  1)
hypothesis(brm_pvis_00, "r_ktype:tongue[1_short,Intercept] = r_ktype:tongue[1_med,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[1_short,Intercept] = r_ktype:tongue[1_long,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[1_med,Intercept] = r_ktype:tongue[1_long,Intercept]", class = "")

# Funnel (group  2)
hypothesis(brm_pvis_00, "r_ktype:tongue[2_short,Intercept] = r_ktype:tongue[2_med,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[2_short,Intercept] = r_ktype:tongue[2_long,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[2_med,Intercept] = r_ktype:tongue[2_long,Intercept]", class = "")

# Bell (group  3)
hypothesis(brm_pvis_00, "r_ktype:tongue[3_short,Intercept] = r_ktype:tongue[3_med,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[3_short,Intercept] = r_ktype:tongue[3_long,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[3_med,Intercept] = r_ktype:tongue[3_long,Intercept]", class = "")

# Stalk-disc (group  4)
hypothesis(brm_pvis_00, "r_ktype:tongue[4_short,Intercept] = r_ktype:tongue[4_med,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[4_short,Intercept] = r_ktype:tongue[4_long,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[4_med,Intercept] = r_ktype:tongue[4_long,Intercept]", class = "")

# Lip (group  5)
hypothesis(brm_pvis_00, "r_ktype:tongue[5_short,Intercept] = r_ktype:tongue[5_med,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[5_short,Intercept] = r_ktype:tongue[5_long,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[5_med,Intercept] = r_ktype:tongue[5_long,Intercept]", class = "")

# Flag (group  6)
hypothesis(brm_pvis_00, "r_ktype:tongue[6_short,Intercept] = r_ktype:tongue[6_med,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[6_short,Intercept] = r_ktype:tongue[6_long,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[6_med,Intercept] = r_ktype:tongue[6_long,Intercept]", class = "")

# Head (group  7)
hypothesis(brm_pvis_00, "r_ktype:tongue[7_short,Intercept] = r_ktype:tongue[7_med,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[7_short,Intercept] = r_ktype:tongue[7_long,Intercept]", class = "")
hypothesis(brm_pvis_00, "r_ktype:tongue[7_med,Intercept] = r_ktype:tongue[7_long,Intercept]", class = "")
```






